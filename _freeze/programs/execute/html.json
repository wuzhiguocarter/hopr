{
  "hash": "03e46be5a6445f81294d0c8664f45d53",
  "result": {
    "markdown": "---\nknit: quarto render\n---\n\n# Programs {#programs}\n\nIn this chapter, you will build a real, working slot machine that you can play by running an R function. When you're finished, you'll be able to play it like this:\n\n```r\nplay()\n## 0 0 DD\n## $0\n\nplay()\n## 7 7 7\n## $80\n```\n\nThe `play` function will need to do two things. First, it will need to randomly generate three symbols; and, second, it will need to calculate a prize based on those symbols. \n\nThe first step is easy to simulate. You can randomly generate three symbols with the `sample` function—just like you randomly \"rolled\" two dice in [Project 1: Weighted Dice]. The following function generates three symbols from a group of common slot machine symbols: diamonds (`DD`), sevens (`7`), triple bars (`BBB`), double bars (`BB`), single bars (`B`), cherries (`C`), and zeroes (`0`). The symbols are selected randomly, and each symbol appears with a different probability:\n\n```r\nget_symbols <- function() {\n  wheel <- c(\"DD\", \"7\", \"BBB\", \"BB\", \"B\", \"C\", \"0\")\n  sample(wheel, size = 3, replace = TRUE, \n    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))\n}\n```\n\nYou can use `get_symbols` to generate the symbols used in your slot machine: \n\n```r\nget_symbols()\n## \"BBB\" \"0\"   \"C\"  \n\nget_symbols()\n## \"0\" \"0\" \"0\"\n\nget_symbols()\n## \"7\" \"0\" \"B\"\n```\n\n`get_symbols` uses the probabilities observed in a group of video lottery terminals from Manitoba, Canada. These slot machines became briefly controversial in the 1990s, when a reporter decided to test their payout rate. The machines appeared to pay out only 40 cents on the dollar, even though the manufacturer claimed they would pay out 92 cents on the dollar. The original data collected on the machines and a description of the controversy is available online in [a journal article by W. John Braun](http://bit.ly/jse_Braun). The controversy died down when additional testing showed that the manufacturer was correct.\n\nThe Manitoba slot machines use the complicated payout scheme shown in Table \\@ref(tab:prizes). A player will win a prize if he gets:\n\n* Three of the same type of symbol (except for three zeroes)\n* Three bars (of mixed variety)\n* One or more cherries\n\nOtherwise, the player receives no prize. \n\nThe monetary value of the prize is determined by the exact combination of symbols and is further modified by the presence of diamonds. Diamonds are treated like \"wild cards,\" which means they can be considered any other symbol if it would increase a player's prize. For example, a player who rolls `7` `7` `DD` would earn a prize for getting three sevens. There is one exception to this rule, however: a diamond cannot be considered a cherry unless the player also gets one real cherry. This prevents a dud roll like, `0` `DD` `0` from being scored as `0` `C` `0`. \n\nDiamonds are also special in another way. Every diamond that appears in a combination doubles the amount of the final prize. So `7` `7` `DD` would actually be scored _higher_ than `7` `7` `7`. Three sevens would earn you $80, but two sevens and a diamond would earn you $160. One seven and two diamonds would be even better, resulting in a prize that has been doubled twice, or $320. A jackpot occurs when a player rolls `DD` `DD` `DD`. Then a player earns $100 doubled three times, which is $800.\n\nTable: (\\#tab:prizes) Each play of the slot machine costs $1. A player's symbols determine how much they win. Diamonds (`DD`) are wild, and each diamond doubles the final prize. * = any symbol.\n\n|Combination|Prize($)\n|-----------|--------\n|`DD  DD  DD`|100\n|`7  7  7`|80\n|`BBB  BBB  BBB`|40\n|`BB  BB  BB`|25\n|`B  B  B`|10\n|`C  C  C`|10\n|Any combination of bars|5\n|`C  C  *`|5\n|`C  *  C`|5\n|`*  C  C`|5\n|`C  *  *`|2\n|`*  C  *`|2\n|`*  *  C`|2\n\nTo create your `play` function, you will need to write a program that can take the output of `get_symbols` and calculate the correct prize based on  Table \\@ref(tab:prizes). \n\nIn R, programs are saved either as R scripts or as functions. We'll save your program as a function named `score`. When you are finished, you will be able to use `score` to calculate a prize like this:\n\n```r\nscore(c(\"DD\", \"DD\", \"DD\"))\n## 800\n```\n\nAfter that it will be easy to create the full slot machine, like this:\n\n```r\nplay <- function() {\n  symbols <- get_symbols()\n  print(symbols)\n  score(symbols)\n}\n```\n\n::: {.cell type='rmdnote'}\n\\BeginKnitrBlock{rmdnote}<div class=\"rmdnote\">The `print` command prints its output to the console window, which makes `print` a useful way to display messages from within the body of a function.</div>\\EndKnitrBlock{rmdnote}\n:::\n\nYou may notice that `play` calls a new function, `print`. This will help `play` display the three slot machine symbols, since they do not get returned by the last line of the function. The `print` command prints its output to the console window -- even if R calls it from within a function.\n\nIn [Project 1: Weighted Dice], I encouraged you to write all of your R code in an R script, a text file where you can compose and save code. That advice will become very important as you work through this chapter. Remember that you can open an R script in RStudio by going to the menu bar and clicking on File > New File > R Script.\n\n## Strategy\n\nScoring slot-machine results is a complex task that will require a complex algorithm. You can make this, and other coding tasks, easier by using a simple strategy:\n\n* Break complex tasks into simple subtasks.\n* Use concrete examples.\n* Describe your solutions in English, then convert them to R.\n\nLet's start by looking at how you can divide a program into subtasks that are simple to work with.\n\nA program is a set of step-by-step instructions for your computer to follow. Taken together, these instructions may accomplish something very sophisticated. Taken apart, each individual step will likely be simple and straightforward. \n\nYou can make coding easier by identifying the individual steps or subtasks within your program. You can then work on each subtask separately. If a subtask seems complicated, try to divide it again into even subtasks that are even more simple. You can often reduce an R program into substasks so simple that each can be performed with a preexisting function. \n\nR programs contain two types of subtasks: sequential steps and parallel cases.\n\n### Sequential Steps\n\nOne way to subdivide a program is into a series of sequential steps. The `play` function takes the approach, shown in Figure \\@ref(fig:subdivide1). First, it generates three symbols (step 1), then it displays them in the console window (step 2), and then it scores them (step 3): \n\n```r\nplay <- function() {\n\n  # step 1: generate symbols\n  symbols <- get_symbols()\n\n  # step 2: display the symbols\n  print(symbols)\n\n  # step 3: score the symbols\n  score(symbols)\n}\n```\n\nTo have R execute steps in sequence, place the steps one after another in an R script or function body. \n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![The play function uses a series of steps.](images/hopr_0701.png){width=458}\n:::\n:::\n\n### Parallel Cases\n\nAnother way to divide a task is to spot groups of similar cases within the task. Some tasks require different algorithms for different groups of input. If you can identify those groups, you can work out their algorithms one at a time. \n\nFor example, `score` will need to calculate the prize one way if `symbols` contains three of a kind (In that case, `score` will need to match the common symbol to a prize). `score` will need to calculate the prize a second way if the symbols are all bars (In that case, `score` can just assign a prize of $5). And, finally, `score` will need to calculate the prize in a third way if the symbols do not contain three of a kind or all bars (In that case, `score` must count the number of cherries present). `score` will never use all three of these algorithms at once; it will always choose just one algorithm to run based on the combination of symbols. \n\nDiamonds complicate all of this because diamonds can be treated as wild cards. Let's ignore that for now and focus on the simpler case where diamonds double the prize but are not wilds. `score` can double the prize as necessary after it runs one of the following algorithms, as shown in Figure \\@ref(fig:subdivide2).\n\nAdding the `score` cases to the `play` steps reveals a strategy for the complete slot machine program, as shown in Figure \\@ref(fig:subdivide3).\n\nWe've already solved the first few steps in this strategy. Our program can get three slot machine symbols with the `get_symbols` function. Then it can display the symbols with the `print` function. Now let's examine how the program can handle the parallel score cases.\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![The score function must distinguish between parallel cases.](images/hopr_0702.png){width=666}\n:::\n:::\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![The complete slot machine simulation will involve subtasks that are arranged both in series and in parallel.](images/hopr_0703.png){width=782}\n:::\n:::\n\n## if Statements\n\nLinking cases together in parallel requires a bit of structure; your program faces a fork in the road whenever it must choose between cases. You can help the program navigate this fork with an `if` statement.\n\nAn `if` statement tells R to do a certain task for a certain case. In English you would say something like, \"If this is true, do that.\" In R, you would say:\n\n```r\nif (this) {\n  that\n}\n```\n\nThe `this` object should be a logical test or an R expression that evaluates to a single `TRUE` or `FALSE`. If `this` evaluates to `TRUE`, R will run all of the code that appears between the braces that follow the `if` statement (i.e., between the `{` and `}` symbols). If `this` evaluates to `FALSE`, R will skip the code between the braces without running it.\n\nFor example, you could write an `if` statement that ensures some object, `num`, is positive:\n\n```r\nif (num < 0) {\n  num <- num * -1\n}\n```\n\nIf `num < 0` is `TRUE`, R will multiply `num` by negative one, which will make `num` positive: \n\n```r\nnum <- -2\n\nif (num < 0) {\n  num <- num * -1\n}\n\nnum\n## 2\n```\n\nIf `num < 0` is `FALSE`, R will do nothing and `num` will remain as it is—positive (or zero):\n\n```r\nnum <- 4\n\nif (num < 0) {\n  num <- num * -1\n}\n\nnum\n## 4\n```\n\nThe condition of an `if` statement must evaluate to a _single_ `TRUE` or `FALSE`. If the condition creates a vector of `TRUE`s and `FALSE`s (which is easier to make than you may think), your `if` statement will print a warning message and use only the first element of the vector. Remember that you can condense vectors of logical values to a single `TRUE` or `FALSE` with the functions `any` and `all`.\n\nYou don't have to limit your `if` statements to a single line of code; you can include as many lines as you like between the braces. For example, the following code uses many lines to ensure that `num` is positive. The additional lines print some informative statements if `num` begins as a negative number. R will skip the entire code block—`print` statements and all—if `num` begins as a positive number:\n\n```r\nnum <- -1\n\nif (num < 0) {\n  print(\"num is negative.\")\n  print(\"Don't worry, I'll fix it.\")\n  num <- num * -1\n  print(\"Now num is positive.\")\n}\n## \"num is negative.\"\n## \"Don't worry, I'll fix it.\"\n## \"Now num is positive.\"\n\nnum\n## 1\n```\n\nTry the following quizzes to develop your understanding of `if` statements.\n\n::: {.cell name='Quiz A'}\n\n```{.exercise .cell-code}\nWhat will this return?\n```\n:::\n\n```r\nx <- 1\nif (3 == 3) {\n  x <- 2\n}\nx\n```\n\n::: {.cell}\n\n```{.solution .cell-code}\nThe code will return the number 2. `x` begins as 1, and then R encounters the `if` statement. Since the condition evaluates to `TRUE`, R will run `x <- 2`, changing the value of `x`.\n```\n:::\n\n::: {.cell name='Quiz B'}\n\n```{.exercise .cell-code}\nWhat will this return?\n```\n:::\n\n```r\nx <- 1\nif (TRUE) {\n  x <- 2\n}\nx\n```\n\n::: {.cell}\n\n```{.solution .cell-code}\nThis code will also return the number 2. It works the same as the code in Quiz A, except the condition in this statement is already `TRUE`. R doesn't even need to evaluate it. As a result, the code inside the `if` statement will be run, and `x` will be set to 2. \n```\n:::\n\n::: {.cell name='Quiz C'}\n\n```{.exercise .cell-code}\nWhat will this return?\n```\n:::\n\n```r\nx <- 1\nif (x == 1) {\n  x <- 2\n  if (x == 1) {\n    x <- 3\n  }\n}\nx\n```\n\n::: {.cell}\n\n```{.solution .cell-code}\nOnce again, the code will return the number 2. `x` starts out as 1, and the condition of the first `if` statement will evaluate to `TRUE`, which causes R to run the code in the body of the `if` statement. First, R sets `x` equal to 2, then R evaluates the second `if` statement, which is in the body of the first. This time `x == 1` will evaluate to `FALSE` because `x` now equals 2. As a result, R ignores `x <- 3` and exits both `if` statements. \n```\n:::\n\n## else Statements\n\n`if` statements tell R what to do when your condition is _true_, but you can also tell R what to do when the condition is _false_. `else` is a counterpart to `if` that extends an `if` statement to include a second case. In English, you would say, \"If this is true, do plan A; else do plan B.\" In R, you would say:\n\n```r\nif (this) {\n  Plan A\n} else {\n  Plan B\n}\n```\n\n\nWhen `this` evaluates to `TRUE`, R will run the code in the first set of braces, but not the code in the second. When `this` evaluates to `FALSE`, R will run the code in the second set of braces, but not the first. You can use this arrangement to cover all of the possible cases. For example, you could write some code that rounds a decimal to the nearest integer.\n\nStart with a decimal:\n\n```r\na <- 3.14\n```\n\nThen isolate the decimal component with `trunc`:\n\n```r\ndec <- a - trunc(a)\ndec\n## 0.14\n```\n\n::: {.cell type='rmdnote'}\n\\BeginKnitrBlock{rmdnote}<div class=\"rmdnote\">`trunc` takes a number and returns only the portion of the number that appears to the left of the decimal place (i.e., the integer part of the number). </div>\\EndKnitrBlock{rmdnote}\n:::\n\n::: {.cell type='rmdnote'}\n\\BeginKnitrBlock{rmdnote}<div class=\"rmdnote\">`a - trunc(a)` is a convenient way to return the decimal part of `a`.</div>\\EndKnitrBlock{rmdnote}\n:::\n\nThen use an `if else` tree to round the number (either up or down):\n\n```r\nif (dec >= 0.5) {\n  a <- trunc(a) + 1\n} else {\n  a <- trunc(a)\n}\n\na\n## 3\n```\n\nIf your situation has more than two mutually exclusive cases, you can string multiple `if` and `else` statements together by adding a new `if` statement immediately after `else`. For example:\n\n```r\na <- 1\nb <- 1\n\nif (a > b) {\n  print(\"A wins!\")\n} else if (a < b) {\n  print(\"B wins!\")\n} else {\n  print(\"Tie.\")\n}\n## \"Tie.\"\n```\n\nR will work through the `if` conditions until one evaluates to `TRUE`, then R will ignore any remaining `if` and `else` clauses in the tree. If no conditions evaluate to `TRUE`, R will run the final `else` statement.\n\nIf two `if` statements describe mutually exclusive events, it is better to join the `if` statements with an `else if` than to list them separately. This lets R ignore the second `if` statement whenever the first returns a `TRUE`, which saves work.\n\nYou can use `if` and `else` to link the subtasks in your slot-machine function. Open a fresh R script, and copy this code into it. The code will be the skeleton of our final `score` function. Compare it to the flow chart for `score` in Figure \\@ref(fig:subdivide2):\n\n```r\nif ( # Case 1: all the same <1>) {\n  prize <- # look up the prize <3>\n} else if ( # Case 2: all bars <2> ) {\n  prize <- # assign $5 <4>\n} else {\n  # count cherries <5>\n  prize <- # calculate a prize <7>\n}\n\n# count diamonds <6>\n# double the prize if necessary <8>\n```\n\nOur skeleton is rather incomplete; there are many sections that are just code comments instead of real code. However, we've reduced the program to eight simple subtasks: \n\n**<1>** - Test whether the symbols are three of a kind.  \n**<2>** - Test whether the symbols are all bars.  \n**<3>** - Look up the prize for three of a kind based on the common symbol.  \n**<4>** - Assign a prize of $5.  \n**<5>** - Count the number of cherries.  \n**<6>** - Count the number of diamonds.  \n**<7>** - Calculate a prize based on the number of cherries.  \n**<8>** -  Adjust the prize for diamonds.  \n\nIf you like, you can reorganize your flow chart around these tasks, as in Figure \\@ref(fig:subdivide4). The chart will describe the same strategy, but in a more precise way. I'll use a diamond shape to symbolize an `if else` decision.\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![score can navigate three cases with two if else decisions. We can also break some of our tasks into two steps.](images/hopr_0704.png){width=782}\n:::\n:::\n\nNow we can work through the subtasks one at a time, adding R code to the `if` tree as we go. Each subtask will be easy to solve if you set up a concrete example to work with and try to describe a solution in English before coding in R.\n\nThe first subtask asks you to test whether the symbols are three of a kind. How should you begin writing the code for this subtask?\n\nYou know that the final `score` function will look something like this:\n\n```r\nscore <- function(symbols) {\n\n  # calculate a prize\n\n  prize\n}\n```\n\nIts argument, `symbols`, will be the output of `get_symbols`, a vector that contains three character strings. You could start writing `score` as I have written it, by defining an object named `score` and then slowly filling in the body of the function. However, this would be a bad idea. The eventual function will have eight separate parts, and it will not work correctly until _all_ of those parts are written (and themselves work correctly). This means you would have to write the entire `score` function before you could test any of the subtasks. If `score` doesn't work—which is very likely—you will not know which subtask needs fixed.\n\nYou can save yourself time and headaches if you focus on one subtask at a time. For each subtask, create a concrete example that you can test your code on. For example, you know that `score` will need to work on a vector named `symbols` that contains three character strings. If you make a real vector named `symbols`, you can run the code for many of your subtasks on the vector as you go:\n\n```r\nsymbols <- c(\"7\", \"7\", \"7\")\n```\n\nIf a piece of code does not work on `symbols`, you will know that you need to fix it before you move on. You can change the value of `symbols` from subtask to subtask to ensure that your code works in every situation:\n\n```r\nsymbols <- c(\"B\", \"BB\", \"BBB\")\nsymbols <- c(\"C\", \"DD\", \"0\")\n```\n\nOnly combine your subtasks into a `score` function once each subtask works on a concrete example. If you follow this plan, you will spend more time using your functions and less time trying to figure out why they do not work.\n\nAfter you set up a concrete example, try to describe how you will do the subtask in English. The more precisely you can describe your solution, the easier it will be to write your R code.\n\nOur first subtask asks us to \"test whether the symbols are three of a kind.\" This phrase does not suggest any useful R code to me. However, I could describe a more precise test for three of a kind: three symbols will be the same if the first symbol is equal to the second and the second symbol is equal to the third. Or, even more precisely:\n\n_A vector named `symbols` will contain three of the same symbol if the first element of `symbols` is equal to the second element of `symbols` and the second element of `symbols` is equal to the third element of `symbols`_.\n\n::: {.cell name='Write a Test'}\n\n```{.exercise .cell-code}\nTurn the preceding statement into a logical test written in R. Use your knowledge of logical tests, Boolean operators, and subsetting from [R Notation]. The test should work with the vector `symbols` and return a `TRUE` _if and only if_ each element in `symbols` is the same. Be sure to test your code on `symbols`.\n```\n:::\n\n\n::: {.cell}\n\n```{.solution .cell-code}\nHere are a couple of ways to test that `symbols` contains three of the same symbol. The first method parallels the English suggestion above, but there are other ways to do the same test. There is no right or wrong answer, so long as your solution works, which is easy to check because you've created a vector named `symbols`:\n```\n:::\n\n```r\nsymbols\n##  \"7\" \"7\" \"7\"\n\nsymbols[1] == symbols[2] & symbols[2] == symbols[3]\n## TRUE\n\nsymbols[1] == symbols[2] & symbols[1] == symbols[3]\n## TRUE\n\nall(symbols == symbols[1])\n## TRUE\n```\nAs your vocabulary of R functions broadens, you'll think of more ways to do basic tasks. One method that I like for checking three of a kind is:\n\n```r\nlength(unique(symbols) == 1)\n```\n\nThe `unique` function returns every unique term that appears in a vector. If your `symbols` vector contains three of a kind (i.e., one unique term that appears three times), then `unique(symbols)` will return a vector of length `1`.\n\nNow that you have a working test, you can add it to your slot-machine script:\n\n```r\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\n\nif (same) {\n  prize <- # look up the prize\n} else if ( # Case 2: all bars ) {\n  prize <- # assign $5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\n```\n\n::: {.cell type='rmdnote'}\n\\BeginKnitrBlock{rmdnote}<div class=\"rmdnote\">`&&` and `||` behave like `&` and `|` but can sometimes be more efficient. The double operators will not evaluate the second test in a pair of tests if the first test makes the result clear. For example, if `symbols[1]` does not equal `symbols[2]` in the next expression, `&&` will not evaluate `symbols[2] == symbols[3]`; it can immediately return a `FALSE` for the whole expression (because `FALSE & TRUE` and `FALSE & FALSE` both evaluate to `FALSE`). This efficiency can speed up your programs; however, double operators are not appropriate everywhere. `&&` and `||` are not vectorized, which means they can only handle a single logical test on each side of the operator.</div>\\EndKnitrBlock{rmdnote}\n:::\n\nThe second prize case occurs when all the symbols are a type of bar, for example, `B`, `BB`, and `BBB`. Let's begin by creating a concrete example to work with:\n\n```r\nsymbols <- c(\"B\", \"BBB\", \"BB\")\n```\n\n\n::: {.cell name='Test for All Bars'}\n\n```{.exercise .cell-code}\nUse R's logical and Boolean operators to write a test that will determine whether a vector named `symbols` contains only symbols that are a type of bar. Check whether your test works with our example `symbols` vector. Remember to describe how the test should work in English, and then convert the solution to R.\n```\n:::\n\n\n\n::: {.cell}\n\n```{.solution .cell-code}\nAs with many things in R, there are multiple ways to test whether `symbols` contains all bars. For example, you could write a very long test that uses multiple Boolean operators, like this:\n```\n:::\n\n```r\n(symbols[1] == \"B\" | symbols[1] == \"BB\" | symbols[1] == \"BBB\") &\n  (symbols[2] == \"B\" | symbols[2] == \"BB\" | symbols[2] == \"BBB\") &\n  (symbols[3] == \"B\" | symbols[3] == \"BB\" | symbols[3] == \"BBB\")\n## TRUE\n```\n\nHowever, this is not a very efficient solution, because R has to run nine logical tests (and you have to type them). You can often replace multiple `|` operators with a single `%in%`. Also, you can check that a test is true for each element in a vector with `all`. These two changes shorten the preceding code to:\n\n```r\nall(symbols %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\n```\n\nLet's add this code to our script:\n\n```r\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  prize <- # look up the prize\n} else if (all(bars)) {\n  prize <- # assign $5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\n```\n\nYou may have noticed that I split this test up into two steps, `bars` and `all(bars)`. That's just a matter of personal preference. Wherever possible, I like to write my code so it can be read with function and object names conveying what they do.\n\nYou also may have noticed that our test for Case 2 will capture some symbols that should be in Case 1 because they contain three of a kind:\n\n```r\nsymbols <- c(\"B\", \"B\", \"B\")\nall(symbols %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\n```\n\nThat won't be a problem, however, because we've connected our cases with `else if` in the `if` tree. As soon as R comes to a case that evaluates to `TRUE`, it will skip over the rest of the tree. Think of it this way: each `else` tells R to only run the code that follows it _if none of the previous conditions have been met_. So when we have three of the same type of bar, R will evaluate the code for Case 1 and then skip the code for Case 2 (and Case 3).\n\nOur next subtask is to assign a prize for `symbols`. When the `symbols` vector contains three of the same symbol, the prize will depend on which symbol there are three of. If there are three `DD`s, the prize will be $100; if there are three `7`s, the prize will be $80; and so on. \n\nThis suggests another `if` tree. You could assign a prize with some code like this:\n\n```r\nif (same) {\n  symbol <- symbols[1]\n  if (symbol == \"DD\") {\n    prize <- 800\n  } else if (symbol == \"7\") {\n    prize <- 80\n  } else if (symbol == \"BBB\") {\n    prize <- 40\n  } else if (symbol == \"BB\") {\n    prize <- 5\n  } else if (symbol == \"B\") {\n    prize <- 10\n  } else if (symbol == \"C\") {\n    prize <- 10\n  } else if (symbol == \"0\") {\n    prize <- 0\n  }\n}\n```\n\nWhile this code will work, it is a bit long to write and read, and it may require R to perform multiple logical tests before delivering the correct prize. We can do better with a different method.\n\n## Lookup Tables\n\nVery often in R, the simplest way to do something will involve subsetting. How could you use subsetting here? Since you know the exact relationship between the symbols and their prizes, you can create a vector that captures this information. This vector can store symbols as names and prize values as elements:\n\n```r\npayouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n  \"B\" = 10, \"C\" = 10, \"0\" = 0)\npayouts\n##  DD   7 BBB  BB   B   C   0 \n## 100  80  40  25  10  10   0 \n```\n\nNow you can extract the correct prize for any symbol by subsetting the vector with the symbol's name:\n\n```r\npayouts[\"DD\"]\n##  DD \n## 100 \n\npayouts[\"B\"]\n##  B\n## 10\n```\n\nIf you want to leave behind the symbol's name when subsetting, you can run the `unname` function on the output:\n\n```r\nunname(payouts[\"DD\"])\n## 100 \n```\n\n`unname` returns a copy of an object with the names attribute removed.\n\n`payouts` is a type of _lookup table_, an R object that you can use to look up values. Subsetting `payouts` provides a simple way to find the prize for a symbol. It doesn't take many lines of code, and it does the same amount of work whether your symbol is `DD` or `0`. You can create lookup tables in R by creating named objects that can be subsetted in clever ways.\n\nSadly, our method is not quite automatic; we need to tell R which symbol to look up in `payouts`. Or do we? What would happen if you subsetted `payouts` by `symbols[1]`? Give it a try:\n\n```r\nsymbols <- c(\"7\", \"7\", \"7\")\nsymbols[1]\n## \"7\"\n\npayouts[symbols[1]]\n##  7 \n## 80 \n\nsymbols <- c(\"C\", \"C\", \"C\")\npayouts[symbols[1]]\n##  C \n## 10 \n```\n\nYou don't need to know the exact symbol to look up because you can tell R to look up whichever symbol happens to be in `symbols`. You can find this symbol with `symbols[1]`, `symbols[2]`, or `symbols[3]`, because each contains the same symbol in this case. You now have a simple automated way to calculate the prize when `symbols` contains three of a kind. Let's add it to our code and then look at Case 2:\n\n```r\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- # assign $5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\n```\n\nCase 2 occurs whenever the symbols are all bars. In that case, the prize will be $5, which is easy to assign:\n\n\n```r\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  # count cherries\n  prize <- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\n```\n\n\nNow we can work on the last case. Here, you'll need to know how many cherries are in `symbols` before you can calculate a prize.\n\n::: {.cell name='Find C's'}\n\n```{.exercise .cell-code}\nHow can you tell which elements of a vector named `symbols` are a `C`? Devise a test and try it out.\n```\n:::\n\n::: {.cell type='rmdnote'}\n\\BeginKnitrBlock{rmdnote}<div class=\"rmdnote\">**Challenge**\n\nHow might you count the number of `C`s in a vector named `symbols`? Remember R's coercion rules.</div>\\EndKnitrBlock{rmdnote}\n:::\n\n::: {.cell}\n\n```{.solution .cell-code}\nAs always, let's work with a real example:\n```\n:::\n\n```r\nsymbols <- c(\"C\", \"DD\", \"C\")\n```\n\nOne way to test for cherries would be to check which, if any, of the symbols are a `C`:\n\n```r\nsymbols == \"C\"\n## TRUE FALSE  TRUE\n```\n\nIt'd be even more useful to count how many of the symbols are cherries. You can do this with `sum`, which expects numeric input, not logical. Knowing this, R will coerce the `TRUE`s and `FALSE`s to `1`s and `0`s before doing the summation. As a result, `sum` will return the number of `TRUE`s, which is also the number of cherries:\n\n```r\nsum(symbols == \"C\")\n## 2\n```\n\nYou can use the same method to count the number of diamonds in `symbols`:\n\n```r\nsum(symbols == \"DD\")\n## 1\n```\n\nLet's add both of these subtasks to the program skeleton:\n\n```r\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- # calculate a prize\n}\n\ndiamonds <- sum(symbols == \"DD\")\n# double the prize if necessary\n```\n\nSince Case 3 appears further down the `if` tree than Cases 1 and 2, the code in Case 3 will only be applied to players that do not have three of a kind or all bars. According to the slot machine's payout scheme, these players will win $5 if they have two cherries and $2 if they have one cherry. If the player has no cherries, she gets a prize of $0. We don't need to worry about three cherries because that outcome is already covered in Case 1. \n\nAs in Case 1, you could write an `if` tree that handles each combination of cherries, but just like in Case 1, this would be an inefficient solution: \n\n```r\nif (cherries == 2) {\n  prize <- 5\n} else if (cherries == 1) {\n  prize <- 2\n} else {}\n  prize <- 0\n}\n```\n\nAgain, I think the best solution will involve subsetting. If you are feeling ambitious, you can try to work this solution out on your own, but you will learn just as quickly by mentally working through the following proposed solution. \n\nWe know that our prize should be $0 if we have no cherries, $2 if we have one cherry, and $5 if we have two cherries. You can create a vector that contains this information. This will be a very simple lookup table:\n\n```r\nc(0, 2, 5)\n```\n\nNow, like in Case 1, you can subset the vector to retrieve the correct prize. In this case, the prize's aren't identified by a symbol name, but by the number of cherries present. Do we have that information? Yes, it is stored in `cherries`. We can use basic integer subsetting to get the correct prize from the prior lookup table, for example, `c(0, 2, 5)[1]`. \n\n`cherries` isn't exactly suited for integer subsetting because it could contain a zero, but that's easy to fix. We can subset with `cherries + 1`. Now when `cherries` equals zero, we have:\n\n```r\ncherries + 1\n## 1\n\nc(0, 2, 5)[cherries + 1]\n## 0\n```\n\nWhen `cherries` equals one, we have:\n\n```r\ncherries + 1\n## 2\n\nc(0, 2, 5)[cherries + 1]\n## 2\n```\n\nAnd when `cherries` equals two, we have:\n\n```r\ncherries + 1\n## 3\n\nc(0, 2, 5)[cherries + 1]\n## 5\n```\n\nExamine these solutions until you are satisfied that they return the correct prize for each number of cherries. Then add the code to your script, as follows:\n\n```r\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- c(0, 2, 5)[cherries + 1]\n}\n\ndiamonds <- sum(symbols == \"DD\")\n# double the prize if necessary\n```\n\n::: {.cell type='rmdimportant'}\n\\BeginKnitrBlock{rmdimportant}<div class=\"rmdimportant\">**Lookup Tables Versus if Trees**\n\nThis is the second time we've created a lookup table to avoid writing an `if` tree. Why is this technique helpful and why does it keep appearing? Many `if` trees in R are essential. They provide a useful way to tell R to use different algorithms in different cases. However, `if` trees are not appropriate everywhere.\n\n`if` trees have a couple of drawbacks. First, they require R to run multiple tests as it works its way down the `if` tree, which can create unnecessary work. Second, as you'll see in [Speed], it can be difficult to use `if` trees in vectorized code, a style of code that takes advantage of R's programming strengths to create fast programs. Lookup tables do not suffer from either of these drawbacks.\n\nYou won't be able to replace every `if` tree with a lookup table, nor should you. However, you can usually use lookup tables to avoid assigning variables with `if` trees. As a general rule, use an `if` tree if each branch of the tree runs different _code_. Use a lookup table if each branch of the tree only assigns a different _value_.\n\nTo convert an `if` tree to a lookup table, identify the values to be assigned and store them in a vector. Next, identify the selection criteria used in the conditions of the `if` tree. If the conditions use character strings, give your vector names and use name-based subsetting. If the conditions use integers, use integer-based subsetting.</div>\\EndKnitrBlock{rmdimportant}\n:::\n\nThe final subtask is to double the prize once for every diamond present. This means that the final prize will be some multiple of the current prize.  For example, if no diamonds are present, the prize will be:\n\n```r\nprize * 1      # 1 = 2 ^ 0\n```\n\nIf one diamond is present, it will be:\n\n```r\nprize * 2      # 2 = 2 ^ 1\n```\n\nIf two diamonds are present, it will be:\n\n```r\nprize * 4      # 4 = 2 ^ 2\n```\n\nAnd if three diamonds are present, it will be:\n\n```r\nprize * 8      # 8 = 2 ^ 3\n```\n\nCan you think of an easy way to handle this? How about something similar to these examples? \n\n::: {.cell name='Adjust for Diamonds'}\n\n```{.exercise .cell-code}\nWrite a method for adjusting `prize` based on `diamonds`. Describe a solution in English first, and then write your code. \n```\n:::\n\n::: {.cell}\n\n```{.solution .cell-code}\nHere is a concise solution inspired by the previous pattern. The adjusted prize will equal:\n```\n:::\n\n```r\nprize * 2 ^ diamonds\n```\n\nwhich gives us our final `score` script:\n\n```r\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- c(0, 2, 5)[cherries + 1]\n}\n\ndiamonds <- sum(symbols == \"DD\")\nprize * 2 ^ diamonds\n```\n\n## Code Comments\n\nYou now have a working score script that you can save to a function. Before you save your script, though, consider adding comments to your code with a `#`. Comments can make your code easier to understand by explaining _why_ the code does what it does. You can also use comments to break long programs into scannable chunks. For example, I would include three comments in the `score` code:\n\n```r\n# identify case\nsame <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\n# get prize\nif (same) {\n  payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize <- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize <- 5\n} else {\n  cherries <- sum(symbols == \"C\")\n  prize <- c(0, 2, 5)[cherries + 1]\n}\n\n# adjust for diamonds\ndiamonds <- sum(symbols == \"DD\")\nprize * 2 ^ diamonds\n```\n\nNow that each part of your code works, you can wrap it into a function with the methods you learned in [Writing Your Own Functions](#write-functions). Either use RStudio's Extract Function option in the menu bar under Code, or use the `function` function. Ensure that the last line of the function returns a result (it does), and identify any arguments used by your function. Often the concrete examples that you used to test your code, like `symbols`, will become the arguments of your function. Run the following code to start using the `score` function:\n\n```r\nscore <- function (symbols) {\n  # identify case\n  same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]\n  bars <- symbols %in% c(\"B\", \"BB\", \"BBB\")\n  \n  # get prize\n  if (same) {\n    payouts <- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n      \"B\" = 10, \"C\" = 10, \"0\" = 0)\n    prize <- unname(payouts[symbols[1]])\n  } else if (all(bars)) {\n    prize <- 5\n  } else {\n    cherries <- sum(symbols == \"C\")\n    prize <- c(0, 2, 5)[cherries + 1]\n  }\n  \n  # adjust for diamonds\n  diamonds <- sum(symbols == \"DD\")\n  prize * 2 ^ diamonds\n}\n```\n\nOnce you have defined the `score` function, the `play` function will work as well: \n\n```r\nplay <- function() {\n  symbols <- get_symbols()\n  print(symbols)\n  score(symbols)\n}\n```\n\nNow it is easy to play the slot machine:\n\n```r\nplay()\n## \"0\"  \"BB\" \"B\" \n## 0\n\nplay()\n## \"DD\"  \"0\" \"B\"  \n## 0\n\nplay()\n## \"BB\" \"BB\" \"B\" \n## 25\n```\n\n## Summary\n\nAn R program is a set of instructions for your computer to follow that has been organized into a sequence of steps and cases. This may make programs seem simple, but don't be fooled: you can create complicated results with the right combination of simple steps (and cases).\n\nAs a programmer, you are more likely to be fooled in the opposite way. A program may seem impossible to write when you know that it must do something impressive. Do not panic in these situations. Divide the job before you into simple tasks, and then divide the tasks again. You can visualize the relationship between tasks with a flow chart if it helps. Then work on the subtasks one at a time. Describe solutions in English, then convert them to R code. Test each solution against concrete examples as you go. Once each of your subtasks works, combine your code into a function that you can share and reuse.\n\nR provides tools that can help you do this. You can manage cases with `if` and `else` statements. You can create a lookup table with objects and subsetting. You can add code comments with `#`. And you can save your programs as a function with `function`.\n\nThings often go wrong when people write programs. It will be up to you to find the source of any errors that occur and to fix them. It should be easy to find the source of your errors if you use a stepwise approach to writing functions, writing—and then testing—one bit at a time. However, if the source of an error eludes you, or you find yourself working with large chunks of untested code, consider using R's built in debugging tools, described in [Debugging R Code].\n\nThe next two chapters will teach you more tools that you can use in your programs. As you master these tools, you will find it easier to write R programs that let you do whatever you wish to your data. In [S3], you will learn how to use R's S3 system, an invisible hand that shapes many parts of R. You will use the system to build a custom class for your slot machine output, and you will tell R how to display objects that have your class.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "dependencies": {
      "type": "includes",
      "data": []
    },
    "preserve": {}
  }
}