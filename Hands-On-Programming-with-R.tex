% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrbook}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{5}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother





\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\usepackage{tikz}
\usepackage{graphicx}
\newcommand{\circled}[1]{\tikz[baseline=(char.base)]{\node[shape=circle,draw,inner sep=1pt] (char) {#1};}}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Hands-On Programming with R},
  pdfauthor={Garrett Grolemund},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{Hands-On Programming with R}
\author{Garrett Grolemund}
\date{}
\begin{document}
\frontmatter
\maketitle

\frontmatter
\begin{titlepage}
\thispagestyle{empty}
\begin{center}
\vspace*{2cm}
{\Huge\bfseries Hands-On Programming with R\par}
\vspace{2cm}
{\Large\itshape Garrett Grolemund\par}
\vfill
\includegraphics[width=0.8\textwidth]{images/cover.png}
\vfill
\end{center}
\end{titlepage}
\cleardoublepage
\mainmatter

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}

\mainmatter
\bookmarksetup{startatroot}

\chapter*{Welcome}\label{welcome}
\addcontentsline{toc}{chapter}{Welcome}

\markboth{Welcome}{Welcome}

This is the website for \textbf{``Hands-On Programming with R''}. This
book will teach you how to program in R, with hands-on examples. I wrote
it for non-programmers to provide a friendly introduction to the R
language. You'll learn how to load data, assemble and disassemble data
objects, navigate R's environment system, write your own functions, and
use all of R's programming tools. Throughout the book, you'll use your
newfound skills to solve practical data science problems.

If you are already comfortable with R, and would like to focus instead
how to analyze data using R's Tidyverse packages, I recommend
\href{http://r4ds.had.co.nz/}{R for Data Science}, a book that I
co-authored with Hadley Wickham.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-note-color}{\faInfo}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

This book was originally created using
\href{https://bookdown.org}{bookdown} and published at
\url{https://rstudio-education.github.io/hopr/}. This site is a port of
the original book source to the \href{https://quarto.org}{Quarto}
publishing system in order to provide an example of it's use.

\end{minipage}%
\end{tcolorbox}

\section*{License}\label{license}
\addcontentsline{toc}{section}{License}

\markright{License}

This website is (and will always be) \textbf{free to use}, and is
licensed under the
\href{https://creativecommons.org/licenses/by-nc-nd/4.0/}{Creative
Commons Attribution-NonCommercial-NoDerivs 4.0} License. If you'd like a
\textbf{physical copy} of the book, you can order it from
\href{https://www.amazon.com/Hands-Programming-Write-Functions-Simulations/dp/1449359019}{amazon};
it was published by O'Reilly in July 2014. If you'd like to give back,
please consider reporting a typo or leaving a pull request at
\href{https://github.com/rstudio-education/hopr}{github.com/rstudio-education/hopr}.

\bookmarksetup{startatroot}

\chapter*{Preface}\label{preface}
\addcontentsline{toc}{chapter}{Preface}

\markboth{Preface}{Preface}

This book will teach you how to program in R. You'll go from loading
data to writing your own functions (which will outperform the functions
of other R users). But this is not a typical introduction to R. I want
to help you become a data scientist, as well as a computer scientist, so
this book will focus on the programming skills that are most related to
data science.

The chapters in the book are arranged according to three practical
projects--given that they're fairly substantial projects, they span
multiple chapters. I chose these projects for two reasons. First, they
cover the breadth of the R language. You will learn how to load data,
assemble and disassemble data objects, navigate R's environment system,
write your own functions, and use all of R's programming tools, such as
\texttt{if\ else} statements, for loops, S3 classes, R's package system,
and R's debugging tools. The projects will also teach you how to write
vectorized R code, a style of lightning-fast code that takes advantage
of all of the things R does best.

But, more importantly, the projects will teach you how to solve the
logistical problems of data science---and there are many logistical
problems. When you work with data, you will need to store, retrieve, and
manipulate large sets of values without introducing errors. As you work
through the book, I will teach you not just how to program with R, but
how to use the programming skills to support your work as a data
scientist.

Not every programmer needs to be a data scientist, so not every
programmer will find this book useful. You will find this book helpful
if you're in one of the following categories:

\begin{itemize}
\item
  You already use R as a statistical tool, but you would like to learn
  how to write your own functions and simulations with R.
\item
  You would like to teach yourself how to program, and you see the sense
  of learning a language related to data science.
\end{itemize}

One of the biggest surprises in this book is that I do not cover
traditional applications of R, such as models and graphs; instead, I
treat R purely as a programming language. Why this narrow focus? R is
designed to be a tool that helps scientists analyze data. It has many
excellent functions that make plots and fit models to data. As a result,
many statisticians learn to use R as if it were a piece of
software---they learn which functions do what they want, and they ignore
the rest.

This is an understandable approach to learning R. Visualizing and
modeling data are complicated skills that require a scientist's full
attention. It takes expertise, judgement, and focus to extract reliable
insights from a data set. I would not recommend that any data scientist
distract herself with computer programming until she feels comfortable
with the basic theory and practice of her craft. If you would like to
learn the craft of data science, I recommend the book
\href{http://r4ds.had.co.nz/}{R for Data Science}, my companion volume
to this book, co-written with Hadley Wickham.

However, learning to program \emph{should} be on every data scientist's
to-do list. Knowing how to program will make you a more flexible analyst
and augment your mastery of data science in every way. My favorite
metaphor for describing this was introduced by Greg Snow on the R help
mailing list in May 2006. Using functions in R is like riding a bus.
\emph{Writing} functions in R is like driving a car.

\begin{quote}
Busses are very easy to use, you just need to know which bus to get on,
where to get on, and where to get off (and you need to pay your fare).
Cars, on the other hand, require much more work: you need to have some
type of map or directions (even if the map is in your head), you need to
put gas in every now and then, you need to know the rules of the road
(have some type of drivers license). The big advantage of the car is
that it can take you a bunch of places that the bus does not go and it
is quicker for some trips that would require transferring between
busses.

Using this analogy, programs like SPSS are busses, easy to use for the
standard things, but very frustrating if you want to do something that
is not already preprogrammed.

R is a 4-wheel drive SUV (though environmentally friendly) with a bike
on the back, a kayak on top, good walking and running shoes in the
passenger seat, and mountain climbing and spelunking gear in the back.

R can take you anywhere you want to go if you take time to learn how to
use the equipment, but that is going to take longer than learning where
the bus stops are in SPSS.

-- Greg Snow
\end{quote}

Greg compares R to SPSS, but he assumes that you use the full powers of
R; in other words, that you learn how to program in R. If you only use
functions that preexist in R, you are using R like SPSS: it is a bus
that can only take you to certain places.

This flexibility matters to data scientists. The exact details of a
method or simulation will change from problem to problem. If you cannot
build a method tailored to your situation, you may find yourself tempted
to make unrealistic assumptions just so you can use an ill-suited method
that already exists.

This book will help you make the leap from bus to car. I have written it
for beginning programmers. I do not talk about the theory of computer
science---there are no discussions of big \texttt{O()} and little
\texttt{o()} in these pages. Nor do I get into advanced details such as
the workings of \emph{lazy evaluation}. These things are interesting if
you think of computer science at the theoretical level, but they are a
distraction when you first learn to program.

Instead, I teach you how to program in R with three concrete examples.
These examples are short, easy to understand, and cover everything you
need to know.

I have taught this material many times in my job as Master Instructor at
RStudio. As a teacher, I have found that students learn abstract
concepts much faster when they are illustrated by concrete examples. The
examples have a second advantage, as well: they provide immediate
practice. Learning to program is like learning to speak another
language---you progress faster when you practice. In fact, learning to
program \emph{is} learning to speak another language. You will get the
best results if you follow along with the examples in the book and
experiment whenever an idea strikes you.

The book is a companion to \href{http://r4ds.had.co.nz/}{R for Data
Science}. In that book, Hadley Wickham and I explain how to use R to
make plots, model data, and write reports. That book teaches these tasks
as data-science skills, which require judgement and expertise---not as
programming exercises, which they also are. This book will teach you how
to program in R. It does not assume that you have mastered the
data-science skills taught in \emph{R for Data Science} (nor that you
ever intend to). However, this skill set amplifies that one. And if you
master both, you will be a powerful, computer-augmented data scientist,
fit to command a high salary and influence scientific dialogue.

\section*{Conventions Used in This
Book}\label{conventions-used-in-this-book}
\addcontentsline{toc}{section}{Conventions Used in This Book}

\markright{Conventions Used in This Book}

The following typographical conventions are used in this book:

\emph{Italic}:: Indicates new terms, URLs, email addresses, filenames,
and file extensions.

\texttt{Constant\ width}:: Used for program listings, as well as within
paragraphs to refer to program elements such as variable or function
names, databases, data types, environment variables, statements, and
keywords.

\textbf{\texttt{Constant\ width\ bold}}:: Shows commands or other text
that should be typed literally by the user.

\emph{\texttt{Constant\ width\ italic}}:: Shows text that should be
replaced with user-supplied values or by values determined by context.

To comment or ask technical questions about this book, please file an
issue at
\href{https://github.com/rstudio-education/hopr}{github.com/rstudio-education/hopr}.

\section*{Acknowledgments}\label{acknowledgments}
\addcontentsline{toc}{section}{Acknowledgments}

\markright{Acknowledgments}

Many excellent people have helped me write this book, from my two
editors, Courtney Nash and Julie Steele, to the rest of the O'Reilly
team, who designed, proofread, and indexed the book. Also, Greg Snow
generously let me quote him in this preface. I offer them all my
heartfelt thanks.

I would also like to thank Hadley Wickham, who has shaped the way I
think about and teach R. Many of the ideas in this book come from
Statistics 405, a course that I helped Hadley teach when I was a PhD
student at Rice University.

Further ideas came from the students and teachers of Introduction to
Data Science with R, a workshop that I teach on behalf of RStudio. Thank
you to all of you. I'd like to offer special thanks to my teaching
assistants Josh Paulson, Winston Chang, Jaime Ramos, Jay Emerson, and
Vivian Zhang.

Thank you also to JJ Allaire and the rest of my colleagues at RStudio
who provide the RStudio IDE, a tool that makes it much easier to use,
teach, and write about R.

Finally, I would like to thank my wife, Kristin, for her support and
understanding while I wrote this book.

\part{Project 1: Weighted Dice}

Computers let you assemble, manipulate, and visualize data sets, all at
speeds that would have wowed yesterday's scientists. In short, computers
give you scientific superpowers! But if you wish to use them, you'll
need to pick up some programming skills.

As a data scientist who knows how to program, you will improve your
ability to:

\begin{itemize}
\tightlist
\item
  Memorize (store) entire data sets
\item
  Recall data values on demand
\item
  Perform complex calculations with large amounts of data
\item
  Do repetitive tasks without becoming careless or bored
\end{itemize}

Computers can do all of these things quickly and error free, which lets
your mind do the things \emph{it} does well: make decisions and assign
meaning.

Sound exciting? Great! Let's begin.

When I was a college student, I sometimes daydreamed of going to Las
Vegas. I thought that knowing statistics might help me win big. If
that's what led \emph{you} to data science, you better sit down; I have
some bad news. Even a statistician will lose money in a casino over the
long run. This is because the odds for each game are always stacked in
the casino's favor. However, there is a loophole to this rule. You can
make money--and reliably too. All you have to do is \emph{be the
casino}.

Believe it or not, R can help you do that. Over the course of the book,
you will use R to build three virtual objects: a pair of dice that you
can roll to generate random numbers, a deck of cards that you can
shuffle and deal from, and a slot machine modeled after some real-life
video lottery terminals. After that, you'll just need to add some video
graphics and a bank account (and maybe get a few government licenses),
and you'll be in business. I'll leave those details to you.

These projects are lighthearted, but they are also deep. As you complete
them, you will become an expert at the skills you need to work with data
as a data scientist. You will learn how to store data in your computer's
memory, how to access data that is already there, and how to transform
data values in memory when necessary. You will also learn how to write
your own programs in R that you can use to analyze data and run
simulations.

If simulating a slot machine (or dice, or cards) seems frivilous, think
of it this way: playing a slot machine is a process. Once you can
simulate it, you'll be able to simulate other processes, such as
bootstrap sampling, Markov chain Monte Carlo, and other data-analysis
procedures. Plus, these projects provide concrete examples for learning
all of the components of R programming: objects, data types, classes,
notation, functions, environments, \texttt{if} trees, loops, and
vectorization. This first project will make it easier to study these
things by teaching you the basics of R.

Your first mission is simple: assemble R code that will simulate rolling
a pair of dice, like at a craps table. Once you have done that, we'll
weight the dice a bit in your favor, just to keep things interesting.

In this project, you will learn how to:

\begin{itemize}
\tightlist
\item
  Use the R and RStudio interfaces
\item
  Run R commands
\item
  Create R objects
\item
  Write your own R functions and scripts
\item
  Load and use R packages
\item
  Generate random samples
\item
  Create quick plots
\item
  Get help when you need it
\end{itemize}

Don't worry if it seems like we cover a lot of ground fast. This project
is designed to give you a concise overview of the R language. You will
return to many of the concepts we meet here in projects 2 and 3, where
you will examine the concepts in depth.

You'll need to have both R and RStudio installed on your computer before
you can use them. Both are free and easy to download. See
Appendix~\ref{sec-appendix-starting} for complete instructions. If you
are ready to begin, open RStudio on your computer and read on.

\chapter{The Very Basics}\label{sec-basics}

This chapter provides a broad overview of the R language that will get
you programming right away. In it, you will build a pair of virtual dice
that you can use to generate random numbers. Don't worry if you've never
programmed before; the chapter will teach you everything you need to
know.

To simulate a pair of dice, you will have to distill each die into its
essential features. You cannot place a physical object, like a die, into
a computer (well, not without unscrewing some screws), but you can save
\emph{information} about the object in your computer's memory.

Which information should you save? In general, a die has six important
pieces of information: when you roll a die, it can only result in one of
six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential
characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a
group of values in your computer's memory.

Let's work on saving these numbers first, and then consider a method for
``rolling'' our die.

\section{The R User Interface}\label{the-r-user-interface}

Before you can ask your computer to save some numbers, you'll need to
know how to talk to it. That's where R and RStudio come in. RStudio
gives you a way to talk to your computer. R gives you a language to
speak in. To get started, open RStudio just as you would open any other
application on your computer. When you do, a window should appear in
your screen like the one shown in Figure~\ref{fig-console}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0101.png}}

}

\caption{\label{fig-console}Your computer does your bidding when you
type R commands at the prompt in the bottom line of the console pane.
Don't forget to hit the Enter key. When you first open RStudio, the
console appears in the pane on your left, but you can change this with
File \textgreater{} Preferences in the menu bar.}

\end{figure}%

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

If you do not yet have R and RStudio installed on your computer--or do
not know what I am talking about--visit \hyperref[starting]{Appendix A}.
The appendix will give you an overview of the two free tools and tell
you how to download them.

\end{tcolorbox}

The RStudio interface is simple. You type R code into the bottom line of
the RStudio console pane and then click Enter to run it. The code you
type is called a \emph{command}, because it will command your computer
to do something for you. The line you type it into is called the
\emph{command line}.

When you type a command at the prompt and hit Enter, your computer
executes the command and shows you the results. Then RStudio displays a
fresh prompt for your next command. For example, if you type
\texttt{1\ +\ 1} and hit Enter, RStudio will display:

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}} \DecValTok{1} \SpecialCharTok{+} \DecValTok{1}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\DecValTok{2}
\SpecialCharTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

You'll notice that a \texttt{{[}1{]}} appears next to your result. R is
just letting you know that this line begins with the first value in your
result. Some commands return more than one value, and their results may
fill up multiple lines. For example, the command \texttt{100:130}
returns 31 values; it creates a sequence of integers from 100 to 130.
Notice that new bracketed numbers appear at the start of the second and
third lines of output. These numbers just mean that the second line
begins with the 14th value in the result, and the third line begins with
the 25th value. You can mostly ignore the numbers that appear in
brackets:

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}} \DecValTok{100}\SpecialCharTok{:}\DecValTok{130}
\NormalTok{ [}\DecValTok{1}\NormalTok{] }\DecValTok{100} \DecValTok{101} \DecValTok{102} \DecValTok{103} \DecValTok{104} \DecValTok{105} \DecValTok{106} \DecValTok{107} \DecValTok{108} \DecValTok{109} \DecValTok{110} \DecValTok{111} \DecValTok{112}
\NormalTok{[}\DecValTok{14}\NormalTok{] }\DecValTok{113} \DecValTok{114} \DecValTok{115} \DecValTok{116} \DecValTok{117} \DecValTok{118} \DecValTok{119} \DecValTok{120} \DecValTok{121} \DecValTok{122} \DecValTok{123} \DecValTok{124} \DecValTok{125}
\NormalTok{[}\DecValTok{25}\NormalTok{] }\DecValTok{126} \DecValTok{127} \DecValTok{128} \DecValTok{129} \DecValTok{130}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, toprule=.15mm]

The colon operator (\texttt{:}) returns every integer between two
integers. It is an easy way to create a sequence of numbers.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

You may hear me speak of R in the third person. For example, I might
say, ``Tell R to do this'' or ``Tell R to do that'', but of course R
can't do anything; it is just a language. This way of speaking is
shorthand for saying, ``Tell your computer to do this by writing a
command in the R language at the command line of your RStudio console.''
Your computer, and not R, does the actual work.

Is this shorthand confusing and slightly lazy to use? Yes. Do a lot of
people use it? Everyone I know--probably because it is so convenient.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

In some languages, like C, Java, and FORTRAN, you have to compile your
human-readable code into machine-readable code (often 1s and 0s) before
you can run it. If you've programmed in such a language before, you may
wonder whether you have to compile your R code before you can use it.
The answer is no. R is a dynamic programming language, which means R
automatically interprets your code as you run it.

\end{tcolorbox}

If you type an incomplete command and press Enter, R will display a
\texttt{+} prompt, which means R is waiting for you to type the rest of
your command. Either finish the command or hit Escape to start over:

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}} \DecValTok{5} \SpecialCharTok{{-}}
\SpecialCharTok{+}
\SpecialCharTok{+} \DecValTok{1}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\DecValTok{4}
\end{Highlighting}
\end{Shaded}

If you type a command that R doesn't recognize, R will return an error
message. If you ever see an error message, don't panic. R is just
telling you that your computer couldn't understand or do what you asked
it to do. You can then try a different command at the next prompt:

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}} \DecValTok{3}\NormalTok{ \% }\DecValTok{5}
\NormalTok{Error}\SpecialCharTok{:}\NormalTok{ unexpected input }\ControlFlowTok{in} \StringTok{"3 \% 5"}
\SpecialCharTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Once you get the hang of the command line, you can easily do anything in
R that you would do with a calculator. For example, you could do some
basic arithmetic:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \SpecialCharTok{*} \DecValTok{3}   
\DocumentationTok{\#\# 6}

\DecValTok{4} \SpecialCharTok{{-}} \DecValTok{1}   
\DocumentationTok{\#\# 3}

\DecValTok{6} \SpecialCharTok{/}\NormalTok{ (}\DecValTok{4} \SpecialCharTok{{-}} \DecValTok{1}\NormalTok{)   }
\DocumentationTok{\#\# 2}
\end{Highlighting}
\end{Shaded}

Did you notice something different about this code? I've left out the
\texttt{\textgreater{}}'s and \texttt{{[}1{]}}'s. This will make the
code easier to copy and paste if you want to put it in your own console.

R treats the hashtag character, \texttt{\#}, in a special way; R will
not run anything that follows a hashtag on a line. This makes hashtags
very useful for adding comments and annotations to your code. Humans
will be able to read the comments, but your computer will pass over
them. The hashtag is known as the \emph{commenting symbol} in R.

For the remainder of the book, I'll use hashtags to display the output
of R code. I'll use a single hashtag to add my own comments and a double
hashtag, \texttt{\#\#}, to display the results of code. I'll avoid
showing \texttt{\textgreater{}}s and \texttt{{[}1{]}}s unless I want you
to look at them.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-important-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-important-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important}, toprule=.15mm]

Some R commands may take a long time to run. You can cancel a command
once it has begun by pressing ctrl + c.~Note that it may also take R a
long time to cancel the command.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Magic with Numbers}\vspace{3mm}

That's the basic interface for executing R code in RStudio. Think you
have it? If so, try doing these simple tasks. If you execute everything
correctly, you should end up with the same number that you started with:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Choose any number and add 2 to it.
\item
  Multiply the result by 3.
\item
  Subtract 6 from the answer.
\item
  Divide what you get by 3.
\end{enumerate}

\end{tcolorbox}

Throughout the book, I'll put exercises in chunks, like the one above.
I'll follow each exercise with a model answer, like the one below.

You could start with the number 10, and then do the following steps:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{10} \SpecialCharTok{+} \DecValTok{2}
\DocumentationTok{\#\# 12}

\DecValTok{12} \SpecialCharTok{*} \DecValTok{3}
\DocumentationTok{\#\# 36}

\DecValTok{36} \SpecialCharTok{{-}} \DecValTok{6}
\DocumentationTok{\#\# 30}

\DecValTok{30} \SpecialCharTok{/} \DecValTok{3}
\DocumentationTok{\#\# 10}
\end{Highlighting}
\end{Shaded}

\section{Objects}\label{objects}

Now that you know how to use R, let's use it to make a virtual die. The
\texttt{:} operator from a couple of pages ago gives you a nice way to
create a group of numbers from one to six. The \texttt{:} operator
returns its results as a \textbf{vector}, a one-dimensional set of
numbers:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}
\DocumentationTok{\#\# 1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

That's all there is to how a virtual die looks! But you are not done
yet. Running \texttt{1:6} generated a vector of numbers for you to see,
but it didn't save that vector anywhere in your computer's memory. What
you are looking at is basically the footprints of six numbers that
existed briefly and then melted back into your computer's RAM. If you
want to use those numbers again, you'll have to ask your computer to
save them somewhere. You can do that by creating an R \emph{object}.

R lets you save data by storing it inside an R object. What is an
object? Just a name that you can use to call up stored data. For
example, you can save data into an object like \emph{\texttt{a}} or
\emph{\texttt{b}}. Wherever R encounters the object, it will replace it
with the data saved inside, like so:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{a}
\DocumentationTok{\#\# 1}

\NormalTok{a }\SpecialCharTok{+} \DecValTok{2}
\DocumentationTok{\#\# 3}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  To create an R object, choose a name and then use the less-than
  symbol, \texttt{\textless{}}, followed by a minus sign, \texttt{-}, to
  save data into it. This combination looks like an arrow,
  \texttt{\textless{}-}. R will make an object, give it your name, and
  store in it whatever follows the arrow. So \texttt{a\ \textless{}-\ 1}
  stores \texttt{1} in an object named \texttt{a}.
\item
  When you ask R what's in \texttt{a}, R tells you on the next line.
\item
  You can use your object in new R commands, too. Since \texttt{a}
  previously stored the value of \texttt{1}, you're now adding
  \texttt{1} to \texttt{2}.
\end{enumerate}

\end{tcolorbox}

So, for another example, the following code would create an object named
\texttt{die} that contains the numbers one through six. To see what is
stored in an object, just type the object's name by itself:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}

\NormalTok{die}
\DocumentationTok{\#\# 1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

When you create an object, the object will appear in the environment
pane of RStudio, as shown in Figure~\ref{fig-environment}. This pane
will show you all of the objects you've created since opening RStudio.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0102.png}}

}

\caption{\label{fig-environment}The RStudio environment pane keeps track
of the R objects you create.}

\end{figure}%

You can name an object in R almost anything you want, but there are a
few rules. First, a name cannot start with a number. Second, a name
cannot use some special symbols, like \texttt{\^{}}, \texttt{!},
\texttt{\$}, \texttt{@}, \texttt{+}, \texttt{-}, \texttt{/}, or
\texttt{*}:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Good names & Names that cause errors \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
a & 1trial \\
b & \$ \\
FOO & \^{}mean \\
my\_var & 2nd \\
.day & !bad \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-warning-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Capitalization}, toprule=.15mm]

R is case-sensitive, so \texttt{name} and \texttt{Name} will refer to
different objects:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Name }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{name }\OtherTok{\textless{}{-}} \DecValTok{0}  
  
\NormalTok{Name }\SpecialCharTok{+} \DecValTok{1}  
\DocumentationTok{\#\# 2  }
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

Finally, R will overwrite any previous information stored in an object
without asking you for permission. So, it is a good idea to \emph{not}
use names that are already taken:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_number }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{my\_number }
\DocumentationTok{\#\# 1}

\NormalTok{my\_number }\OtherTok{\textless{}{-}} \DecValTok{999}
\NormalTok{my\_number}
\DocumentationTok{\#\# 999}
\end{Highlighting}
\end{Shaded}

You can see which object names you have already used with the function
\texttt{ls}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}\NormalTok{()}
\DocumentationTok{\#\# "a"         "die"       "my\_number" "name"     "Name"     }
\end{Highlighting}
\end{Shaded}

You can also see which names you have used by examining RStudio's
environment pane.

You now have a virtual die that is stored in your computer's memory. You
can access it whenever you like by typing the word \emph{\texttt{die}}.
So what can you do with this die? Quite a lot. R will replace an object
with its contents whenever the object's name appears in a command. So,
for example, you can do all sorts of math with the die. Math isn't so
helpful for rolling dice, but manipulating sets of numbers will be your
stock and trade as a data scientist. So let's take a look at how to do
that:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\SpecialCharTok{{-}} \DecValTok{1}
\DocumentationTok{\#\# 0 1 2 3 4 5}

\NormalTok{die }\SpecialCharTok{/} \DecValTok{2}
\DocumentationTok{\#\# 0.5 1.0 1.5 2.0 2.5 3.0}

\NormalTok{die }\SpecialCharTok{*}\NormalTok{ die}
\DocumentationTok{\#\# 1  4  9 16 25 36}
\end{Highlighting}
\end{Shaded}

If you are a big fan of linear algebra (and who isn't?), you may notice
that R does not always follow the rules of matrix multiplication.
Instead, R uses \emph{element-wise execution}. When you manipulate a set
of numbers, R will apply the same operation to each element in the set.
So for example, when you run \emph{\texttt{die\ -\ 1}}, R subtracts one
from each element of \texttt{die}.

When you use two or more vectors in an operation, R will line up the
vectors and perform a sequence of individual operations. For example,
when you run \emph{\texttt{die\ *\ die}}, R lines up the two
\texttt{die} vectors and then multiplies the first element of vector 1
by the first element of vector 2. R then multiplies the second element
of vector 1 by the second element of vector 2, and so on, until every
element has been multiplied. The result will be a new vector the same
length as the first two, as shown in Figure~\ref{fig-elementwise}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0103.png}}

}

\caption{\label{fig-elementwise}When R performs element-wise execution,
it matches up vectors and then manipulates each pair of elements
independently.}

\end{figure}%

If you give R two vectors of unequal lengths, R will repeat the shorter
vector until it is as long as the longer vector, and then do the math,
as shown in Figure~\ref{fig-recycle}. This isn't a permanent change--the
shorter vector will be its original size after R does the math. If the
length of the short vector does not divide evenly into the length of the
long vector, R will return a warning message. This behavior is known as
\emph{vector recycling}, and it helps R do element-wise operations:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}
\DocumentationTok{\#\# 1 2}

\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}
\DocumentationTok{\#\# 1 2 3 4}

\NormalTok{die}
\DocumentationTok{\#\# 1 2 3 4 5 6}

\NormalTok{die }\SpecialCharTok{+} \DecValTok{1}\SpecialCharTok{:}\DecValTok{2}
\DocumentationTok{\#\# 2 4 4 6 6 8}

\NormalTok{die }\SpecialCharTok{+} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4}
\DocumentationTok{\#\# 2 4 6 8 6 8}
\NormalTok{Warning message}\SpecialCharTok{:}
\NormalTok{In die }\SpecialCharTok{+} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4} \SpecialCharTok{:}
\NormalTok{  longer object length is not a multiple of shorter object length}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0104.png}}

}

\caption{\label{fig-recycle}R will repeat a short vector to do
element-wise operations with two vectors of uneven lengths.}

\end{figure}%

Element-wise operations are a very useful feature in R because they
manipulate groups of values in an orderly way. When you start working
with data sets, element-wise operations will ensure that values from one
observation or case are only paired with values from the same
observation or case. Element-wise operations also make it easier to
write your own programs and functions in R.

But don't think that R has given up on traditional matrix
multiplication. You just have to ask for it when you want it. You can do
inner multiplication with the \texttt{\%*\%} operator and outer
multiplication with the \texttt{\%o\%} operator:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\SpecialCharTok{\%*\%}\NormalTok{ die}
\DocumentationTok{\#\# 91}

\NormalTok{die }\SpecialCharTok{\%o\%}\NormalTok{ die}
\DocumentationTok{\#\#      [,1] [,2] [,3] [,4] [,5] [,6]}
\DocumentationTok{\#\# [1,]    1    2    3    4    5    6}
\DocumentationTok{\#\# [2,]    2    4    6    8   10   12}
\DocumentationTok{\#\# [3,]    3    6    9   12   15   18}
\DocumentationTok{\#\# [4,]    4    8   12   16   20   24}
\DocumentationTok{\#\# [5,]    5   10   15   20   25   30}
\DocumentationTok{\#\# [6,]    6   12   18   24   30   36}
\end{Highlighting}
\end{Shaded}

You can also do things like transpose a matrix with \texttt{t} and take
its determinant with \texttt{det}.

Don't worry if you're not familiar with these operations. They are easy
to look up, and you won't need them for this book.

Now that you can do math with your \texttt{die} object, let's look at
how you could ``roll'' it. Rolling your die will require something more
sophisticated than basic arithmetic; you'll need to randomly select one
of the die's values. And for that, you will need a \emph{function}.

\section{Functions}\label{functions}

R comes with many functions that you can use to do sophisticated tasks
like random sampling. For example, you can round a number with the
\texttt{round} function, or calculate its factorial with the
\texttt{factorial} function. Using a function is pretty simple. Just
write the name of the function and then the data you want the function
to operate on in parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\FloatTok{3.1415}\NormalTok{)}
\DocumentationTok{\#\# 3}

\FunctionTok{factorial}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# 6}
\end{Highlighting}
\end{Shaded}

The data that you pass into the function is called the function's
\emph{argument}. The argument can be raw data, an R object, or even the
results of another R function. In this last case, R will work from the
innermost function to the outermost, as in Figure~\ref{fig-pemdas}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{)}
\DocumentationTok{\#\# 3.5}

\FunctionTok{mean}\NormalTok{(die)}
\DocumentationTok{\#\# 3.5}

\FunctionTok{round}\NormalTok{(}\FunctionTok{mean}\NormalTok{(die))}
\DocumentationTok{\#\# 4}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0105.png}}

}

\caption{\label{fig-pemdas}When you link functions together, R will
resolve them from the innermost operation to the outermost. Here R first
looks up die, then calculates the mean of one through six, then rounds
the mean.}

\end{figure}%

Lucky for us, there is an R function that can help ``roll'' the die. You
can simulate a roll of the die with R's \texttt{sample} function.
\texttt{sample} takes \emph{two} arguments: a vector named \texttt{x}
and a number named \texttt{size}. \texttt{sample} will return
\texttt{size} elements from the vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(}\AttributeTok{x =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\AttributeTok{size =} \DecValTok{2}\NormalTok{)}
\DocumentationTok{\#\# 3 2}
\end{Highlighting}
\end{Shaded}

To roll your die and get a number back, set \texttt{x} to \texttt{die}
and sample one element from it. You'll get a new (maybe different)
number each time you roll it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(}\AttributeTok{x =}\NormalTok{ die, }\AttributeTok{size =} \DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# 2}

\FunctionTok{sample}\NormalTok{(}\AttributeTok{x =}\NormalTok{ die, }\AttributeTok{size =} \DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# 1}

\FunctionTok{sample}\NormalTok{(}\AttributeTok{x =}\NormalTok{ die, }\AttributeTok{size =} \DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# 6}
\end{Highlighting}
\end{Shaded}

Many R functions take multiple arguments that help them do their job.
You can give a function as many arguments as you like as long as you
separate each argument with a comma.

You may have noticed that I set \texttt{die} and \texttt{1} equal to the
names of the arguments in \texttt{sample}, \texttt{x} and \texttt{size}.
Every argument in every R function has a name. You can specify which
data should be assigned to which argument by setting a name equal to
data, as in the preceding code. This becomes important as you begin to
pass multiple arguments to the same function; names help you avoid
passing the wrong data to the wrong argument. However, using names is
optional. You will notice that R users do not often use the name of the
first argument in a function. So you might see the previous code written
as:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# 2}
\end{Highlighting}
\end{Shaded}

Often, the name of the first argument is not very descriptive, and it is
usually obvious what the first piece of data refers to anyways.

But how do you know which argument names to use? If you try to use a
name that a function does not expect, you will likely get an error:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\FloatTok{3.1415}\NormalTok{, }\AttributeTok{corners =} \DecValTok{2}\NormalTok{)}
\DocumentationTok{\#\# Error in round(3.1415, corners = 2) : unused argument(s) (corners = 2)}
\end{Highlighting}
\end{Shaded}

If you're not sure which names to use with a function, you can look up
the function's arguments with \texttt{args}. To do this, place the name
of the function in the parentheses behind \texttt{args}. For example,
you can see that the \texttt{round} function takes two arguments, one
named \texttt{x} and one named \texttt{digits}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{args}\NormalTok{(round)}
\DocumentationTok{\#\# function (x, digits = 0) }
\DocumentationTok{\#\# NULL}
\end{Highlighting}
\end{Shaded}

Did you notice that \texttt{args} shows that the \texttt{digits}
argument of \texttt{round} is already set to 0? Frequently, an R
function will take optional arguments like \texttt{digits}. These
arguments are considered optional because they come with a default
value. You can pass a new value to an optional argument if you want, and
R will use the default value if you do not. For example, \texttt{round}
will round your number to 0 digits past the decimal point by default. To
override the default, supply your own value for \texttt{digits}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\FloatTok{3.1415}\NormalTok{)}
\DocumentationTok{\#\# 3}

\FunctionTok{round}\NormalTok{(}\FloatTok{3.1415}\NormalTok{, }\AttributeTok{digits =} \DecValTok{2}\NormalTok{)}
\DocumentationTok{\#\# 3.14}
\end{Highlighting}
\end{Shaded}

You should write out the names of each argument after the first one or
two when you call a function with multiple arguments. Why? First, this
will help you and others understand your code. It is usually obvious
which argument your first input refers to (and sometimes the second
input as well). However, you'd need a large memory to remember the third
and fourth arguments of every R function. Second, and more importantly,
writing out argument names prevents errors.

If you do not write out the names of your arguments, R will match your
values to the arguments in your function by order. For example, in the
following code, the first value, \texttt{die}, will be matched to the
first argument of \texttt{sample}, which is named \texttt{x}. The next
value, \texttt{1}, will be matched to the next argument, \texttt{size}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# 2}
\end{Highlighting}
\end{Shaded}

As you provide more arguments, it becomes more likely that your order
and R's order may not align. As a result, values may get passed to the
wrong argument. Argument names prevent this. R will always match a value
to its argument name, no matter where it appears in the order of
arguments:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(}\AttributeTok{size =} \DecValTok{1}\NormalTok{, }\AttributeTok{x =}\NormalTok{ die)}
\DocumentationTok{\#\# 2}
\end{Highlighting}
\end{Shaded}

\subsection{Sample with Replacement}\label{sample-with-replacement}

If you set \texttt{size\ =\ 2}, you can \emph{almost} simulate a pair of
dice. Before we run that code, think for a minute why that might be the
case. \texttt{sample} will return two numbers, one for each die:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{)}
\DocumentationTok{\#\# 3 4}
\end{Highlighting}
\end{Shaded}

I said this ``almost'' works because this method does something funny.
If you use it many times, you'll notice that the second die never has
the same value as the first die, which means you'll never roll something
like a pair of threes or snake eyes. What is going on?

By default, \texttt{sample} builds a sample \emph{without replacement}.
To see what this means, imagine that \texttt{sample} places all of the
values of \texttt{die} in a jar or urn. Then imagine that
\texttt{sample} reaches into the jar and pulls out values one by one to
build its sample. Once a value has been drawn from the jar,
\texttt{sample} sets it aside. The value doesn't go back into the jar,
so it cannot be drawn again. So if \texttt{sample} selects a six on its
first draw, it will not be able to select a six on the second draw; six
is no longer in the jar to be selected. Although \texttt{sample} creates
its sample electronically, it follows this seemingly physical behavior.

One side effect of this behavior is that each draw depends on the draws
that come before it. In the real world, however, when you roll a pair of
dice, each die is independent of the other. If the first die comes up
six, it does not prevent the second die from coming up six. In fact, it
doesn't influence the second die in any way whatsoever. You can recreate
this behavior in \texttt{sample} by adding the argument
\texttt{replace\ =\ TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\DocumentationTok{\#\# 5 5}
\end{Highlighting}
\end{Shaded}

The argument \texttt{replace\ =\ TRUE} causes \texttt{sample} to sample
\emph{with replacement}. Our jar example provides a good way to
understand the difference between sampling with replacement and without.
When \texttt{sample} uses replacement, it draws a value from the jar and
records the value. Then it puts the value back into the jar. In other
words, \texttt{sample} \emph{replaces} each value after each draw. As a
result, \texttt{sample} may select the same value on the second draw.
Each value has a chance of being selected each time. It is as if every
draw were the first draw.

Sampling with replacement is an easy way to create \emph{independent
random samples}. Each value in your sample will be a sample of size one
that is independent of the other values. This is the correct way to
simulate a pair of dice:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\DocumentationTok{\#\# 2 4}
\end{Highlighting}
\end{Shaded}

Congratulate yourself; you've just run your first simulation in R! You
now have a method for simulating the result of rolling a pair of dice.
If you want to add up the dice, you can feed your result straight into
the \texttt{sum} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{dice}
\DocumentationTok{\#\# 2 4}

\FunctionTok{sum}\NormalTok{(dice)}
\DocumentationTok{\#\# 6}
\end{Highlighting}
\end{Shaded}

What would happen if you call \texttt{dice} multiple times? Would R
generate a new pair of dice values each time? Let's give it a try:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dice}
\DocumentationTok{\#\# 2 4}

\NormalTok{dice}
\DocumentationTok{\#\# 2 4}

\NormalTok{dice}
\DocumentationTok{\#\# 2 4}
\end{Highlighting}
\end{Shaded}

Nope. Each time you call \texttt{dice}, R will show you the result of
that one time you called \texttt{sample} and saved the output to
\texttt{dice}. R won't rerun \texttt{sample(die,\ 2,\ replace\ =\ TRUE)}
to create a new roll of the dice. This is a relief in a way. Once you
save a set of results to an R object, those results do not change.
Programming would be quite hard if the values of your objects changed
each time you called them.

However, it \emph{would} be convenient to have an object that can
re-roll the dice whenever you call it. You can make such an object by
writing your own R function.

\section{Writing Your Own Functions}\label{sec-write-functions}

To recap, you already have working R code that simulates rolling a pair
of dice:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}
\NormalTok{dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{sum}\NormalTok{(dice)}
\end{Highlighting}
\end{Shaded}

You can retype this code into the console anytime you want to re-roll
your dice. However, this is an awkward way to work with the code. It
would be easier to use your code if you wrapped it into its own
function, which is exactly what we'll do now. We're going to write a
function named \texttt{roll} that you can use to roll your virtual dice.
When you're finished, the function will work like this: each time you
call \texttt{roll()}, R will return the sum of rolling two dice:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{roll}\NormalTok{()}
\DocumentationTok{\#\# 8 }

\FunctionTok{roll}\NormalTok{()}
\DocumentationTok{\#\# 3}

\FunctionTok{roll}\NormalTok{()}
\DocumentationTok{\#\# 7}
\end{Highlighting}
\end{Shaded}

Functions may seem mysterious or fancy, but they are just another type
of R object. Instead of containing data, they contain code. This code is
stored in a special format that makes it easy to reuse the code in new
situations. You can write your own functions by recreating this format.

\subsection{The Function Constructor}\label{the-function-constructor}

Every function in R has three basic parts: a name, a body of code, and a
set of arguments. To make your own function, you need to replicate these
parts and store them in an R object, which you can do with the
\texttt{function} function. To do this, call \texttt{function()} and
follow it with a pair of braces, \texttt{\{\}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_function }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{\}}
\end{Highlighting}
\end{Shaded}

\texttt{function} will build a function out of whatever R code you place
between the braces. For example, you can turn your dice code into a
function by calling:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  die }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}
\NormalTok{  dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(dice)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

Notice that I indented each line of code between the braces. This makes
the code easier for you and me to read but has no impact on how the code
runs. R ignores spaces and line breaks and executes one complete
expression at a time.

\end{tcolorbox}

Just hit the Enter key between each line after the first brace,
\texttt{\{}. R will wait for you to type the last brace, \texttt{\}},
before it responds.

Don't forget to save the output of \texttt{function} to an R object.
This object will become your new function. To use it, write the object's
name followed by an open and closed parenthesis:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{roll}\NormalTok{()}
\DocumentationTok{\#\# 9}
\end{Highlighting}
\end{Shaded}

You can think of the parentheses as the ``trigger'' that causes R to run
the function. If you type in a function's name \emph{without} the
parentheses, R will show you the code that is stored inside the
function. If you type in the name \emph{with} the parentheses, R will
run that code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll}
\DocumentationTok{\#\# function() \{}
\DocumentationTok{\#\#   die \textless{}{-} 1:6}
\DocumentationTok{\#\#   dice \textless{}{-} sample(die, size = 2, replace = TRUE)}
\DocumentationTok{\#\#   sum(dice)}
\DocumentationTok{\#\# \}}

\FunctionTok{roll}\NormalTok{()}
\DocumentationTok{\#\# 6}
\end{Highlighting}
\end{Shaded}

The code that you place inside your function is known as the \emph{body}
of the function. When you run a function in R, R will execute all of the
code in the body and then return the result of the last line of code. If
the last line of code doesn't return a value, neither will your
function, so you want to ensure that your final line of code returns a
value. One way to check this is to think about what would happen if you
ran the body of code line by line in the command line. Would R display a
result after the last line, or would it not?

Here's some code that would display a result:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dice}
\DecValTok{1} \SpecialCharTok{+} \DecValTok{1}
\FunctionTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

And here's some code that would not:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{two }\OtherTok{\textless{}{-}} \DecValTok{1} \SpecialCharTok{+} \DecValTok{1}
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do you notice the pattern? These lines of code do not return a value to
the command line; they save a value to an object.

\section{Arguments}\label{arguments}

What if we removed one line of code from our function and changed the
name \texttt{die} to \texttt{bones}, like this?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(bones, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(dice)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now I'll get an error when I run the function. The function needs the
object \texttt{bones} to do its job, but there is no object named
\texttt{bones} to be found:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{roll2}\NormalTok{()}
\DocumentationTok{\#\# Error in sample(bones, size = 2, replace = TRUE) : }
\DocumentationTok{\#\#   object \textquotesingle{}bones\textquotesingle{} not found}
\end{Highlighting}
\end{Shaded}

You can supply \texttt{bones} when you call \texttt{roll2} if you make
\texttt{bones} an argument of the function. To do this, put the name
\texttt{bones} in the parentheses that follow \texttt{function} when you
define \texttt{roll2}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(bones) \{}
\NormalTok{  dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(bones, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(dice)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now \texttt{roll2} will work as long as you supply \texttt{bones} when
you call the function. You can take advantage of this to roll different
types of dice each time you call \texttt{roll2}. Dungeons and Dragons,
here we come!

Remember, we're rolling pairs of dice:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{roll2}\NormalTok{(}\AttributeTok{bones =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{)}
\DocumentationTok{\#\#  3}

\FunctionTok{roll2}\NormalTok{(}\AttributeTok{bones =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{)}
\DocumentationTok{\#\# 10}

\FunctionTok{roll2}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{20}\NormalTok{)}
\DocumentationTok{\#\# 31}
\end{Highlighting}
\end{Shaded}

Notice that \texttt{roll2} will still give an error if you do not supply
a value for the \texttt{bones} argument when you call \texttt{roll2}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{roll2}\NormalTok{()}
\DocumentationTok{\#\# Error in sample(bones, size = 2, replace = TRUE) : }
\DocumentationTok{\#\#   argument "bones" is missing, with no default}
\end{Highlighting}
\end{Shaded}

You can prevent this error by giving the \texttt{bones} argument a
default value. To do this, set \texttt{bones} equal to a value when you
define \texttt{roll2}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{bones =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{) \{}
\NormalTok{  dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(bones, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(dice)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now you can supply a new value for \texttt{bones} if you like, and
\texttt{roll2} will use the default if you do not:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{roll2}\NormalTok{()}
\DocumentationTok{\#\# 9}
\end{Highlighting}
\end{Shaded}

You can give your functions as many arguments as you like. Just list
their names, separated by commas, in the parentheses that follow
\texttt{function}. When the function is run, R will replace each
argument name in the function body with the value that the user supplies
for the argument. If the user does not supply a value, R will replace
the argument name with the argument's default value (if you defined
one).

To summarize, \texttt{function} helps you construct your own R
functions. You create a body of code for your function to run by writing
code between the braces that follow \texttt{function}. You create
arguments for your function to use by supplying their names in the
parentheses that follow \texttt{function}. Finally, you give your
function a name by saving its output to an R object, as shown in
Figure~\ref{fig-functions}.

Once you've created your function, R will treat it like every other
function in R. Think about how useful this is. Have you ever tried to
create a new Excel option and add it to Microsoft's menu bar? Or a new
slide animation and add it to Powerpoint's options? When you work with a
programming language, you can do these types of things. As you learn to
program in R, you will be able to create new, customized, reproducible
tools for yourself whenever you like. \hyperref[slots]{Project 3: Slot
Machine} will teach you much more about writing functions in R.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0106.png}}

}

\caption{\label{fig-functions}Every function in R has the same parts,
and you can use function to create these parts. Assign the result to a
name, so you can call the function later.}

\end{figure}%

\section{Scripts}\label{scripts}

What if you want to edit \texttt{roll2} again? You could go back and
retype each line of code in \texttt{roll2}, but it would be so much
easier if you had a draft of the code to start from. You can create a
draft of your code as you go by using an R \emph{script}. An R script is
just a plain text file that you save R code in. You can open an R script
in RStudio by going to
\texttt{File\ \textgreater{}\ New\ File\ \textgreater{}\ R\ script} in
the menu bar. RStudio will then open a fresh script above your console
pane, as shown in Figure~\ref{fig-script}.

I strongly encourage you to write and edit all of your R code in a
script before you run it in the console. Why? This habit creates a
reproducible record of your work. When you're finished for the day, you
can save your script and then use it to rerun your entire analysis the
next day. Scripts are also very handy for editing and proofreading your
code, and they make a nice copy of your work to share with others. To
save a script, click the scripts pane, and then go to
\texttt{File\ \textgreater{}\ Save\ As} in the menu bar.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0107.png}}

}

\caption{\label{fig-script}When you open an R Script (File
\textgreater{} New File \textgreater{} R Script in the menu bar),
RStudio creates a fourth pane above the console where you can write and
edit your code.}

\end{figure}%

RStudio comes with many built-in features that make it easy to work with
scripts. First, you can automatically execute a line of code in a script
by clicking the Run button, as shown in Figure~\ref{fig-run}.

R will run whichever line of code your cursor is on. If you have a whole
section highlighted, R will run the highlighted code. Alternatively, you
can run the entire script by clicking the Source button. Don't like
clicking buttons? You can use Control + Return as a shortcut for the Run
button. On Macs, that would be Command + Return.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0108.png}}

}

\caption{\label{fig-run}You can run a highlighted portion of code in
your script if you click the Run button at the top of the scripts pane.
You can run the entire script by clicking the Source button.}

\end{figure}%

If you're not convinced about scripts, you soon will be. It becomes a
pain to write multi-line code in the console's single-line command line.
Let's avoid that headache and open your first script now before we move
to the next chapter.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Extract function}, toprule=.15mm]

RStudio comes with a tool that can help you build functions. To use it,
highlight the lines of code in your R script that you want to turn into
a function. Then click \texttt{Code\ \textgreater{}\ Extract\ Function}
in the menu bar. RStudio will ask you for a function name to use and
then wrap your code in a \texttt{function} call. It will scan the code
for undefined variables and use these as arguments.

You may want to double-check RStudio's work. It assumes that your code
is correct, so if it does something surprising, you may have a problem
in your code.

\end{tcolorbox}

\section{Summary}\label{summary}

You've covered a lot of ground already. You now have a virtual die
stored in your computer's memory, as well as your own R function that
rolls a pair of dice. You've also begun speaking the R language.

As you've seen, R is a language that you can use to talk to your
computer. You write commands in R and run them at the command line for
your computer to read. Your computer will sometimes talk back--for
example, when you commit an error--but it usually just does what you ask
and then displays the result.

The two most important components of the R language are objects, which
store data, and functions, which manipulate data. R also uses a host of
operators like \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, and
\texttt{\textless{}-} to do basic tasks. As a data scientist, you will
use R objects to store data in your computer's memory, and you will use
functions to automate tasks and do complicated calculations. We will
examine objects in more depth later in
\hyperref[sec-project-cards]{Project 2: Playing Cards} and dig further
into functions in \hyperref[sec-project-slots]{Project 3: Slot Machine}.
The vocabulary you have developed here will make each of those projects
easier to understand. However, we're not done with your dice yet.

In \hyperref[sec-packages-and-help]{Packages and Help Pages}, you'll run
some simulations on your dice and build your first graphs in R. You'll
also look at two of the most useful components of the R language: R
\emph{packages}, which are collections of functions writted by R's
talented community of developers, and R documentation, which is a
collection of help pages built into R that explains every function and
data set in the language.

\chapter{Packages and Help Pages}\label{sec-packages-and-help}

You now have a function that simulates rolling a pair of dice. Let's
make things a little more interesting by weighting the dice in your
favor. The house always wins, right? Let's make the dice roll high
numbers slightly more often than it rolls low numbers.

Before we weight the dice, we should make sure that they are fair to
begin with. Two tools will help you do this: \emph{repetition} and
\emph{visualization}. By coincidence, these tools are also two of the
most useful superpowers in the world of data science.

We will repeat our dice rolls with a function called \texttt{replicate},
and we will visualize our rolls with a function called \texttt{qplot}.
\texttt{qplot} does not come with R when you download it; \texttt{qplot}
comes in a standalone R package. Many of the most useful R tools come in
R packages, so let's take a moment to look at what R packages are and
how you can use them.

\section{Packages}\label{packages}

You're not the only person writing your own functions with R. Many
professors, programmers, and statisticians use R to design tools that
can help people analyze data. They then make these tools free for anyone
to use. To use these tools, you just have to download them. They come as
preassembled collections of functions and objects called packages.
\hyperref[sec-appendix-packages]{Appendix B: R Packages} contains
detailed instructions for downloading and updating R packages, but we'll
look at the basics here.

We're going to use the \texttt{qplot} function to make some quick plots.
\texttt{qplot} comes in the \emph{ggplot2} package, a popular package
for making graphs. Before you can use \texttt{qplot}, or anything else
in the ggplot2 package, you need to download and install it.

\subsection{install.packages}\label{install.packages}

Each R package is hosted at \url{http://cran.r-project.org}, the same
website that hosts R. However, you don't need to visit the website to
download an R package; you can download packages straight from R's
command line. Here's how:

\begin{itemize}
\tightlist
\item
  Open RStudio.
\item
  Make sure you are connected to the Internet.
\item
  Run \emph{\texttt{install.packages("ggplot2")}} at the command line.
\end{itemize}

That's it. R will have your computer visit the website, download
ggplot2, and install the package in your hard drive right where R wants
to find it. You now have the ggplot2 package. If you would like to
install another package, replace ggplot2 with your package name in the
code.

\subsection{library}\label{library}

Installing a package doesn't place its functions at your fingertips just
yet: it simply places them in your hard drive. To use an R package, you
next have to load it in your R session with the command
\emph{\texttt{library("ggplot2")}}. If you would like to load a
different package, replace ggplot2 with your package name in the code.

To see what this does, try an experiment. First, ask R to show you the
\texttt{qplot} function. R won't be able to find \texttt{qplot} because
\texttt{qplot} lives in the ggplot2 package, which you haven't loaded:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{qplot}
\DocumentationTok{\#\# Error: object \textquotesingle{}qplot\textquotesingle{} not found}
\end{Highlighting}
\end{Shaded}

Now load the ggplot2 package:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you installed the package with \texttt{install.packages} as
instructed, everything should go fine. Don't worry if you don't see any
results or messages. No news is fine news when loading a package. Don't
worry if you do see a message either; ggplot2 sometimes displays helpful
start up messages. As long as you do not see anything that says
``Error,'' you are doing fine.

Now if you ask to see \texttt{qplot}, R will show you quite a bit of
code (\texttt{qplot} is a long function):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{qplot}
\DocumentationTok{\#\# (quite a bit of code)}
\end{Highlighting}
\end{Shaded}

\hyperref[sec-appendix-packages]{Appendix B: R Packages} contains many
more details about acquiring and using packages. I recommend that you
read it if you are unfamiliar with R's package system. The main thing to
remember is that you only need to install a package once, but you need
to load it with \texttt{library} each time you wish to use it in a new R
session. R will unload all of its packages each time you close RStudio.

Now that you've loaded \texttt{qplot}, let's take it for a spin.
\texttt{qplot} makes ``quick plots.'' If you give \texttt{qplot} two
vectors of equal lengths, \texttt{qplot} will draw a scatterplot for
you. \texttt{qplot} will use the first vector as a set of x values and
the second vector as a set of y values. Look for the plot to appear in
the Plots tab of the bottom-right pane in your RStudio window.

The following code will make the plot that appears in
Figure~\ref{fig-qplot}. Until now, we've been creating sequences of
numbers with the \texttt{:} operator; but you can also create vectors of
numbers with the \texttt{c} function. Give \texttt{c} all of the numbers
that you want to appear in the vector, separated by a comma. \texttt{c}
stands for \emph{concatenate}, but you can think of it as ``collect'' or
``combine'':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{0.8}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{0.6}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{0.4}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{0.2}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.4}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{x}
\DocumentationTok{\#\# {-}1.0 {-}0.8 {-}0.6 {-}0.4 {-}0.2  0.0  0.2  0.4  0.6  0.8  1.0}

\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{3}
\NormalTok{y}
\DocumentationTok{\#\# {-}1.000 {-}0.512 {-}0.216 {-}0.064 {-}0.008  0.000  0.008}
\DocumentationTok{\#\#  0.064  0.216  0.512  1.000}

\FunctionTok{qplot}\NormalTok{(x, y)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0201.png}}

}

\caption{\label{fig-qplot}\texttt{qplot} makes a scatterplot when you
give it two vectors.}

\end{figure}%

You don't need to name your vectors \texttt{x} and \texttt{y}. I just
did that to make the example clear. As you can see in
Figure~\ref{fig-qplot}, a scatterplot is a set of points, each plotted
according to its x and y values. Together, the vectors \texttt{x} and
\texttt{y} describe a set of 10 points. How did R match up the values in
\texttt{x} and \texttt{y} to make these points? With element-wise
execution, as we saw in Figure~\ref{fig-elementwise}.

Scatterplots are useful for visualizing the relationship between two
variables. However, we're going to use a different type of graph, a
\emph{histogram}. A histogram visualizes the distribution of a single
variable; it displays how many data points appear at each value of x.

Let's take a look at a histogram to see if this makes sense.
\texttt{qplot} will make a histogram whenever you give it only
\emph{one} vector to plot. The following code makes the left-hand plot
in Figure~\ref{fig-hist} (we'll worry about the right-hand plot in just
second). To make sure our graphs look the same, use the extra argument
\emph{\texttt{binwidth\ =\ 1}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\FunctionTok{qplot}\NormalTok{(x, }\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0202.png}}

}

\caption{\label{fig-hist}\texttt{qplot} makes a histogram when you give
it a single vector.}

\end{figure}%

This plot shows that our vector contains one value in the interval
\texttt{{[}1,\ 2)} by placing a bar of height 1 above that interval.
Similarly, the plot shows that the vector contains three values in the
interval \texttt{{[}2,\ 3)} by placing a bar of height 3 in that
interval. It shows that the vector contains two values in the interval
\texttt{{[}3,\ 4)} by placing a bar of height 2 in that interval. In
these intervals, the hard bracket, \texttt{{[}}, means that the first
number is included in the interval. The parenthesis, \texttt{)}, means
that the last number is \emph{not} included.

Let's try another histogram. This code makes the right-hand plot in
Figure~\ref{fig-hist}. Notice that there are five points with a value of
1 in \texttt{x2}. The histogram displays this by plotting a bar of
height 5 above the interval x2 = {[}1, 2):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x2 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\FunctionTok{qplot}\NormalTok{(x2, }\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\phantomsection\label{exr:histogram}
\section{Visualize a Histogram}\label{visualize-a-histogram}

Let \texttt{x3} be the following vector:

\texttt{x3\ \textless{}-\ c(0,\ 1,\ 1,\ 2,\ 2,\ 2,\ 3,\ 3,\ 4)}

Imagine what a histogram of \texttt{x3} would look like. Assume that the
histogram has a bin width of 1. How many bars will the histogram have?
Where will they appear? How high will each be?

When you are done, plot a histogram of \texttt{x3} with
\texttt{binwidth\ =\ 1}, and see if you are right.

You can make a histogram of \texttt{x3} with
\texttt{qplot(x3,\ binwidth\ =\ 1)}. The histogram will look like a
symmetric pyramid. The middle bar will have a height of 3 and will
appear above \texttt{{[}2,\ 3)}, but be sure to try it and see for
yourself.

You can use a histogram to display visually how common different values
of \texttt{x} are. Numbers covered by a tall bar are more common than
numbers covered by a short bar.

How can you use a histogram to check the accuracy of your dice?

Well, if you roll your dice many times and keep track of the results,
you would expect some numbers to occur more than others. This is because
there are more ways to get some numbers by adding two dice together than
to get other numbers, as shown in Figure~\ref{fig-probs}.

If you roll your dice many times and plot the results with
\texttt{qplot}, the histogram will show you how often each sum appeared.
The sums that occurred most often will have the highest bars. The
histogram should look like the pattern in Figure Figure~\ref{fig-probs}
if the dice are fairly weighted.

This is where \texttt{replicate} comes in. \texttt{replicate} provides
an easy way to repeat an R command many times. To use it, first give
\texttt{replicate} the number of times you wish to repeat an R command,
and then give it the command you wish to repeat. \texttt{replicate} will
run the command multiple times and store the results as a vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{replicate}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{1} \SpecialCharTok{+} \DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# 2 2 2}

\FunctionTok{replicate}\NormalTok{(}\DecValTok{10}\NormalTok{, }\FunctionTok{roll}\NormalTok{())}
\DocumentationTok{\#\# 3  7  5  3  6  2  3  8 11  7}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0203.png}}

}

\caption{\label{fig-probs}Each individual dice combination should occur
with the same frequency. As a result, some sums will occur more often
than others. With fair dice, each sum should appear in proportion to the
number of combinations that make it.}

\end{figure}%

A histogram of your first 10 rolls probably won't look like the pattern
shown in Figure~\ref{fig-probs}. Why not? There is too much randomness
involved. Remember that we use dice in real life because they are
effective random number generators. Patterns of long run frequencies
will only appear \emph{over the long run}. So let's simulate 10,000 dice
rolls and plot the results. Don't worry; \texttt{qplot} and
\texttt{replicate} can handle it. The results appear in
Figure~\ref{fig-fair}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rolls }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{10000}\NormalTok{, }\FunctionTok{roll}\NormalTok{())}
\FunctionTok{qplot}\NormalTok{(rolls, }\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The results suggest that the dice are fair. Over the long run, each
number occurs in proportion to the number of combinations that generate
it.

Now how can you bias these results? The previous pattern occurs because
each underlying combination of dice (e.g., (3,4)) occurs with the same
frequency. If you could increase the probability that a 6 is rolled on
either die, then any combination with a six in it will occur more often
than any combination without a six in it. The combination (6, 6) would
occur most of all. This won't make the dice add up to 12 more often than
they add up to seven, but it will skew the results toward the higher
numbers.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0204.png}}

}

\caption{\label{fig-fair}The behavior of our dice suggests that they are
fair. Seven occurs more often than any other number, and frequencies
diminish in proportion to the number of die combinations that create
each number.}

\end{figure}%

To put it another way, the probability of rolling any single number on a
fair die is 1/6. I'd like you to change the probability to 1/8 for each
number below six, and then increase the probability of rolling a six to
3/8:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Number & Fair probability & Weighted probability \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 1/6 & 1/8 \\
2 & 1/6 & 1/8 \\
3 & 1/6 & 1/8 \\
4 & 1/6 & 1/8 \\
5 & 1/6 & 1/8 \\
6 & 1/6 & 3/8 \\
\end{longtable}

You can change the probabilities by adding a new argument to the
\texttt{sample} function. I'm not going to tell you what the argument
is; instead I'll point you to the help page for the \texttt{sample}
function. What's that? R functions come with help pages? Yes they do, so
let's learn how to read one.

\section{Getting Help with Help
Pages}\label{getting-help-with-help-pages}

There are over 1,000 functions at the core of R, and new R functions are
created all of the time. This can be a lot of material to memorize and
learn! Luckily, each R function comes with its own help page, which you
can access by typing the function's name after a question mark. For
example, each of these commands will open a help page. Look for the
pages to appear in the Help tab of RStudio's bottom-right pane:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?sqrt}
\NormalTok{?log10}
\NormalTok{?sample}
\end{Highlighting}
\end{Shaded}

Help pages contain useful information about what each function does.
These help pages also serve as code documentation, so reading them can
be bittersweet. They often seem to be written for people who already
understand the function and do not need help.

Don't let this bother you---you can gain a lot from a help page by
scanning it for information that makes sense and glossing over the rest.
This technique will inevitably bring you to the most helpful part of
each help page: the bottom. Here, almost every help page includes some
example code that puts the function in action. Running this code is a
great way to learn by example.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-warning-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning}, toprule=.15mm]

If a function comes in an R package, R won't be able to find its help
page unless the package is loaded.

\end{tcolorbox}

\subsection{Parts of a Help Page}\label{parts-of-a-help-page}

Each help page is divided into sections. Which sections appear can vary
from help page to help page, but you can usually expect to find these
useful topics:

\textbf{Description} - A short summary of what the function does.

\textbf{Usage} - An example of how you would type the function. Each
argument of the function will appear in the order R expects you to
supply it (if you don't use argument names).

\textbf{Arguments} - A list of each argument the function takes, what
type of information R expects you to supply for the argument, and what
the function will do with the information.

\textbf{Details} - A more in-depth description of the function and how
it operates. The details section also gives the function author a chance
to alert you to anything you might want to know when using the function.

\textbf{Value} - A description of what the function returns when you run
it.

\textbf{See Also} - A short list of related R functions.

\textbf{Examples} - Example code that uses the function and is
guaranteed to work. The examples section of a help page usually
demonstrates a couple different ways to use a function. This helps give
you an idea of what the function is capable of.

If you'd like to look up the help page for a function but have forgotten
the function's name, you can search by keyword. To do this, type two
question marks followed by a keyword in R's command line. R will pull up
a list of links to help pages related to the keyword. You can think of
this as the help page for the help page:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{??log}
\end{Highlighting}
\end{Shaded}

Let's take a stroll through \texttt{sample}'s help page. Remember: we're
searching for anything that could help you change the probabilities
involved in the sampling process. I'm not going to reproduce the whole
help page here (just the juiciest parts), so you should follow along on
your computer.

First, open the help page. It will appear in the same pane in RStudio as
your plots did (but in the Help tab, not the Plots tab):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?sample}
\end{Highlighting}
\end{Shaded}

What do you see? Starting from the top:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Random Samples and Permutations}

\NormalTok{Description}
\NormalTok{    sample takes a sample of the specified size from the elements of x using }
\NormalTok{either with or without replacement.}
\end{Highlighting}
\end{Shaded}

So far, so good. You knew all of that. The next section, Usage, has a
possible clue. It mentions an argument called \texttt{prob}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Usage}
\NormalTok{    sample(x, size, replace = FALSE, prob = NULL)}
\end{Highlighting}
\end{Shaded}

If you scroll down to the arguments section, the description of +prob+
sounds \emph{very} promising:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A vector of probability weights for obtaining the elements of the vector being }
\NormalTok{sampled.}
\end{Highlighting}
\end{Shaded}

The Details section confirms our suspicions. In this case, it also tells
you how to proceed:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{The optional prob argument can be used to give a vector of weights for obtaining }
\NormalTok{the elements of the vector being sampled. They need not sum to one, but they }
\NormalTok{should be nonnegative and not all zero.}
\end{Highlighting}
\end{Shaded}

Although the help page does not say it here, these weights will be
matched up to the elements being sampled in element-wise fashion. The
first weight will describe the first element, the second weight the
second element, and so on. This is common practice in R.

Reading on:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{If replace is true, Walker\textquotesingle{}s alias method (Ripley, 1987) is used...}
\end{Highlighting}
\end{Shaded}

Okay, that looks like time to start skimming. We should have enough info
now to figure out how to weight our dice.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Roll a Pair of Dice}\vspace{3mm}

Rewrite the \texttt{roll} function below to roll a pair of weighted
dice:

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  die }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}
\NormalTok{  dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(dice)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You will need to add a \texttt{prob} argument to the \texttt{sample}
function inside of \texttt{roll}. This argument should tell
\texttt{sample} to sample the numbers one through five with probability
1/8 and the number 6 with probability 3/8.

When you are finished, read on for a model answer.

To weight your dice, you need to add a \texttt{prob} argument with a
vector of weights to \texttt{sample}, like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  die }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}
\NormalTok{  dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }
    \AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\DecValTok{3}\SpecialCharTok{/}\DecValTok{8}\NormalTok{))}
  \FunctionTok{sum}\NormalTok{(dice)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This will cause \texttt{roll} to pick 1 through 5 with probability 1/8
and 6 with probability 3/8.

Overwrite your previous version of \texttt{roll} with the new function
(by running the previous code snippet in your command line). Then
visualize the new long-term behavior of your dice. I've put the results
in Figure~\ref{fig-weighted} next to our original results:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rolls }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{10000}\NormalTok{, }\FunctionTok{roll}\NormalTok{())}
\FunctionTok{qplot}\NormalTok{(rolls, }\AttributeTok{binwidth =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This confirms that we've effectively weighted the dice. High numbers
occur much more often than low numbers. The remarkable thing is that
this behavior will only be apparent when you examine long-term
frequencies. On any single roll, the dice will appear to behave
randomly. This is great news if you play Settlers of Catan (just tell
your friends you lost the dice), but it should be disturbing if you
analyze data, because it means that bias can easily occur without anyone
noticing it in the short run.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0205.png}}

}

\caption{\label{fig-weighted}The dice are now clearly biased towards
high numbers, since high sums occur much more often than low sums.}

\end{figure}%

\subsection{Getting More Help}\label{getting-more-help}

R also comes with a super active community of users that you can turn to
for \href{http://bit.ly/r-help}{help on the R-help mailing list}. You
can email the list with questions, but there's a great chance that your
question has already been answered. Find out by searching the
\href{http://bit.ly/R_archives}{archives}.

Even better than the R-help list is
\href{http://stackoverflow.com}{Stack Overflow}, a website that allows
programmers to answer questions and users to rank answers based on
helpfulness. Personally, I find the Stack Overflow format to be more
user-friendly than the R-help email list (and the respondents to be more
human friendly). You can submit your own question or search through
Stack Overflow's previously answered questions related to R. There are
over 30,000.

Best of all is
\href{http://community.rstudio.com}{community.rstudio.com}, a friendly,
inclusive place to share questions related to R. community.rstudio.com
is a very active forum focused on R. Don't be surprised if you ask a
question about an R package, and the author of the package shows up to
answer.

For all of the R help list, Stack Overflow, and community.rstudio.com,
you're more likely to get a useful answer if you provide a reproducible
example with your question. This means pasting in a short snippet of
code that users can run to arrive at the bug or question you have in
mind.

\section{Summary}\label{summary-1}

R's packages and help pages can make you a more productive programmer.
You saw in \hyperref[sec-basics]{The Very Basics} that R gives you the
power to write your own functions that do specific things, but often the
function that you want to write will already exist in an R package.
Professors, programmers, and scientists have developed over 13,000
packages for you to use, which can save you valuable programming time.
To use a package, you need to install it to your computer once with
\texttt{install.packages}, and then load it into each new R session with
\texttt{library}.

R's help pages will help you master the functions that appear in R and
its packages. Each function and data set in R has its own help page.
Although help pages often contain advanced content, they also contain
valuable clues and examples that can help you learn how to use a
function.

You have now seen enough of R to learn by doing, which is the best way
to learn R. You can make your own R commands, run them, and get help
when you need to understand something that I have not explained. I
encourage you to experiment with your own ideas in R as you read through
the next two projects.

\section{Project 1 Wrap-up}\label{project-1-wrap-up}

You've done more in this project than enable fraud and gambling; you've
also learned how to speak to your computer in the language of R. R is a
language like English, Spanish, or German, except R helps you talk to
computers, not humans.

You've met the nouns of the R language, objects. And hopefully you
guessed that functions are the verbs (I suppose function arguments would
be the adverbs). When you combine functions and objects, you express a
complete thought. By stringing thoughts together in a logical sequence,
you can build eloquent, even artistic statements. In that respect, R is
not that different than any other language.

R shares another characteristic of human languages: you won't feel very
comfortable speaking R until you build up a vocabulary of R commands to
use. Fortunately, you don't have to be bashful. Your computer will be
the only one to ``hear'' you speak R. Your computer is not very
forgiving, but it also doesn't judge. Not that you need to worry; you'll
broaden your R vocabulary tremendously between here and the end of the
book.

Now that you can use R, it is time to become an expert at using R to do
data science. The foundation of data science is the ability to store
large amounts of data and recall values on demand. From this, all else
follows---manipulating data, visualizing data, modeling data, and more.
However, you cannot easily store a data set in your mind by memorizing
it. Nor can you easily store a data set on paper by writing it down. The
only efficient way to store large amounts of data is with a computer. In
fact, computers are so efficient that their development over the last
three decades has completely changed the type of data we can accumulate
and the methods we can use to analyze it. In short, computer data
storage has driven the revolution in science that we call data science.

\hyperref[sec-project-cards]{Project 2: Playing Cards} will make you
part of this revolution by teaching you how to use R to store data sets
in your computer's memory and how to retrieve and manipulate data once
it's there.

\part{Project 2: Playing Cards}

This project--which spans the next four chapters--will teach you how to
store, retrieve, and change data values in your computer's memory. These
skills will help you save and manage data without accumulating errors.
In the project, you'll design a deck of playing cards that you can
shuffle and deal from. Best of all, the deck will remember which cards
have been dealt--just like a real deck. You can use the deck to play
card games, tell fortunes, and test card-counting strategies.

Along the way, you will learn how to:

\begin{itemize}
\tightlist
\item
  Save new types of data, like character strings and logical values
\item
  Save a data set as a vector, matrix, array, list, or data frame
\item
  Load and save your own data sets with R
\item
  Extract individual values from a data set
\item
  Change individual values within a data set
\item
  Write logical tests
\item
  Use R's missing-value symbol, NA
\end{itemize}

To keep the project simple, I've divided it into four tasks. Each task
will teach you a new skill for managing data with R:

\textbf{Task 1: build the deck}\\
In \hyperref[sec-r-objects]{R Objects}, you will design and build a
virtual deck of playing cards. This will be a complete data set, just
like the ones you will use as a data scientist. You'll need to know how
to use R's data types and data structures to make this work.

\textbf{Task 2: write functions that deal and shuffle}\\
Next, in \hyperref[sec-r-notation]{R Notation}, you will write two
functions to use with the deck. One function will deal cards from the
deck, and the other will reshuffle the deck. To write these functions,
you'll need to know how to extract values from a data set with R.

\textbf{Task 3: change the point system to suit your game}\\
In \hyperref[sec-modifying-values]{Modifying Values}, you will use R's
notation system to change the point values of your cards to match the
card games you may wish to play, like war, hearts, or blackjack. This
will help you change values in place in existing data sets.

\textbf{Task 4: manage the state of the deck}\\
Finally, in \hyperref[sec-environments]{Environments}, you will make
sure that your deck remembers which cards it has dealt. This is an
advanced task, and it will introduce R's environment system and scoping
rules. To do it successfully, you will need to learn the minute details
of how R looks up and uses the data that you have stored in your
computer.

\chapter{R Objects}\label{sec-r-objects}

In this chapter, you'll use R to assemble a deck of 52 playing cards.

You'll start by building simple R objects that represent playing cards
and then work your way up to a full-blown table of data. In short,
you'll build the equivalent of an Excel spreadsheet from scratch. When
you are finished, your deck of cards will look something like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ face   suit value}
\NormalTok{ king spades    }\DecValTok{13}
\NormalTok{queen spades    }\DecValTok{12}
\NormalTok{ jack spades    }\DecValTok{11}
\NormalTok{  ten spades    }\DecValTok{10}
\NormalTok{ nine spades     }\DecValTok{9}
\NormalTok{eight spades     }\DecValTok{8}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

Do you need to build a data set from scratch to use it in R? Not at all.
You can load most data sets into R with one simple step, see
\hyperref[sec-loading-data]{Loading Data}. But this exercise will teach
you how R stores data, and how you can assemble---or disassemble---your
own data sets. You will also learn about the various types of objects
available for you to use in R (not all R objects are the same!).
Consider this exercise a rite of passage; by doing it, you will become
an expert on storing data in R.

We'll start with the very basics. The most simple type of object in R is
an \emph{atomic vector}. Atomic vectors are not nuclear powered, but
they are very simple and they do show up everywhere. If you look closely
enough, you'll see that most structures in R are built from atomic
vectors.

\section{Atomic Vectors}\label{atomic-vectors}

An atomic vector is just a simple vector of data. In fact, you've
already made an atomic vector, your \texttt{die} object from
\hyperref[sec-project-dice]{Project 1: Weighted Dice}. You can make an
atomic vector by grouping some values of data together with \texttt{c}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{die}
\DocumentationTok{\#\# 1 2 3 4 5 6}

\FunctionTok{is.vector}\NormalTok{(die)}
\DocumentationTok{\#\#  TRUE}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{is.vector}, toprule=.15mm]

\texttt{is.vector} tests whether an object is an atomic vector. It
returns \texttt{TRUE} if the object is an atomic vector and
\texttt{FALSE} otherwise.

\end{tcolorbox}

You can also make an atomic vector with just one value. R saves single
values as an atomic vector of length 1:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{five }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{five}
\DocumentationTok{\#\# 5}

\FunctionTok{is.vector}\NormalTok{(five)}
\DocumentationTok{\#\#  TRUE}

\FunctionTok{length}\NormalTok{(five)}
\DocumentationTok{\#\# 1}
\FunctionTok{length}\NormalTok{(die)}
\DocumentationTok{\#\# 6}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{length}, toprule=.15mm]

\texttt{length} returns the length of an atomic vector.

\end{tcolorbox}

Each atomic vector stores its values as a one-dimensional vector, and
each atomic vector can only store one type of data. You can save
different types of data in R by using different types of atomic vectors.
Altogether, R recognizes six basic types of atomic vectors:
\emph{doubles}, \emph{integers}, \emph{characters}, \emph{logicals},
\emph{complex}, and \emph{raw}.

To create your card deck, you will need to use different types of atomic
vectors to save different types of information (text and numbers). You
can do this by using some simple conventions when you enter your data.
For example, you can create an integer vector by including a capital
\texttt{L} with your input. You can create a character vector by
surrounding your input in quotation marks:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{int }\OtherTok{\textless{}{-}} \DecValTok{1}\NormalTok{L}
\NormalTok{text }\OtherTok{\textless{}{-}} \StringTok{"ace"}
\end{Highlighting}
\end{Shaded}

Each type of atomic vector has its own convention (described below). R
will recognize the convention and use it to create an atomic vector of
the appropriate type. If you'd like to make atomic vectors that have
more than one element in them, you can combine an element with the
\texttt{c} function. Use the same convention with each element:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{int }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{L, }\DecValTok{5}\NormalTok{L)}
\NormalTok{text }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You may wonder why R uses multiple types of vectors. Vector types help R
behave as you would expect. For example, R will do math with atomic
vectors that contain numbers, but not with atomic vectors that contain
character strings:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(int)}
\DocumentationTok{\#\# 6}

\FunctionTok{sum}\NormalTok{(text)}
\DocumentationTok{\#\# Error in sum(text) : invalid \textquotesingle{}type\textquotesingle{} (character) of argument}
\end{Highlighting}
\end{Shaded}

But we're getting ahead of ourselves! Get ready to say hello to the six
types of atomic vectors in R.

\subsection{Doubles}\label{doubles}

A double vector stores regular numbers. The numbers can be positive or
negative, large or small, and have digits to the right of the decimal
place or not. In general, R will save any number that you type in R as a
double. So, for example, the die you made in
\hyperref[sec-project-dice]{Project 1: Weighted Dice} was a double
object:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{die}
\DocumentationTok{\#\# 1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

You'll usually know what type of object you are working with in R (it
will be obvious), but you can also ask R what type of object an object
is with \texttt{typeof}. For example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(die)}
\DocumentationTok{\#\#  "double"}
\end{Highlighting}
\end{Shaded}

Some R functions refer to doubles as ``numerics,'' and I will often do
the same. Double is a computer science term. It refers to the specific
number of bytes your computer uses to store a number, but I find
``numeric'' to be much more intuitive when doing data science.

\subsection{Integers}\label{integers}

Integer vectors store integers, numbers that can be written without a
decimal component. As a data scientist, you won't use the integer type
very often because you can save integers as a double object.

You can specifically create an integer in R by typing a number followed
by an uppercase \texttt{L}. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{int }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{L, }\DecValTok{2}\NormalTok{L, }\DecValTok{4}\NormalTok{L)}
\NormalTok{int}
\DocumentationTok{\#\# {-}1  2  4}

\FunctionTok{typeof}\NormalTok{(int)}
\DocumentationTok{\#\# "integer"}
\end{Highlighting}
\end{Shaded}

Note that R won't save a number as an integer unless you include the
\texttt{L}. Integer numbers without the \texttt{L} will be saved as
doubles. The only difference between \texttt{4} and \texttt{4L} is how R
saves the number in your computer's memory. Integers are defined more
precisely in your computer's memory than doubles (unless the integer is
\emph{very} large or small).

Why would you save your data as an integer instead of a double?
Sometimes a difference in precision can have surprising effects. Your
computer allocates 64 bits of memory to store each double in an R
program. This allows a lot of precision, but some numbers cannot be
expressed exactly in 64 bits, the equivalent of a sequence of 64 ones
and zeroes. For example, the number \(\pi\) contains an endless
sequences of digits to the right of the decimal place. Your computer
must round \(\pi\) to something close to, but not exactly equal to
\(\pi\) to store \(\pi\) in its memory. Many decimal numbers share a
similar fate.

As a result, each double is accurate to about 16 significant digits.
This introduces a little bit of error. In most cases, this rounding
error will go unnoticed. However, in some situations, the rounding error
can cause surprising results. For example, you may expect the result of
the expression below to be zero, but it is not:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{{-}} \DecValTok{2}
\DocumentationTok{\#\# 4.440892e{-}16}
\end{Highlighting}
\end{Shaded}

The square root of two cannot be expressed exactly in 16 significant
digits. As a result, R has to round the quantity, and the expression
resolves to something very close to---but not quite---zero.

These errors are known as \emph{floating-point} errors, and doing
arithmetic in these conditions is known as \emph{floating-point
arithmetic}. Floating-point arithmetic is not a feature of R; it is a
feature of computer programming. Usually floating-point errors won't be
enough to ruin your day. Just keep in mind that they may be the cause of
surprising results.

You can avoid floating-point errors by avoiding decimals and only using
integers. However, this is not an option in most data-science
situations. You cannot do much math with integers before you need a
noninteger to express the result. Luckily, the errors caused by
floating-point arithmetic are usually insignificant (and when they are
not, they are easy to spot). As a result, you'll generally use doubles
instead of integers as a data scientist.

\subsection{Characters}\label{characters}

A character vector stores small pieces of text. You can create a
character vector in R by typing a character or string of characters
surrounded by quotes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Hello"}\NormalTok{,  }\StringTok{"World"}\NormalTok{)}
\NormalTok{text}
\DocumentationTok{\#\#  "Hello"  "World"}

\FunctionTok{typeof}\NormalTok{(text)}
\DocumentationTok{\#\# "character"}

\FunctionTok{typeof}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\DocumentationTok{\#\# "character"}
\end{Highlighting}
\end{Shaded}

The individual elements of a character vector are known as
\emph{strings}. Note that a string can contain more than just letters.
You can assemble a character string from numbers or symbols as well.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Character or Number?}\vspace{3mm}

Can you spot the difference between a character string and a number?
Here's a test: Which of these are character strings and which are
numbers? \texttt{1}, \texttt{"1"}, \texttt{"one"}.

\end{tcolorbox}

\texttt{"1"} and \texttt{"one"} are both character strings.

Character strings can contain number characters, but that doesn't make
them numeric. They're just strings that happen to have numbers in them.
You can tell strings from real numbers because strings come surrounded
by quotes. In fact, anything surrounded by quotes in R will be treated
as a character string---no matter what appears between the quotes.

It is easy to confuse R objects with character strings. Why? Because
both appear as pieces of text in R code. For example, \texttt{x} is the
name of an R object named ``x,'' \texttt{"x"} is a character string that
contains the character ``x.'' One is an object that contains raw data,
the other is a piece of raw data itself.

Expect an error whenever you forget your quotation marks; R will start
looking for an object that probably does not exist.

\subsection{Logicals}\label{sec-logicals}

Logical vectors store \texttt{TRUE}s and \texttt{FALSE}s, R's form of
Boolean data. Logicals are very helpful for doing things like
comparisons:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3} \SpecialCharTok{\textgreater{}} \DecValTok{4}
\DocumentationTok{\#\# FALSE}
\end{Highlighting}
\end{Shaded}

Any time you type \texttt{TRUE} or \texttt{FALSE} in capital letters
(without quotation marks), R will treat your input as logical data. R
also assumes that \texttt{T} and \texttt{F} are shorthand for
\texttt{TRUE} and \texttt{FALSE}, unless they are defined elsewhere
(e.g.~\texttt{T\ \textless{}-\ 500}). Since the meaning of \texttt{T}
and \texttt{F} can change, its best to stick with \texttt{TRUE} and
\texttt{FALSE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{logic }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{)}
\NormalTok{logic}
\DocumentationTok{\#\#   TRUE FALSE  TRUE}

\FunctionTok{typeof}\NormalTok{(logic)}
\DocumentationTok{\#\# "logical"}

\FunctionTok{typeof}\NormalTok{(F)}
\DocumentationTok{\#\# "logical"}
\end{Highlighting}
\end{Shaded}

\subsection{Complex and Raw}\label{complex-and-raw}

Doubles, integers, characters, and logicals are the most common types of
atomic vectors in R, but R also recognizes two more types: complex and
raw. It is doubtful that you will ever use these to analyze data, but
here they are for the sake of thoroughness.

Complex vectors store complex numbers. To create a complex vector, add
an imaginary term to a number with \texttt{i}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{comp }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1} \SpecialCharTok{+} \DecValTok{1}\NormalTok{i, }\DecValTok{1} \SpecialCharTok{+} \DecValTok{2}\NormalTok{i, }\DecValTok{1} \SpecialCharTok{+} \DecValTok{3}\NormalTok{i)}
\NormalTok{comp}
\DocumentationTok{\#\# 1+1i 1+2i 1+3i}

\FunctionTok{typeof}\NormalTok{(comp)}
\DocumentationTok{\#\# "complex"}
\end{Highlighting}
\end{Shaded}

Raw vectors store raw bytes of data. Making raw vectors gets
complicated, but you can make an empty raw vector of length \emph{n}
with \texttt{raw(n)}. See the help page of \texttt{raw} for more options
when working with this type of data:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{raw}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# 00 00 00}

\FunctionTok{typeof}\NormalTok{(}\FunctionTok{raw}\NormalTok{(}\DecValTok{3}\NormalTok{))}
\DocumentationTok{\#\# "raw"}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Vector of Cards}\vspace{3mm}

Create an atomic vector that stores just the face names of the cards in
a royal flush, for example, the ace of spades, king of spades, queen of
spades, jack of spades, and ten of spades. The face name of the ace of
spades would be ``ace,'' and ``spades'' is the suit.

Which type of vector will you use to save the names?

\end{tcolorbox}

A character vector is the most appropriate type of atomic vector in
which to save card names. You can create one with the \texttt{c}
function if you surround each name with quotation marks:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hand }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{)}
\NormalTok{hand}
\DocumentationTok{\#\# "ace"   "king"  "queen" "jack"  "ten"  }

\FunctionTok{typeof}\NormalTok{(hand)}
\DocumentationTok{\#\# "character"}
\end{Highlighting}
\end{Shaded}

This creates a one-dimensional group of card names---great job! Now
let's make a more sophisticated data structure, a two-dimensional table
of card names and suits. You can build a more sophisticated object from
an atomic vector by giving it some attributes and assigning it a class.

\section{Attributes}\label{sec-attributes}

An attribute is a piece of information that you can attach to an atomic
vector (or any R object). The attribute won't affect any of the values
in the object, and it will not appear when you display your object. You
can think of an attribute as ``metadata''; it is just a convenient place
to put information associated with an object. R will normally ignore
this metadata, but some R functions will check for specific attributes.
These functions may use the attributes to do special things with the
data.

You can see which attributes an object has with \texttt{attributes}.
\texttt{attributes} will return \texttt{NULL} if an object has no
attributes. An atomic vector, like \texttt{die}, won't have any
attributes unless you give it some:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(die)}
\DocumentationTok{\#\# NULL}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{\texttt{NULL}}, toprule=.15mm]

R uses \texttt{NULL} to represent the null set, an empty object.
\texttt{NULL} is often returned by functions whose values are undefined.
You can create a \texttt{NULL} object by typing \texttt{NULL} in capital
letters.

\end{tcolorbox}

\subsection{Names}\label{sec-names}

The most common attributes to give an atomic vector are names,
dimensions (dim), and classes. Each of these attributes has its own
helper function that you can use to give attributes to an object. You
can also use the helper functions to look up the value of these
attributes for objects that already have them. For example, you can look
up the value of the names attribute of \texttt{die} with \texttt{names}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(die)}
\DocumentationTok{\#\# NULL}
\end{Highlighting}
\end{Shaded}

\texttt{NULL} means that \texttt{die} does not have a names attribute.
You can give one to \texttt{die} by assigning a character vector to the
output of \texttt{names}. The vector should include one name for each
element in \texttt{die}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(die) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"one"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"five"}\NormalTok{, }\StringTok{"six"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now \texttt{die} has a names attribute:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(die)}
\DocumentationTok{\#\# "one"   "two"   "three" "four"  "five"  "six" }

\FunctionTok{attributes}\NormalTok{(die)}
\DocumentationTok{\#\# $names}
\DocumentationTok{\#\# [1] "one"   "two"   "three" "four"  "five"  "six"}
\end{Highlighting}
\end{Shaded}

R will display the names above the elements of \texttt{die} whenever you
look at the vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die}
\DocumentationTok{\#\#  one   two three  four  five   six }
\DocumentationTok{\#\#    1     2     3     4     5     6 }
\end{Highlighting}
\end{Shaded}

However, the names won't affect the actual values of the vector, nor
will the names be affected when you manipulate the values of the vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\SpecialCharTok{+} \DecValTok{1}
\DocumentationTok{\#\#  one   two three  four  five   six }
\DocumentationTok{\#\#    2     3     4     5     6     7}
\end{Highlighting}
\end{Shaded}

You can also use \texttt{names} to change the names attribute or remove
it all together. To change the names, assign a new set of labels to
\texttt{names}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(die) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"uno"}\NormalTok{, }\StringTok{"dos"}\NormalTok{, }\StringTok{"tres"}\NormalTok{, }\StringTok{"quatro"}\NormalTok{, }\StringTok{"cinco"}\NormalTok{, }\StringTok{"seis"}\NormalTok{)}
\NormalTok{die}
\DocumentationTok{\#\#   uno    dos   tres quatro  cinco   seis }
\DocumentationTok{\#\#     1      2      3      4      5      6 }
\end{Highlighting}
\end{Shaded}

To remove the names attribute, set it to \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(die) }\OtherTok{\textless{}{-}} \ConstantTok{NULL}
\NormalTok{die}
\DocumentationTok{\#\#  1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

\subsection{Dim}\label{dim}

You can transform an atomic vector into an \emph{n}-dimensional array by
giving it a dimensions attribute with \texttt{dim}. To do this, set the
\texttt{dim} attribute to a numeric vector of length \emph{n}. R will
reorganize the elements of the vector into \emph{n} dimensions. Each
dimension will have as many rows (or columns, etc.) as the \emph{nth}
value of the \texttt{dim} vector. For example, you can reorganize
\texttt{die} into a 2  3 matrix (which has 2 rows and 3 columns):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(die) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{die}
\DocumentationTok{\#\#      [,1] [,2] [,3]}
\DocumentationTok{\#\# [1,]    1    3    5}
\DocumentationTok{\#\# [2,]    2    4    6}
\end{Highlighting}
\end{Shaded}

or a 3  2 matrix (which has 3 rows and 2 columns):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(die) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{die}
\DocumentationTok{\#\#      [,1] [,2]}
\DocumentationTok{\#\# [1,]    1    4}
\DocumentationTok{\#\# [2,]    2    5}
\DocumentationTok{\#\# [3,]    3    6}
\end{Highlighting}
\end{Shaded}

or a 1  2  3 hypercube (which has 1 row, 2 columns, and 3 ``slices'').
This is a three-dimensional structure, but R will need to show it slice
by slice by slice on your two-dimensional computer screen:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(die) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{die}
\DocumentationTok{\#\# , , 1}
\DocumentationTok{\#\# }
\DocumentationTok{\#\#      [,1] [,2]}
\DocumentationTok{\#\# [1,]    1    2}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# , , 2}
\DocumentationTok{\#\# }
\DocumentationTok{\#\#      [,1] [,2]}
\DocumentationTok{\#\# [1,]    3    4}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# , , 3}
\DocumentationTok{\#\# }
\DocumentationTok{\#\#      [,1] [,2]}
\DocumentationTok{\#\# [1,]    5    6}
\end{Highlighting}
\end{Shaded}

R will always use the first value in \texttt{dim} for the number of rows
and the second value for the number of columns. In general, rows always
come first in R operations that deal with both rows and columns.

You may notice that you don't have much control over how R reorganizes
the values into rows and columns. For example, R always fills up each
matrix by columns, instead of by rows. If you'd like more control over
this process, you can use one of R's helper functions, \texttt{matrix}
or \texttt{array}. They do the same thing as changing the \texttt{dim}
attribute, but they provide extra arguments to customize the process.

\section{Matrices}\label{matrices}

Matrices store values in a two-dimensional array, just like a matrix
from linear algebra. To create one, first give \texttt{matrix} an atomic
vector to reorganize into a matrix. Then, define how many rows should be
in the matrix by setting the \texttt{nrow} argument to a number.
\texttt{matrix} will organize your vector of values into a matrix with
the specified number of rows. Alternatively, you can set the
\texttt{ncol} argument, which tells R how many columns to include in the
matrix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(die, }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{)}
\NormalTok{m}
\DocumentationTok{\#\#      [,1] [,2] [,3]}
\DocumentationTok{\#\# [1,]    1    3    5}
\DocumentationTok{\#\# [2,]    2    4    6}
\end{Highlighting}
\end{Shaded}

\texttt{matrix} will fill up the matrix column by column by default, but
you can fill the matrix row by row if you include the argument
\texttt{byrow\ =\ TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(die, }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{m}
\DocumentationTok{\#\#      [,1] [,2] [,3]}
\DocumentationTok{\#\# [1,]    1    2    3}
\DocumentationTok{\#\# [2,]    4    5    6}
\end{Highlighting}
\end{Shaded}

\texttt{matrix} also has other default arguments that you can use to
customize your matrix. You can read about them at \texttt{matrix}'s help
page (accessible by \texttt{?matrix}).

\section{Arrays}\label{arrays}

The \texttt{array} function creates an n-dimensional array. For example,
you could use \texttt{array} to sort values into a cube of three
dimensions or a hypercube in 4, 5, or \emph{n} dimensions.
\texttt{array} is not as customizeable as \texttt{matrix} and basically
does the same thing as setting the \texttt{dim} attribute. To use
\texttt{array}, provide an atomic vector as the first argument, and a
vector of dimensions as the second argument, now called \texttt{dim}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ar }\OtherTok{\textless{}{-}} \FunctionTok{array}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{11}\SpecialCharTok{:}\DecValTok{14}\NormalTok{, }\DecValTok{21}\SpecialCharTok{:}\DecValTok{24}\NormalTok{, }\DecValTok{31}\SpecialCharTok{:}\DecValTok{34}\NormalTok{), }\AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\NormalTok{ar}
\DocumentationTok{\#\# , , 1}
\DocumentationTok{\#\# }
\DocumentationTok{\#\#      [,1] [,2]}
\DocumentationTok{\#\# [1,]   11   13}
\DocumentationTok{\#\# [2,]   12   14}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# , , 2}
\DocumentationTok{\#\# }
\DocumentationTok{\#\#      [,1] [,2]}
\DocumentationTok{\#\# [1,]   21   23}
\DocumentationTok{\#\# [2,]   22   24}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# , , 3}
\DocumentationTok{\#\# }
\DocumentationTok{\#\#      [,1] [,2]}
\DocumentationTok{\#\# [1,]   31   33}
\DocumentationTok{\#\# [2,]   32   34}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Make a Matrix}\vspace{3mm}

Create the following matrix, which stores the name and suit of every
card in a royal flush.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\#      [,1]    [,2]    }
\DocumentationTok{\#\# [1,] "ace"   "spades"}
\DocumentationTok{\#\# [2,] "king"  "spades"}
\DocumentationTok{\#\# [3,] "queen" "spades"}
\DocumentationTok{\#\# [4,] "jack"  "spades"}
\DocumentationTok{\#\# [5,] "ten"   "spades"}
\end{Highlighting}
\end{Shaded}

There is more than one way to build this matrix, but in every case, you
will need to start by making a character vector with 10 values. If you
start with the following character vector, you can turn it into a matrix
with any of the following three commands:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hand1 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }
  \StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{)}

\FunctionTok{matrix}\NormalTok{(hand1, }\AttributeTok{nrow =} \DecValTok{5}\NormalTok{)}
\FunctionTok{matrix}\NormalTok{(hand1, }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{)}
\FunctionTok{dim}\NormalTok{(hand1) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can also start with a character vector that lists the cards in a
slightly different order. In this case, you will need to ask R to fill
the matrix row by row instead of column by column:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hand2 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"king"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }
  \StringTok{"spades"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"spades"}\NormalTok{)}

\FunctionTok{matrix}\NormalTok{(hand2, }\AttributeTok{nrow =} \DecValTok{5}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{matrix}\NormalTok{(hand2, }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\section{Class}\label{class}

Notice that changing the dimensions of your object will not change the
type of the object, but it \emph{will} change the object's
\texttt{class} attribute:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(die) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\FunctionTok{typeof}\NormalTok{(die)}
\DocumentationTok{\#\#  "double"}
 
\FunctionTok{class}\NormalTok{(die)}
\DocumentationTok{\#\#  "matrix"}
\end{Highlighting}
\end{Shaded}

A matrix is a special case of an atomic vector. For example, the
\texttt{die} matrix is a special case of a double vector. Every element
in the matrix is still a double, but the elements have been arranged
into a new structure. R added a \texttt{class} attribute to \texttt{die}
when you changed its dimensions. This class describes \texttt{die}'s new
format. Many R functions will specifically look for an object's
\texttt{class} attribute, and then handle the object in a predetermined
way based on the attribute.

Note that an object's \texttt{class} attribute will not always appear
when you run \texttt{attributes}; you may need to specifically search
for it with \texttt{class}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(die)}
\DocumentationTok{\#\# $dim}
\DocumentationTok{\#\# [1] 2 3}
\end{Highlighting}
\end{Shaded}

You can apply \texttt{class} to objects that do not have a
\texttt{class} attribute. \texttt{class} will return a value based on
the object's atomic type. Notice that the ``class'' of a double is
``numeric,'' an odd deviation, but one I am thankful for. I think that
the most important property of a double vector is that it contains
numbers, a property that ``numeric'' makes obvious:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\DocumentationTok{\#\#  "character"}

\FunctionTok{class}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\DocumentationTok{\#\#  "numeric"}
\end{Highlighting}
\end{Shaded}

You can also use \texttt{class} to set an object's \texttt{class}
attribute, but this is usually a bad idea. R will expect objects of a
class to share certain traits, such as attributes, that your object may
not possess. You'll learn how to make and use your own classes in
\hyperref[sec-project-slots]{Project 3: Slot Machine}.

\subsection{Dates and Times}\label{dates-and-times}

The attribute system lets R represent more types of data than just
doubles, integers, characters, logicals, complexes, and raws. The time
looks like a character string when you display it, but its data type is
actually \texttt{"double"}, and its class is \texttt{"POSIXct"}
\texttt{"POSIXt"} (it has two classes):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{now }\OtherTok{\textless{}{-}} \FunctionTok{Sys.time}\NormalTok{()}
\NormalTok{now}
\DocumentationTok{\#\# "2014{-}03{-}17 12:00:00 UTC"}

\FunctionTok{typeof}\NormalTok{(now)}
\DocumentationTok{\#\#  "double"}

\FunctionTok{class}\NormalTok{(now)}
\DocumentationTok{\#\# "POSIXct" "POSIXt" }
\end{Highlighting}
\end{Shaded}

POSIXct is a widely used framework for representing dates and times. In
the POSIXct framework, each time is represented by the number of seconds
that have passed between the time and 12:00 AM January 1st 1970 (in the
Universal Time Coordinated (UTC) zone). For example, the time above
occurs 1,395,057,600 seconds after then. So in the POSIXct system, the
time would be saved as 1395057600.

R creates the time object by building a double vector with one element,
\texttt{1395057600}. You can see this vector by removing the
\texttt{class} attribute of \texttt{now}, or by using the
\texttt{unclass} function, which does the same thing:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unclass}\NormalTok{(now)}
\DocumentationTok{\#\# 1395057600}
\end{Highlighting}
\end{Shaded}

R then gives the double vector a \texttt{class} attribute that contains
two classes, \texttt{"POSIXct"} and \texttt{"POSIXt"}. This attribute
alerts R functions that they are dealing with a POSIXct time, so they
can treat it in a special way. For example, R functions will use the
POSIXct standard to convert the time into a user-friendly character
string before displaying it.

You can take advantage of this system by giving the \texttt{POSIXct}
class to random R objects. For example, have you ever wondered what day
it was a million seconds after 12:00 a.m. Jan.~1, 1970?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mil }\OtherTok{\textless{}{-}} \DecValTok{1000000}
\NormalTok{mil}
\DocumentationTok{\#\# 1e+06}
 
\FunctionTok{class}\NormalTok{(mil) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"POSIXct"}\NormalTok{, }\StringTok{"POSIXt"}\NormalTok{)}
\NormalTok{mil}
\DocumentationTok{\#\# "1970{-}01{-}12 13:46:40 UTC"}
\end{Highlighting}
\end{Shaded}

Jan.~12, 1970. Yikes. A million seconds goes by faster than you would
think. This conversion worked well because the \texttt{POSIXct} class
does not rely on any additional attributes, but in general, forcing the
class of an object is a bad idea.

There are many different classes of data in R and its packages, and new
classes are invented every day. It would be difficult to learn about
every class, but you do not have to. Most classes are only useful in
specific situations. Since each class comes with its own help page, you
can wait to learn about a class until you encounter it. However, there
is one class of data that is so ubiquitous in R that you should learn
about it alongside the atomic data types. That class is
\texttt{factors}.

\subsection{Factors}\label{factors}

Factors are R's way of storing categorical information, like ethnicity
or eye color. Think of a factor as something like a gender; it can only
have certain values (male or female), and these values may have their
own idiosyncratic order (ladies first). This arrangement makes factors
very useful for recording the treatment levels of a study and other
categorical variables.

To make a factor, pass an atomic vector into the \texttt{factor}
function. R will recode the data in the vector as integers and store the
results in an integer vector. R will also add a \texttt{levels}
attribute to the integer, which contains a set of labels for displaying
the factor values, and a \texttt{class} attribute, which contains the
class \texttt{factor}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gender }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"male"}\NormalTok{, }\StringTok{"female"}\NormalTok{, }\StringTok{"female"}\NormalTok{, }\StringTok{"male"}\NormalTok{))}

\FunctionTok{typeof}\NormalTok{(gender)}
\DocumentationTok{\#\# "integer"}

\FunctionTok{attributes}\NormalTok{(gender)}
\DocumentationTok{\#\# $levels}
\DocumentationTok{\#\# [1] "female" "male"  }
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $class}
\DocumentationTok{\#\# [1] "factor"}
\end{Highlighting}
\end{Shaded}

You can see exactly how R is storing your factor with \texttt{unclass}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unclass}\NormalTok{(gender)}
\DocumentationTok{\#\# [1] 2 1 1 2}
\DocumentationTok{\#\# attr(,"levels")}
\DocumentationTok{\#\# [1] "female" "male"  }
\end{Highlighting}
\end{Shaded}

R uses the levels attribute when it displays the factor, as you will
see. R will display each \texttt{1} as \texttt{female}, the first label
in the levels vector, and each \texttt{2} as \texttt{male}, the second
label. If the factor included \texttt{3}s, they would be displayed as
the third label, and so on:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gender}
\DocumentationTok{\#\# male   female female male  }
\DocumentationTok{\#\# Levels: female male}
\end{Highlighting}
\end{Shaded}

Factors make it easy to put categorical variables into a statistical
model because the variables are already coded as numbers. However,
factors can be confusing since they look like character strings but
behave like integers.

R will often try to convert character strings to factors when you load
and create data. In general, you will have a smoother experience if you
do not let R make factors until you ask for them. I'll show you how to
do this when we start reading in data.

You can convert a factor to a character string with the
\texttt{as.character} function. R will retain the display version of the
factor, not the integers stored in memory:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.character}\NormalTok{(gender)}
\DocumentationTok{\#\# "male"   "female" "female" "male"}
\end{Highlighting}
\end{Shaded}

Now that you understand the possibilities provided by R's atomic
vectors, let's make a more complicated type of playing card.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Write a Card}\vspace{3mm}

Many card games assign a numerical value to each card. For example, in
blackjack, each face card is worth 10 points, each number card is worth
between 2 and 10 points, and each ace is worth 1 or 11 points, depending
on the final score.

Make a virtual playing card by combining ``ace,'' ``heart,'' and 1 into
a vector. What type of atomic vector will result? Check if you are
right.

\end{tcolorbox}

You may have guessed that this exercise would not go well. Each atomic
vector can only store one type of data. As a result, R coerces all of
your values to character strings:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{card }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{card}
\DocumentationTok{\#\# "ace"    "hearts" "1" }
\end{Highlighting}
\end{Shaded}

This will cause trouble if you want to do math with that point value,
for example, to see who won your game of blackjack.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-warning-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Data types in vectors}, toprule=.15mm]

If you try to put multiple types of data into a vector, R will convert
the elements to a single type of data.

\end{tcolorbox}

Since matrices and arrays are special cases of atomic vectors, they
suffer from the same behavior. Each can only store one type of data.

This creates a couple of problems. First, many data sets contain
multiple types of data. Simple programs like Excel and Numbers can save
multiple types of data in the same data set, and you should hope that R
can too. Don't worry, it can.

Second, coercion is a common behavior in R, so you'll want to know how
it works.

\section{Coercion}\label{coercion}

R's coercion behavior may seem inconvenient, but it is not arbitrary. R
always follows the same rules when it coerces data types. Once you are
familiar with these rules, you can use R's coercion behavior to do
surprisingly useful things.

So how does R coerce data types? If a character string is present in an
atomic vector, R will convert everything else in the vector to character
strings. If a vector only contains logicals and numbers, R will convert
the logicals to numbers; every \texttt{TRUE} becomes a 1, and every
\texttt{FALSE} becomes a 0, as shown in Figure~\ref{fig-coercion}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0301.png}}

}

\caption{\label{fig-coercion}R always uses the same rules to coerce data
to a single type. If character strings are present, everything will be
coerced to a character string. Otherwise, logicals are coerced to
numerics.}

\end{figure}%

This arrangement preserves information. It is easy to look at a
character string and tell what information it used to contain. For
example, you can easily spot the origins of \texttt{"TRUE"} and
\texttt{"5"}. You can also easily back-transform a vector of 1s and 0s
to \texttt{TRUE}s and \texttt{FALSE}s.

R uses the same coercion rules when you try to do math with logical
values. So the following code:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

will become:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{))}
\DocumentationTok{\#\# 2}
\end{Highlighting}
\end{Shaded}

This means that \texttt{sum} will count the number of \texttt{TRUE}s in
a logical vector (and \texttt{mean} will calculate the proportion of
\texttt{TRUE}s). Neat, huh?

You can explicitly ask R to convert data from one type to another with
the \texttt{as} functions. R will convert the data whenever there is a
sensible way to do so:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.character}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# "1"}

\FunctionTok{as.logical}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# TRUE}

\FunctionTok{as.numeric}\NormalTok{(}\ConstantTok{FALSE}\NormalTok{)}
\DocumentationTok{\#\# 0}
\end{Highlighting}
\end{Shaded}

You now know how R coerces data types, but this won't help you save a
playing card. To do that, you will need to avoid coercion altogether.
You can do this by using a new type of object, a \emph{list}.

Before we look at lists, let's address a question that might be on your
mind.

Many data sets contain multiple types of information. The inability of
vectors, matrices, and arrays to store multiple data types seems like a
major limitation. So why bother with them?

In some cases, using only a single type of data is a huge advantage.
Vectors, matrices, and arrays make it very easy to do math on large sets
of numbers because R knows that it can manipulate each value the same
way. Operations with vectors, matrices, and arrays also tend to be fast
because the objects are so simple to store in memory.

In other cases, allowing only a single type of data is not a
disadvantage. Vectors are the most common data structure in R because
they store variables very well. Each value in a variable measures the
same property, so there's no need to use different types of data.

\section{Lists}\label{lists}

Lists are like atomic vectors because they group data into a
one-dimensional set. However, lists do not group together individual
values; lists group together R objects, such as atomic vectors and other
lists. For example, you can make a list that contains a numeric vector
of length 31 in its first element, a character vector of length 1 in its
second element, and a new list of length 2 in its third element. To do
this, use the \texttt{list} function.

\texttt{list} creates a list the same way \texttt{c} creates a vector.
Separate each element in the list with a comma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1 }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\DecValTok{100}\SpecialCharTok{:}\DecValTok{130}\NormalTok{, }\StringTok{"R"}\NormalTok{, }\FunctionTok{list}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{))}
\NormalTok{list1}
\DocumentationTok{\#\# [[1]]}
\DocumentationTok{\#\# [1] 100 101 102 103 104 105 106 107 108 109 110 111 112}
\DocumentationTok{\#\# [14] 113 114 115 116 117 118 119 120 121 122 123 124 125}
\DocumentationTok{\#\# [27] 126 127 128 129 130}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# [[2]]}
\DocumentationTok{\#\# [1] "R"}
\DocumentationTok{\#\#}
\DocumentationTok{\#\# [[3]]}
\DocumentationTok{\#\# [[3]][[1]]}
\DocumentationTok{\#\# [1] TRUE}
\DocumentationTok{\#\#}
\DocumentationTok{\#\# [[3]][[2]]}
\DocumentationTok{\#\# [1] FALSE}
\end{Highlighting}
\end{Shaded}

I left the \texttt{{[}1{]}} notation in the output so you can see how it
changes for lists. The double-bracketed indexes tell you which element
of the list is being displayed. The single-bracket indexes tell you
which subelement of an element is being displayed. For example,
\texttt{100} is the first subelement of the first element in the list.
\texttt{"R"} is the first sub-element of the second element. This
two-system notation arises because each element of a list can be
\emph{any} R object, including a new vector (or list) with its own
indexes.

Lists are a basic type of object in R, on par with atomic vectors. Like
atomic vectors, they are used as building blocks to create many more
spohisticated types of R objects.

As you can imagine, the structure of lists can become quite complicated,
but this flexibility makes lists a useful all-purpose storage tool in R:
you can group together anything with a list.

However, not every list needs to be complicated. You can store a playing
card in a very simple list.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Use a List to Make a Card}\vspace{3mm}

Use a list to store a single playing card, like the ace of hearts, which
has a point value of one. The list should save the face of the card, the
suit, and the point value in separate elements.

\end{tcolorbox}

You can create your card like this. In the following example, the first
element of the list is a character vector (of length 1). The second
element is also a character vector, and the third element is a numeric
vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{card }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{card}
\DocumentationTok{\#\# [[1]]}
\DocumentationTok{\#\# [1] "ace"}
\DocumentationTok{\#\#}
\DocumentationTok{\#\# [[2]]}
\DocumentationTok{\#\# [1] "hearts"}
\DocumentationTok{\#\#}
\DocumentationTok{\#\# [[3]]}
\DocumentationTok{\#\# [1] 1}
\end{Highlighting}
\end{Shaded}

You can also use a list to store a whole deck of playing cards. Since
you can save a single playing card as a list, you can save a deck of
playing cards as a list of 52 sublists (one for each card). But let's
not bother---there's a much cleaner way to do the same thing. You can
use a special class of list, known as a \emph{data frame}.

\section{Data Frames}\label{data-frames}

Data frames are the two-dimensional version of a list. They are far and
away the most useful storage structure for data analysis, and they
provide an ideal way to store an entire deck of cards. You can think of
a data frame as R's equivalent to the Excel spreadsheet because it
stores data in a similar format.

Data frames group vectors together into a two-dimensional table. Each
vector becomes a column in the table. As a result, each column of a data
frame can contain a different type of data; but within a column, every
cell must be the same type of data, as in Figure~\ref{fig-data-frame}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0302.png}}

}

\caption{\label{fig-data-frame}Data frames store data as a sequence of
columns. Each column can be a different data type. Every column in a
data frame must be the same length.}

\end{figure}%

Creating a data frame by hand takes a lot of typing, but you can do it
(if you like) with the \texttt{data.frame} function. Give
\texttt{data.frame} any number of vectors, each separated with a comma.
Each vector should be set equal to a name that describes the vector.
\texttt{data.frame} will turn each vector into a column of the new data
frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{face =} \FunctionTok{c}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"six"}\NormalTok{),  }
  \AttributeTok{suit =} \FunctionTok{c}\NormalTok{(}\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{), }\AttributeTok{value =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\NormalTok{df}
\DocumentationTok{\#\# face  suit value}
\DocumentationTok{\#\#  ace clubs     1}
\DocumentationTok{\#\#  two clubs     2}
\DocumentationTok{\#\#  six clubs     3}
\end{Highlighting}
\end{Shaded}

You'll need to make sure that each vector is the same length (or can be
made so with R's recycling rules; see Figure~\ref{fig-recycle}, as data
frames cannot combine columns of different lengths.

In the previous code, I named the arguments in \texttt{data.frame}
\texttt{face}, \texttt{suit}, and \texttt{value}, but you can name the
arguments whatever you like. \texttt{data.frame} will use your argument
names to label the columns of the data frame.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Names}, toprule=.15mm]

You can also give names to a list or vector when you create one of these
objects. Use the same syntax as with \texttt{data.frame}:

\texttt{list(face\ =\ "ace",\ suit\ =\ "hearts",\ value\ =\ 1)}\strut \\
\texttt{c(face\ =\ "ace",\ suit\ =\ "hearts",\ value\ =\ "one")}

The names will be stored in the object's \texttt{names} attribute.

\end{tcolorbox}

If you look at the type of a data frame, you will see that it is a list.
In fact, each data frame is a list with class \texttt{data.frame}. You
can see what types of objects are grouped together by a list (or data
frame) with the \texttt{str} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(df)}
\DocumentationTok{\#\# "list"}

\FunctionTok{class}\NormalTok{(df)}
\DocumentationTok{\#\# "data.frame"}

\FunctionTok{str}\NormalTok{(df)}
\DocumentationTok{\#\# \textquotesingle{}data.frame\textquotesingle{}:    3 obs. of  3 variables:}
\DocumentationTok{\#\#  $ face : Factor w/ 3 levels "ace","six","two": 1 3 2}
\DocumentationTok{\#\#  $ suit : Factor w/ 1 level "clubs": 1 1 1}
\DocumentationTok{\#\#  $ value: num  1 2 3}
\end{Highlighting}
\end{Shaded}

Notice that R saved your character strings as factors. I told you that R
likes factors! It is not a very big deal here, but you can prevent this
behavior by adding the argument \texttt{stringsAsFactors\ =\ FALSE} to
\texttt{data.frame}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{face =} \FunctionTok{c}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"six"}\NormalTok{),  }
  \AttributeTok{suit =} \FunctionTok{c}\NormalTok{(}\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{), }\AttributeTok{value =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{),}
  \AttributeTok{stringsAsFactors =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A data frame is a great way to build an entire deck of cards. You can
make each row in the data frame a playing card, and each column a type
of value---each with its own appropriate data type. The data frame would
look something like this:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\#   face     suit value}
\DocumentationTok{\#\#   king   spades    13}
\DocumentationTok{\#\#  queen   spades    12}
\DocumentationTok{\#\#   jack   spades    11}
\DocumentationTok{\#\#    ten   spades    10}
\DocumentationTok{\#\#   nine   spades     9}
\DocumentationTok{\#\#  eight   spades     8}
\DocumentationTok{\#\#  seven   spades     7}
\DocumentationTok{\#\#    six   spades     6}
\DocumentationTok{\#\#   five   spades     5}
\DocumentationTok{\#\#   four   spades     4}
\DocumentationTok{\#\#  three   spades     3}
\DocumentationTok{\#\#    two   spades     2}
\DocumentationTok{\#\#    ace   spades     1}
\DocumentationTok{\#\#   king    clubs    13}
\DocumentationTok{\#\#  queen    clubs    12}
\DocumentationTok{\#\#   jack    clubs    11}
\DocumentationTok{\#\#    ten    clubs    10}
\DocumentationTok{\#\#   ... and so on.}
\end{Highlighting}
\end{Shaded}

You could create this data frame with \texttt{data.frame}, but look at
the typing involved! You need to write three vectors, each with 52
elements:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{face =} \FunctionTok{c}\NormalTok{(}\StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{,}
    \StringTok{"five"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{, }\StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }
    \StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{, }\StringTok{"five"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{, }
    \StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{, }\StringTok{"five"}\NormalTok{, }
    \StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{, }\StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }
    \StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{, }\StringTok{"five"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{),  }
  \AttributeTok{suit =} \FunctionTok{c}\NormalTok{(}\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }
    \StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }
    \StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }
    \StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }
    \StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }
    \StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }
    \StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }
    \StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{), }
  \AttributeTok{value =} \FunctionTok{c}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }
    \DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }
    \DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You should avoid typing large data sets in by hand whenever possible.
Typing invites typos and errors, not to mention RSI. It is always better
to acquire large data sets as a computer file. You can then ask R to
read the file and store the contents as an object.

I've created a file for you to load that contains a data frame of
playing-card information, so don't worry about typing in the code.
Instead, turn your attention toward loading data into R.

\section{Loading Data}\label{sec-loading-data}

You can load the \texttt{deck} data frame from the file
\href{http://bit.ly/deck_CSV}{\emph{deck.csv}}. Please take a moment to
download the file before reading on. Visit the website, click ``Download
Zip,'' and then unzip and open the folder that your web browser
downloads. \emph{deck.csv} will be inside.

\emph{deck.csv} is a comma-separated values file, or CSV for short. CSVs
are plain-text files, which means you can open them in a text editor (as
well as many other programs). If you open \emph{desk.csv}, you'll notice
that it contains a table of data that looks like the following table.
Each row of the table is saved on its own line, and a comma is used to
separate the cells within each row. Every CSV file shares this basic
format:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{"face","suit,"value"}
\NormalTok{"king","spades",13}
\NormalTok{"queen","spades,12}
\NormalTok{"jack","spades,11}
\NormalTok{"ten","spades,10}
\NormalTok{"nine","spades,9}
\NormalTok{... and so on.}
\end{Highlighting}
\end{Shaded}

Most data-science applications can open plain-text files and export data
as plain-text files. This makes plain-text files a sort of lingua franca
for data science.

To load a plain-text file into R, click the Import Dataset icon in
RStudio, shown in Figure~\ref{fig-import}. Then select ``From text
file.''

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0303.png}}

}

\caption{\label{fig-import}You can import data from plain-text files
with RStudio's Import Dataset.}

\end{figure}%

RStudio will ask you to select the file you want to import, then it will
open a wizard to help you import the data, as in
Figure~\ref{fig-wizard}. Use the wizard to tell RStudio what name to
give the data set. You can also use the wizard to tell RStudio which
character the data set uses as a separator, which character it uses to
represent decimals (usually a period in the United States and a comma in
Europe), and whether or not the data set comes with a row of column
names (known as a \emph{header}). To help you out, the wizard shows you
what the raw file looks like, as well as what your loaded data will look
like based on the input settings.

You can also unclick the box ``Strings as factors'' in the wizard. I
recommend doing this. If you do, R will load all of your character
strings as character strings. If you do not, R will convert them to
factors.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0304.png}}

}

\caption{\label{fig-wizard}RStudio's import wizard.}

\end{figure}%

Once everything looks right, click Import. RStudio will read in the data
and save it to a data frame. RStudio will also open a data viewer, so
you can see your new data in a spreadsheet format. This is a good way to
check that everything came through as expected. If all worked well, your
file should appear in a View tab of RStudio, like in
Figure~\ref{fig-view}. You can examine the data frame in the console
with \texttt{head(deck)}.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Online data}, toprule=.15mm]

You can load a plain-text file straight from the Internet by clicking
the ``From Web URL\ldots{}'' option under Import Dataset. The file will
need to have its own URL, and you will need to be connected.

\end{tcolorbox}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0305.png}}

}

\caption{\label{fig-view}When you import a data set, RStudio will save
the data to a data frame and then display the data frame in a View tab.
You can open any data frame in a View tab at any time with the View
function.}

\end{figure}%

Now it is your turn. Download \emph{deck.csv} and import it into
RStudio. Be sure to save the output to an R object called \texttt{deck}:
you'll use it in the next few chapters. If everything goes correctly,
the first few lines of your data frame should look like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(deck)}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  king spades    13}
\DocumentationTok{\#\# queen spades    12}
\DocumentationTok{\#\#  jack spades    11}
\DocumentationTok{\#\#   ten spades    10}
\DocumentationTok{\#\#  nine spades     9}
\DocumentationTok{\#\# eight spades     8}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

\texttt{head} and \texttt{tail} are two functions that provide an easy
way to peek at large data sets. \texttt{head} will return just the first
six rows of the data set, and \texttt{tail} will return just the last
six rows. To see a different number of rows, give \texttt{head} or
\texttt{tails} a second argument, the number of rows you would like to
view, for example, \texttt{head(deck,\ 10)}.

\end{tcolorbox}

R can open many types of files---not just CSVs. Visit
\hyperref[sec-appendix-dataio]{Loading and Saving Data in R} to learn
how to open other common types of files in R.

\section{Saving Data}\label{saving-data}

Before we go any further, let's save a copy of \texttt{deck} as a new
\emph{.csv} file. That way you can email it to a colleague, store it on
a thumb drive, or open it in a different program. You can save any data
frame in R to a \emph{.csv} file with the command \texttt{write.csv}. To
save \texttt{deck}, run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write.csv}\NormalTok{(deck, }\AttributeTok{file =} \StringTok{"cards.csv"}\NormalTok{, }\AttributeTok{row.names =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

R will turn your data frame into a plain-text file with the
comma-separated values format and save the file to your working
directory. To see where your working directory is, run \texttt{getwd()}.
To change the location of your working directory, visit Session
\textgreater{} Set Working Directory \textgreater{} Choose Directory in
the RStudio menu bar.

You can customize the save process with \texttt{write.csv}'s large set
of optional arguments (see \texttt{?write.csv} for details). However,
there are three arguments that you should use \emph{every} time you run
\texttt{write.csv}.

First, you should give \texttt{write.csv} the name of the data frame
that you wish to save. Next, you should provide a file name to give your
file. R will take this name quite literally, so be sure to provide an
extension.

Finally, you should add the argument \texttt{row.names\ =\ FALSE}. This
will prevent R from adding a column of numbers at the start of your data
frame. These numbers will identify your rows from 1 to 52, but it is
unlikely that whatever program you open \emph{cards.csv} in will
understand the row name system. More than likely, the program will
assume that the row names are the first column of data in your data
frame. In fact, this is exactly what R will assume if you reopen
\emph{cards.csv}. If you save and open \emph{cards.csv} several times in
R, you'll notice duplicate columns of row numbers forming at the start
of your data frame. I can't explain why R does this, but I can explain
how to avoid it: use \texttt{row.names\ =\ FALSE} whenever you save data
with \texttt{write.csv}.

For more details about saving files, including how to compress saved
files and how to save files in other formats, see
\hyperref[sec-appendix-dataio]{Loading and Saving Data in R}.

Good work. You now have a virtual deck of cards to work with. Take a
breather, and when you come back, we'll start writing some functions to
use on your deck.

\section{Summary}\label{summary-2}

You can save data in R with five different objects, which let you store
different types of values in different types of relationships, as in
Figure~\ref{fig-structures}. Of these objects, data frames are by far
the most useful for data science. Data frames store one of the most
common forms of data used in data science, tabular data.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0306.png}}

}

\caption{\label{fig-structures}R's most common data structures are
vectors, matrices, arrays, lists, and data frames.}

\end{figure}%

You can load tabular data into a data frame with RStudio's Import
Dataset button---so long as the data is saved as a plain-text file. This
requirement is not as limiting as it sounds. Most software programs can
export data as a plain-text file. So if you have an Excel file (for
example) you can open the file in Excel and export the data as a CSV to
use with R. In fact, opening a file in its original program is good
practice. Excel files use metadata, like sheets and formulas, that help
Excel work with the file. R can try to extract raw data from the file,
but it won't be as good at doing this as Microsoft Excel is. No program
is better at converting Excel files than Excel. Similarly, no program is
better at converting SAS Xport files than SAS, and so on.

However, you may find yourself with a program-specific file, but not the
program that created it. You wouldn't want to buy a
multi-thousand-dollar SAS license just to open a SAS file. Thankfully R
\emph{can} open many types of files, including files from other programs
and databases. R even has its own program-specific formats that can help
you save memory and time if you know that you will be working entirely
in R. If you'd like to know more about all of your options for loading
and saving data in R, see \hyperref[sec-appendix-dataio]{Loading and
Saving Data in R}.

\hyperref[sec-r-notation]{R Notation} will build upon the skills you
learned in this chapter. Here, you learned how to store data in R. In
\hyperref[sec-r-notation]{R Notation}, you will learn how to access
values once they've been stored. You'll also write two functions that
will let you start using your deck, a shuffle function and a deal
function.

\chapter{R Notation}\label{sec-r-notation}

Now that you have a deck of cards, you need a way to do card-like things
with it. First, you'll want to reshuffle the deck from time to time. And
next, you'll want to deal cards from the deck (one card at a time,
whatever card is on top---we're not cheaters).

To do these things, you'll need to work with the individual values
inside your data frame, a task essential to data science. For example,
to deal a card from the top of your deck, you'll need to write a
function that selects the first row of values in your data frame, like
this

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{deal}\NormalTok{(deck)}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  king spades    13}
\end{Highlighting}
\end{Shaded}

You can select values within an R object with R's notation system.

\section{Selecting Values}\label{selecting-values}

R has a notation system that lets you extract values from R objects. To
extract a value or set of values from a data frame, write the data
frame's name followed by a pair of hard brackets:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[ , ]}
\end{Highlighting}
\end{Shaded}

Between the brackets will go two indexes separated by a comma. The
indexes tell R which values to return. R will use the first index to
subset the rows of the data frame and the second index to subset the
columns.

You have a choice when it comes to writing indexes. There are six
different ways to write an index for R, and each does something slightly
different. They are all very simple and quite handy, so let's take a
look at each of them. You can create indexes with:

\begin{itemize}
\tightlist
\item
  Positive integers
\item
  Negative integers
\item
  Zero
\item
  Blank spaces
\item
  Logical values
\item
  Names
\end{itemize}

The simplest of these to use is positive integers.

\subsection{Positive Integers}\label{positive-integers}

R treats positive integers just like \emph{ij} notation in linear
algebra: as illustrated in Figure~\ref{fig-positive},
\texttt{deck{[}i,j{]}} will return the value of \texttt{deck} that is in
the \emph{ith} row and the \emph{jth} column. Notice that \emph{i} and
\emph{j} only need to be integers in the mathematical sense. They can be
saved as numerics in R

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(deck)}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  king spades    13}
\DocumentationTok{\#\# queen spades    12}
\DocumentationTok{\#\#  jack spades    11}
\DocumentationTok{\#\#   ten spades    10}
\DocumentationTok{\#\#  nine spades     9}
\DocumentationTok{\#\# eight spades     8}

\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\# "king"}
\end{Highlighting}
\end{Shaded}

To extract more than one value, use a vector of positive integers. For
example, you can return the first row of \texttt{deck} with
\texttt{deck{[}1,\ c(1,\ 2,\ 3){]}} or \texttt{deck{[}1,\ 1:3{]}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)]}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}
\end{Highlighting}
\end{Shaded}

R will return the values of \texttt{deck} that are in both the first row
and the first, second, and third columns. Note that R won't actually
remove these values from \texttt{deck}. R will give you a new set of
values which are copies of the original values. You can then save this
new set to an R object with R's assignment operator:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\DecValTok{1}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)]}
\NormalTok{new}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Repetition}, toprule=.15mm]

If you repeat a number in your index, R will return the corresponding
value(s) more than once in your ``subset.'' This code will return the
first row of \texttt{deck} twice:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)]}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}
\DocumentationTok{\#\# king spades    13}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0401.png}}

}

\caption{\label{fig-positive}R uses the \emph{ij} notation system of
linear algebra. The commands in this figure will return the shaded
values.}

\end{figure}%

R's notation system is not limited to data frames. You can use the same
syntax to select values in any R object, as long as you supply one index
for each dimension of the object. So, for example, you can subset a
vector (which has one dimension) with a single index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{6}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{vec[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\DocumentationTok{\#\# 6 1 3}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Indexing begins at 1}, toprule=.15mm]

In some programming languages, indexing begins with 0. This means that 0
returns the first element of a vector, 1 returns the second element, and
so on.

This isn't the case with R. Indexing in R behaves just like indexing in
linear algebra. The first element is always indexed by 1. Why is R
different? Maybe because it was written for mathematicians. Those of us
who learned indexing from a linear algebra course wonder why computers
programmers start with 0.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{\texttt{drop\ =\ FALSE}}, toprule=.15mm]

If you select two or more columns from a data frame, R will return a new
data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{]}
\DocumentationTok{\#\#  face   suit}
\DocumentationTok{\#\#  king spades}
\DocumentationTok{\#\# queen spades}
\end{Highlighting}
\end{Shaded}

However, if you select a single column, R will return a vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\#  "king"  "queen"}
\end{Highlighting}
\end{Shaded}

If you would prefer a data frame instead, you can add the optional
argument \texttt{drop\ =\ FALSE} between the brackets:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, drop }\OtherTok{=} \ConstantTok{FALSE}\NormalTok{]}
\DocumentationTok{\#\#  face}
\DocumentationTok{\#\#  king}
\DocumentationTok{\#\# queen}
\end{Highlighting}
\end{Shaded}

This method also works for selecting a single column from a matrix or an
array.

\end{tcolorbox}

\subsection{Negative Integers}\label{negative-integers}

Negative integers do the exact opposite of positive integers when
indexing. R will return every element \emph{except} the elements in a
negative index. For example, \texttt{deck{[}-1,\ 1:3{]}} will return
everything \emph{but} the first row of \texttt{deck}.
\texttt{deck{[}-(2:52),\ 1:3{]}} will return the first row (and exclude
everything else):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\SpecialCharTok{{-}}\NormalTok{(}\DecValTok{2}\SpecialCharTok{:}\DecValTok{52}\NormalTok{), }\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}
\end{Highlighting}
\end{Shaded}

Negative integers are a more efficient way to subset than positive
integers if you want to include the majority of a data frame's rows or
columns.

R will return an error if you try to pair a negative integer with a
positive integer in the \emph{same} index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\# Error in xj[i] : only 0\textquotesingle{}s may be mixed with negative subscripts}
\end{Highlighting}
\end{Shaded}

However, you can use both negative and positive integers to subset an
object if you use them in \emph{different} indexes (e.g., if you use one
in the rows index and one in the columns index, like
\texttt{deck{[}-1,\ 1{]}}).

\subsection{Zero}\label{zero}

What would happen if you used zero as an index? Zero is neither a
positive integer nor a negative integer, but R will still use it to do a
type of subsetting. R will return nothing from a dimension when you use
zero as an index. This creates an empty object:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{]}
\DocumentationTok{\#\# data frame with 0 columns and 0 rows}
\end{Highlighting}
\end{Shaded}

To be honest, indexing with zero is not very helpful.

\subsection{Blank Spaces}\label{blank-spaces}

You can use a blank space to tell R to extract \emph{every} value in a
dimension. This lets you subset an object on one dimension but not the
others, which is useful for extracting entire rows or columns from a
data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, ]}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}
\end{Highlighting}
\end{Shaded}

\subsection{Logical Values}\label{logic}

If you supply a vector of \texttt{TRUE}s and \texttt{FALSE}s as your
index, R will match each \texttt{TRUE} and \texttt{FALSE} to a row in
your data frame (or a column depending on where you place the index). R
will then return each row that corresponds to a \texttt{TRUE},
Figure~\ref{fig-logicals}.

It may help to imagine R reading through the data frame and asking,
``Should I return the \_i\_th row of the data structure?'' and then
consulting the \_i\_th value of the index for its answer. For this
system to work, your vector must be as long as the dimension you are
trying to subset:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)]}
\DocumentationTok{\#\# face   suit }
\DocumentationTok{\#\# king spades}

\NormalTok{rows }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, }
\NormalTok{  F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, }
\NormalTok{  F, F, F, F, F, F, F, F, F, F, F, F, F, F)}
\NormalTok{deck[rows, ]}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0402.png}}

}

\caption{\label{fig-logicals}You can use vectors of TRUEs and FALSEs to
tell R exactly which values you want to extract and which you do not.
The command would return just the numbers 1, 6, and 5.}

\end{figure}%

This system may seem odd---who wants to type so many \texttt{TRUE}s and
\texttt{FALSE}s?---but it will become very powerful in
\hyperref[sec-modifying-values]{Modifying Values}.

\subsection{Names}\label{names-1}

Finally, you can ask for the elements you want by name---if your object
has names (see \hyperref[sec-names]{Names}). This is a common way to
extract the columns of a data frame, since columns almost always have
names:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\StringTok{"face"}\NormalTok{, }\StringTok{"suit"}\NormalTok{, }\StringTok{"value"}\NormalTok{)]}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}

\CommentTok{\# the entire value column}
\NormalTok{deck[ , }\StringTok{"value"}\NormalTok{]}
\DocumentationTok{\#\#  13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8}
\DocumentationTok{\#\#  7  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2}
\DocumentationTok{\#\#  1 13 12 11 10  9  8  7  6  5  4  3  2  1}
\end{Highlighting}
\end{Shaded}

\section{Deal a Card}\label{deal-a-card}

Now that you know the basics of R's notation system, let's put it to
use.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Deal a Card}\vspace{3mm}

Complete the following code to make a function that returns the first
row of a data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(cards) \{}
   \CommentTok{\# ?}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

You can use any of the systems that return the first row of your data
frame to write a \texttt{deal} function. I'll use positive integers and
blanks because I think they are easy to understand:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(cards) \{}
\NormalTok{  cards[}\DecValTok{1}\NormalTok{, ]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The function does exactly what you want: it deals the top card from your
data set. However, the function becomes less impressive if you run
\texttt{deal} over and over again:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{deal}\NormalTok{(deck)}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}

\FunctionTok{deal}\NormalTok{(deck)}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}

\FunctionTok{deal}\NormalTok{(deck)}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}
\end{Highlighting}
\end{Shaded}

\texttt{deal} always returns the king of spades because \texttt{deck}
doesn't know that we've dealt the card away. Hence, the king of spades
stays where it is, at the top of the deck ready to be dealt again. This
is a difficult problem to solve, and we will \emph{deal} with it in
\hyperref[sec-environments]{Environments}. In the meantime, you can fix
the problem by shuffling your deck after every deal. Then a new card
will always be at the top.

Shuffling is a temporary compromise: the probabilities at play in your
deck will not match the probabilities that occur when you play a game
with a single deck of cards. For example, there will still be a
probability that the king of spades appears twice in a row. However,
things are not as bad as they may seem. Most casinos use five or six
decks at a time in card games to prevent card counting. The
probabilities that you would encounter in those situations are very
close to the ones we will create here.

\section{Shuffle the Deck}\label{shuffle-the-deck}

When you shuffle a real deck of cards, you randomly rearrange the order
of the cards. In your virtual deck, each card is a row in a data frame.
To shuffle the deck, you need to randomly reorder the rows in the data
frame. Can this be done? You bet! And you already know everything you
need to do it.

This may sound silly, but start by extracting every row in your data
frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck2 }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, ]}

\FunctionTok{head}\NormalTok{(deck2)}
\DocumentationTok{\#\#   face   suit value}
\DocumentationTok{\#\#   king spades    13}
\DocumentationTok{\#\#  queen spades    12}
\DocumentationTok{\#\#   jack spades    11}
\DocumentationTok{\#\#    ten spades    10}
\DocumentationTok{\#\#   nine spades     9}
\DocumentationTok{\#\#  eight spades     8}
\end{Highlighting}
\end{Shaded}

What do you get? A new data frame whose order hasn't changed at all.
What if you asked R to extract the rows in a different order? For
example, you could ask for row 2, \emph{then} row 1, and then the rest
of the cards:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck3 }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\SpecialCharTok{:}\DecValTok{52}\NormalTok{), ]}

\FunctionTok{head}\NormalTok{(deck3)}
\DocumentationTok{\#\#   face   suit value}
\DocumentationTok{\#\#  queen spades    12}
\DocumentationTok{\#\#   king spades    13}
\DocumentationTok{\#\#   jack spades    11}
\DocumentationTok{\#\#    ten spades    10}
\DocumentationTok{\#\#   nine spades     9}
\DocumentationTok{\#\#  eight spades     8}
\end{Highlighting}
\end{Shaded}

R complies. You'll get all the rows back, and they'll come in the order
you ask for them. If you want the rows to come in a random order, then
you need to sort the integers from 1 to 52 into a random order and use
the results as a row index. How could you generate such a random
collection of integers? With our friendly neighborhood \texttt{sample}
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{)}
\NormalTok{random}
\DocumentationTok{\#\#  35 28 39  9 18 29 26 45 47 48 23 22 21 16 32 38  1 15 20}
\DocumentationTok{\#\#  11  2  4 14 49 34 25  8  6 10 41 46 17 33  5  7 44  3 27}
\DocumentationTok{\#\#  50 12 51 40 52 24 19 13 42 37 43 36 31 30}

\NormalTok{deck4 }\OtherTok{\textless{}{-}}\NormalTok{ deck[random, ]}
\FunctionTok{head}\NormalTok{(deck4)}
\DocumentationTok{\#\#   face     suit value}
\DocumentationTok{\#\#   five diamonds     5}
\DocumentationTok{\#\#  queen diamonds    12}
\DocumentationTok{\#\#    ace diamonds     1}
\DocumentationTok{\#\#   five   spades     5}
\DocumentationTok{\#\#   nine    clubs     9}
\DocumentationTok{\#\#   jack diamonds    11}
\end{Highlighting}
\end{Shaded}

Now the new set is truly shuffled. You'll be finished once you wrap
these steps into a function.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Shuffle a Deck}\vspace{3mm}

Use the preceding ideas to write a \texttt{shuffle} function.
\texttt{shuffle} should take a data frame and return a shuffled copy of
the data frame.

\end{tcolorbox}

Your \texttt{shuffle} function will look like the one that follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{shuffle }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(cards) \{ }
\NormalTok{  random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{)}
\NormalTok{  cards[random, ]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Nice work! Now you can shuffle your cards between each deal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{deal}\NormalTok{(deck)}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}

\NormalTok{deck2 }\OtherTok{\textless{}{-}} \FunctionTok{shuffle}\NormalTok{(deck) }

\FunctionTok{deal}\NormalTok{(deck2)}
\DocumentationTok{\#\# face  suit value}
\DocumentationTok{\#\# jack clubs    11}
\end{Highlighting}
\end{Shaded}

\section{Dollar Signs and Double
Brackets}\label{dollar-signs-and-double-brackets}

Two types of object in R obey an optional second system of notation. You
can extract values from data frames and lists with the \texttt{\$}
syntax. You will encounter the \texttt{\$} syntax again and again as an
R programmer, so let's examine how it works.

To select a column from a data frame, write the data frame's name and
the column name separated by a \texttt{\$}. Notice that no quotes should
go around the column name:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck}\SpecialCharTok{$}\NormalTok{value}
\DocumentationTok{\#\# 13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8  7}
\DocumentationTok{\#\#  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2  1 13}
\DocumentationTok{\#\# 12 11 10  9  8  7  6  5  4  3  2  1}
\end{Highlighting}
\end{Shaded}

R will return all of the values in the column as a vector. This
\texttt{\$} notation is incredibly useful because you will often store
the variables of your data sets as columns in a data frame. From time to
time, you'll want to run a function like \texttt{mean} or
\texttt{median} on the values in a variable. In R, these functions
expect a vector of values as input, and \texttt{deck\$value} delivers
your data in just the right format:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(deck}\SpecialCharTok{$}\NormalTok{value)}
\DocumentationTok{\#\# 7}

\FunctionTok{median}\NormalTok{(deck}\SpecialCharTok{$}\NormalTok{value)}
\DocumentationTok{\#\# 7}
\end{Highlighting}
\end{Shaded}

You can use the same \texttt{\$} notation with the elements of a list,
if they have names. This notation has an advantage with lists, too. If
you subset a list in the usual way, R will return a \emph{new} list that
has the elements you requested. This is true even if you only request a
single element.

To see this, make a list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{numbers =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\AttributeTok{logical =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{strings =} \FunctionTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}
\NormalTok{lst}
\DocumentationTok{\#\# $numbers}
\DocumentationTok{\#\# [1] 1 2}

\DocumentationTok{\#\# $logical}
\DocumentationTok{\#\# [1] TRUE}

\DocumentationTok{\#\# $strings}
\DocumentationTok{\#\# [1] "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

And then subset it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst[}\DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\# $numbers}
\DocumentationTok{\#\# [1] 1 2}
\end{Highlighting}
\end{Shaded}

The result is a smaller \emph{list} with one element. That element is
the vector \texttt{c(1,\ 2)}. This can be annoying because many R
functions do not work with lists. For example, \texttt{sum(lst{[}1{]})}
will return an error. It would be horrible if once you stored a vector
in a list, you could only ever get it back as a list:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(lst[}\DecValTok{1}\NormalTok{])}
\DocumentationTok{\#\# Error in sum(lst[1]) : invalid \textquotesingle{}type\textquotesingle{} (list) of argument}
\end{Highlighting}
\end{Shaded}

When you use the \texttt{\$} notation, R will return the selected values
as they are, with no list structure around them:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst}\SpecialCharTok{$}\NormalTok{numbers}
\DocumentationTok{\#\# 1 2}
\end{Highlighting}
\end{Shaded}

You can then immediately feed the results to a function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(lst}\SpecialCharTok{$}\NormalTok{numbers)}
\DocumentationTok{\#\# 3}
\end{Highlighting}
\end{Shaded}

If the elements in your list do not have names (or you do not wish to
use the names), you can use two brackets, instead of one, to subset the
list. This notation will do the same thing as the \texttt{\$} notation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst[[}\DecValTok{1}\NormalTok{]]}
\DocumentationTok{\#\# 1 2}
\end{Highlighting}
\end{Shaded}

In other words, if you subset a list with single-bracket notation, R
will return a smaller list. If you subset a list with double-bracket
notation, R will return just the values that were inside an element of
the list. You can combine this feature with any of R's indexing methods:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst[}\StringTok{"numbers"}\NormalTok{]}
\DocumentationTok{\#\# $numbers}
\DocumentationTok{\#\# [1] 1 2}

\NormalTok{lst[[}\StringTok{"numbers"}\NormalTok{]]}
\DocumentationTok{\#\# 1 2}
\end{Highlighting}
\end{Shaded}

This difference is subtle but important. In the R community, there is a
popular, and helpful, way to think about it, Figure~\ref{fig-trains}.
Imagine that each list is a train and each element is a train car. When
you use single brackets, R selects individual train cars and returns
them as a new train. Each car keeps its contents, but those contents are
still inside a train car (i.e., a list). When you use double brackets, R
actually unloads the car and gives you back the contents.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0403.png}}

}

\caption{\label{fig-trains}It can be helpful to think of your list as a
train. Use single brackets to select train cars, double brackets to
select the contents inside of a car.}

\end{figure}%

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-important-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-important-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Never attach}, toprule=.15mm]

In R's early days, it became popular to use \texttt{attach()} on a data
set once you had it loaded. Don't do this! \texttt{attach} recreates a
computing environment similar to those used in other statistics
applications like Stata and SPSS, which crossover users liked. However,
R is not Stata or SPSS. R is optimized to use the R computing
environment, and running \texttt{attach()} can cause confusion with some
R functions.

What does \texttt{attach()} do? On the surface, \texttt{attach} saves
you typing. If you attach the \texttt{deck} data set, you can refer to
each of its variables by name; instead of typing \texttt{deck\$face},
you can just type \texttt{face}. But typing isn't bad. It gives you a
chance to be explicit, and in computer programming, explicit is good.
Attaching a data set creates the possibility that R will confuse two
variable names. If this occurs within a function, you're likely to get
unusable results and an unhelpful error message to explain what
happened.

\end{tcolorbox}

Now that you are an expert at retrieving values stored in R, let's
summarize what you've accomplished.

\section{Summary}\label{summary-3}

You have learned how to access values that have been stored in R. You
can retrieve a copy of values that live inside a data frame and use the
copies for new computations.

In fact, you can use R's notation system to access values in any R
object. To use it, write the name of an object followed by brackets and
indexes. If your object is one-dimensional, like a vector, you only need
to supply one index. If it is two-dimensional, like a data frame, you
need to supply two indexes separated by a comma. And, if it is
\emph{n}-dimensional, you need to supply \emph{n} indexes, each
separated by a comma.

In \hyperref[sec-modifying-values]{Modifying Values}, you'll take this
system a step further and learn how to change the actual values that are
stored inside your data frame. This is all adding up to something
special: complete control of your data. You can now store your data in
your computer, retrieve individual values at will, and use your computer
to perform correct calculations with those values.

Does this sound basic? It may be, but it is also powerful and essential
for efficient data science. You no longer need to memorize everything in
your head, nor worry about doing mental arithmetic wrong. This low-level
control over your data is also a prerequisite for more efficient R
programs, the subject of \hyperref[sec-project-slots]{Project 3: Slot
Machine}.

\chapter{Modifying Values}\label{sec-modifying-values}

Are you ready to play some games with your virtual deck? Not so fast!
The point system in your deck of cards doesn't align well with many card
games. For example, in war and poker, aces are usually scored higher
than kings. They'd have a point value of 14, not 1.

In this task, you will change the point system of your deck three times
to match three different games: war, hearts, and blackjack. Each of
these games will teach you something different about modifying the
values inside of a data set. Start by making a copy of \texttt{deck}
that you can manipulate. This will ensure that you always have a
pristine copy of \texttt{deck} to fall back on (should things go awry):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck2 }\OtherTok{\textless{}{-}}\NormalTok{ deck}
\end{Highlighting}
\end{Shaded}

\section{Changing Values in Place}\label{changing-values-in-place}

You can use R's notation system to modify values within an R object.
First, describe the value (or values) you wish to modify. Then use the
assignment operator \texttt{\textless{}-} to overwrite those values. R
will update the selected values \emph{in the original object}. Let's put
this into action with a real example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\NormalTok{vec}
\DocumentationTok{\#\#  0 0 0 0 0 0}
\end{Highlighting}
\end{Shaded}

Here's how you can select the first value of \texttt{vec}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec[}\DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\#  0}
\end{Highlighting}
\end{Shaded}

And here is how you can modify it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{1000}
\NormalTok{vec}
\DocumentationTok{\#\# 1000    0    0    0    0    0}
\end{Highlighting}
\end{Shaded}

You can replace multiple values at once as long as the number of new
values equals the number of selected values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec[}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{)] }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{vec}
\DocumentationTok{\#\#  1 0 1 0 1 0}

\NormalTok{vec[}\DecValTok{4}\SpecialCharTok{:}\DecValTok{6}\NormalTok{] }\OtherTok{\textless{}{-}}\NormalTok{ vec[}\DecValTok{4}\SpecialCharTok{:}\DecValTok{6}\NormalTok{] }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{vec}
\DocumentationTok{\#\# 1 0 1 1 2 1}
\end{Highlighting}
\end{Shaded}

You can also create values that do not yet exist in your object. R will
expand the object to accommodate the new values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec[}\DecValTok{7}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{vec}
\DocumentationTok{\#\# 1 0 1 1 2 1 0}
\end{Highlighting}
\end{Shaded}

This provides a great way to add new variables to your data set:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck2}\SpecialCharTok{$}\NormalTok{new }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{52}

\FunctionTok{head}\NormalTok{(deck2)}
\DocumentationTok{\#\#   face   suit value new}
\DocumentationTok{\#\#   king spades    13   1}
\DocumentationTok{\#\#  queen spades    12   2}
\DocumentationTok{\#\#   jack spades    11   3}
\DocumentationTok{\#\#    ten spades    10   4}
\DocumentationTok{\#\#   nine spades     9   5}
\DocumentationTok{\#\#  eight spades     8   6}
\end{Highlighting}
\end{Shaded}

You can also remove columns from a data frame (and elements from a list)
by assigning them the symbol \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck2}\SpecialCharTok{$}\NormalTok{new }\OtherTok{\textless{}{-}} \ConstantTok{NULL}

\FunctionTok{head}\NormalTok{(deck2)}
\DocumentationTok{\#\#   face   suit value}
\DocumentationTok{\#\#   king spades    13}
\DocumentationTok{\#\#  queen spades    12}
\DocumentationTok{\#\#   jack spades    11}
\DocumentationTok{\#\#    ten spades    10}
\DocumentationTok{\#\#   nine spades     9}
\DocumentationTok{\#\#  eight spades     8}
\end{Highlighting}
\end{Shaded}

In the game of war, aces are king (figuratively speaking). They receive
the highest value of all the cards, which would be something like 14.
Every other card gets the value that it already has in \texttt{deck}. To
play war, you just need to change the values of your aces from 1 to 14.

As long as you haven't shuffled your deck, you know just where the aces
are. They appear every 13 cards. Hence, you can describe them with R's
notation system:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck2[}\FunctionTok{c}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{39}\NormalTok{, }\DecValTok{52}\NormalTok{), ]}
\DocumentationTok{\#\#  face     suit value}
\DocumentationTok{\#\#   ace   spades     1}
\DocumentationTok{\#\#   ace    clubs     1}
\DocumentationTok{\#\#   ace diamonds     1}
\DocumentationTok{\#\#   ace   hearts     1}
\end{Highlighting}
\end{Shaded}

You can single out just the \emph{values} of the aces by subsetting the
columns dimension of \texttt{deck2}. Or, even better, you can subset the
column vector \texttt{deck2\$value}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck2[}\FunctionTok{c}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{39}\NormalTok{, }\DecValTok{52}\NormalTok{), }\DecValTok{3}\NormalTok{]}
\DocumentationTok{\#\# 1 1 1 1}

\NormalTok{deck2}\SpecialCharTok{$}\NormalTok{value[}\FunctionTok{c}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{39}\NormalTok{, }\DecValTok{52}\NormalTok{)]}
\DocumentationTok{\#\# 1 1 1 1}
\end{Highlighting}
\end{Shaded}

Now all you have to do is assign a new set of values to these old
values. The set of new values will have to be the same size as the set
of values that you are replacing. So you could save
\texttt{c(14,\ 14,\ 14,\ 14)} into the ace values, or you could just
save \emph{\texttt{14}} and rely on R's recycling rules to expand
\texttt{14} to \texttt{c(14,\ 14,\ 14,\ 14)}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck2}\SpecialCharTok{$}\NormalTok{value[}\FunctionTok{c}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{39}\NormalTok{, }\DecValTok{52}\NormalTok{)] }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{14}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{14}\NormalTok{)}

\CommentTok{\# or}

\NormalTok{deck2}\SpecialCharTok{$}\NormalTok{value[}\FunctionTok{c}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{39}\NormalTok{, }\DecValTok{52}\NormalTok{)] }\OtherTok{\textless{}{-}} \DecValTok{14}
\end{Highlighting}
\end{Shaded}

Notice that the values change \emph{in place}. You don't end up with a
modified \emph{copy} of \texttt{deck2}; the new values will appear
inside \texttt{deck2}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(deck2, }\DecValTok{13}\NormalTok{)}
\DocumentationTok{\#\#   face   suit value}
\DocumentationTok{\#\#   king spades    13}
\DocumentationTok{\#\#  queen spades    12}
\DocumentationTok{\#\#   jack spades    11}
\DocumentationTok{\#\#    ten spades    10}
\DocumentationTok{\#\#   nine spades     9}
\DocumentationTok{\#\#  eight spades     8}
\DocumentationTok{\#\#  seven spades     7}
\DocumentationTok{\#\#    six spades     6}
\DocumentationTok{\#\#   five spades     5}
\DocumentationTok{\#\#   four spades     4}
\DocumentationTok{\#\#  three spades     3}
\DocumentationTok{\#\#    two spades     2}
\DocumentationTok{\#\#    ace spades    14}
\end{Highlighting}
\end{Shaded}

The same technique will work whether you store your data in a vector,
matrix, array, list, or data frame. Just describe the values that you
want to change with R's notation system, then assign over those values
with R's assignment operator.

Things worked very easily in this example because you knew exactly where
each ace was. The cards were sorted in an orderly manner and an ace
appeared every 13 rows.

But what if the deck had been shuffled? You could look through all the
cards and note the locations of the aces, but that would be tedious. If
your data frame were larger, it might be impossible:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck3 }\OtherTok{\textless{}{-}} \FunctionTok{shuffle}\NormalTok{(deck)}
\end{Highlighting}
\end{Shaded}

Where are the aces now?

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(deck3)}
\DocumentationTok{\#\#  face     suit value}
\DocumentationTok{\#\# queen    clubs    12}
\DocumentationTok{\#\#  king    clubs    13}
\DocumentationTok{\#\#   ace   spades     1   \# an ace}
\DocumentationTok{\#\#  nine    clubs     9}
\DocumentationTok{\#\# seven   spades     7}
\DocumentationTok{\#\# queen diamonds    12}
\end{Highlighting}
\end{Shaded}

Why not ask R to find the aces for you? You can do this with logical
subsetting. Logical subsetting provides a way to do targeted extraction
and modification with R objects, a sort of search-and-destroy mission
inside your own data sets.

\section{Logical Subsetting}\label{logical-subsetting}

Do you remember R's logical index system,
\hyperref[sec-logicals]{logicals}? To recap, you can select values with
a vector of \texttt{TRUE}s and \texttt{FALSE}s. The vector must be the
same length as the dimension that you wish to subset. R will return
every element that matches a TRUE:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec}
\DocumentationTok{\#\# 1 0 1 1 2 1 0}

\NormalTok{vec[}\FunctionTok{c}\NormalTok{(}\ConstantTok{FALSE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)]}
\DocumentationTok{\#\# 2}
\end{Highlighting}
\end{Shaded}

At first glance, this system might seem impractical. Who wants to type
out long vectors of TRUEs and FALSEs? No one. But you don't have to. You
can let a logical test create a vector of TRUEs and FALSEs for you.

\subsection{Logical Tests}\label{logical-tests}

A logical test is a comparison like ``is one less than two?'',
\texttt{1\ \textless{}\ 2}, or ``is three greater than four?'',
\texttt{3\ \textgreater{}\ 4}. R provides seven logical operators that
you can use to make comparisons, shown in Table~\ref{tbl-logop}.

\begin{longtable}[]{@{}lll@{}}
\caption{R's Logical Operators}\label{tbl-logop}\tabularnewline
\toprule\noalign{}
Operator & Syntax & Tests \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Operator & Syntax & Tests \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\textgreater{}} & \texttt{a\ \textgreater{}\ b} & Is a greater
than b? \\
\texttt{\textgreater{}=} & \texttt{a\ \textgreater{}=\ b} & Is a greater
than or equal to b? \\
\texttt{\textless{}} & \texttt{a\ \textless{}\ b} & Is a less than b? \\
\texttt{\textless{}=} & \texttt{a\ \textless{}=\ b} & Is a less than or
equal to b? \\
\texttt{==} & \texttt{a\ ==\ b} & Is a equal to b? \\
\texttt{!=} & \texttt{a\ !=\ b} & Is a not equal to b? \\
\texttt{\%in\%} & \texttt{a\ \%in\%\ c(a,\ b,\ c)} & Is a in the group
c(a, b, c)? \\
\end{longtable}

Each operator returns a \texttt{TRUE} or a \texttt{FALSE}. If you use an
operator to compare vectors, R will do element-wise comparisons---just
like it does with the arithmetic operators:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{\textgreater{}} \DecValTok{2}
\DocumentationTok{\#\# FALSE}

\DecValTok{1} \SpecialCharTok{\textgreater{}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\DocumentationTok{\#\# TRUE FALSE FALSE}

\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{) }\SpecialCharTok{==} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# FALSE  TRUE FALSE}
\end{Highlighting}
\end{Shaded}

\texttt{\%in\%} is the only operator that does not do normal
element-wise execution. \texttt{\%in\%} tests whether the value(s) on
the left side are in the vector on the right side. If you provide a
vector on the left side, \texttt{\%in\%} will \emph{not} pair up the
values on the left with the values on the right and then do element-wise
tests. Instead, \texttt{\%in\%} will independently test whether each
value on the left is \emph{somewhere} in the vector on the right:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\DocumentationTok{\#\# FALSE}

\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{) }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\DocumentationTok{\#\# FALSE FALSE}

\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{) }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\DocumentationTok{\#\# FALSE FALSE  TRUE}

\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{) }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\DocumentationTok{\#\# FALSE FALSE  TRUE  TRUE}
\end{Highlighting}
\end{Shaded}

Notice that you test for equality with a double equals sign,
\texttt{==}, and not a single equals sign, \texttt{=}, which is another
way to write \texttt{\textless{}-}. It is easy to forget and use
\texttt{a\ =\ b} to test if \texttt{a} equals \texttt{b}. Unfortunately,
you'll be in for a nasty surprise. R won't return a \texttt{TRUE} or
\texttt{FALSE}, because it won't have to: \texttt{a} \emph{will} equal
\texttt{b}, because you just ran the equivalent of
\texttt{a\ \textless{}-\ b}.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-warning-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{\texttt{=} is an assignment operator}, toprule=.15mm]

Be careful not to confuse \texttt{=} with \texttt{==}. \texttt{=} does
the same thing as \texttt{\textless{}-}: it assigns a value to an
object.

\end{tcolorbox}

You can compare any two R objects with a logical operator; however,
logical operators make the most sense if you compare two objects of the
same data type. If you compare objects of different data types, R will
use its coercion rules to coerce the objects to the same type before it
makes the comparison.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: How many Aces?}\vspace{3mm}

Extract the \texttt{face} column of \texttt{deck2} and test whether each
value is equal to \texttt{ace}. As a challenge, use R to quickly count
how many cards are equal to \texttt{ace}.

\end{tcolorbox}

You can extract the \texttt{face} column with R's \texttt{\$} notation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck2}\SpecialCharTok{$}\NormalTok{face}
\DocumentationTok{\#\#  "king"  "queen" "jack"  "ten"   "nine" }
\DocumentationTok{\#\#  "eight" "seven" "six"   "five"  "four" }
\DocumentationTok{\#\#  "three" "two"   "ace"   "king"  "queen"}
\DocumentationTok{\#\#  "jack"  "ten"   "nine"  "eight" "seven"}
\DocumentationTok{\#\#  "six"   "five"  "four"  "three" "two"  }
\DocumentationTok{\#\#  "ace"   "king"  "queen" "jack"  "ten"  }
\DocumentationTok{\#\#  "nine"  "eight" "seven" "six"   "five" }
\DocumentationTok{\#\#  "four"  "three" "two"   "ace"   "king" }
\DocumentationTok{\#\#  "queen" "jack"  "ten"   "nine"  "eight"}
\DocumentationTok{\#\#  "seven" "six"   "five"  "four"  "three"}
\DocumentationTok{\#\#  "two"   "ace"}
\end{Highlighting}
\end{Shaded}

Next, you can use the \texttt{==} operator to test whether each value is
equal to \texttt{ace}. In the following code, R will use its recycling
rules to indivuidually compare every value of \texttt{deck2\$face} to
\texttt{"ace"}. Notice that the quotation marks are important. If you
leave them out, R will try to find an object named \texttt{ace} to
compare against \texttt{deck2\$face}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck2}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{==} \StringTok{"ace"}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE  TRUE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE  TRUE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE  TRUE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

You can use \texttt{sum} to quickly count the number of \texttt{TRUE}s
in the previous vector. Remember that R will coerce logicals to numerics
when you do math with them. R will turn \texttt{TRUE}s into ones and
\texttt{FALSE}s into zeroes. As a result, sum will count the number of
\texttt{TRUE}s:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(deck2}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{==} \StringTok{"ace"}\NormalTok{)}
\DocumentationTok{\#\# 4}
\end{Highlighting}
\end{Shaded}

You can use this method to spot and then change the aces in your
deck---even if you've shuffled your cards. First, build a logical test
that identifies the aces in your shuffled deck:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck3}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{==} \StringTok{"ace"}
\end{Highlighting}
\end{Shaded}

Then use the test to single out the ace point values. Since the test
returns a logical vector, you can use it as an index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck3}\SpecialCharTok{$}\NormalTok{value[deck3}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{==} \StringTok{"ace"}\NormalTok{]}
\DocumentationTok{\#\#  1 1 1 1}
\end{Highlighting}
\end{Shaded}

Finally, use assignment to change the ace values in \texttt{deck3}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck3}\SpecialCharTok{$}\NormalTok{value[deck3}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{==} \StringTok{"ace"}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{14}

\FunctionTok{head}\NormalTok{(deck3)}
\DocumentationTok{\#\#  face     suit value}
\DocumentationTok{\#\# queen    clubs    12}
\DocumentationTok{\#\#  king    clubs    13}
\DocumentationTok{\#\#   ace   spades    14  \# an ace}
\DocumentationTok{\#\#  nine    clubs     9}
\DocumentationTok{\#\# seven   spades     7}
\DocumentationTok{\#\# queen diamonds    12}
\end{Highlighting}
\end{Shaded}

To summarize, you can use a logical test to select values within an
object.

Logical subsetting is a powerful technique because it lets you quickly
identify, extract, and modify individual values in your data set. When
you work with logical subsetting, you do not need to know \emph{where}
in your data set a value exists. You only need to know how to describe
the value with a logical test.

Logical subsetting is one of the things R does best. In fact, logical
subsetting is a key component of vectorized programming, a coding style
that lets you write fast and efficient R code, which we will study in
\hyperref[sec-speed]{Speed}.

Let's put logical subsetting to use with a new game: hearts. In hearts,
every card has a value of zero:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4 }\OtherTok{\textless{}{-}}\NormalTok{ deck}
\NormalTok{deck4}\SpecialCharTok{$}\NormalTok{value }\OtherTok{\textless{}{-}} \DecValTok{0}

\FunctionTok{head}\NormalTok{(deck4, }\DecValTok{13}\NormalTok{)}
\DocumentationTok{\#\#   face   suit value}
\DocumentationTok{\#\#   king spades     0}
\DocumentationTok{\#\#  queen spades     0}
\DocumentationTok{\#\#   jack spades     0}
\DocumentationTok{\#\#    ten spades     0}
\DocumentationTok{\#\#   nine spades     0}
\DocumentationTok{\#\#  eight spades     0}
\DocumentationTok{\#\#  seven spades     0}
\DocumentationTok{\#\#    six spades     0}
\DocumentationTok{\#\#   five spades     0}
\DocumentationTok{\#\#   four spades     0}
\DocumentationTok{\#\#  three spades     0}
\DocumentationTok{\#\#    two spades     0}
\DocumentationTok{\#\#    ace spades     0}
\end{Highlighting}
\end{Shaded}

except cards in the suit of hearts and the queen of spades. Each card in
the suit of hearts has a value of 1. Can you find these cards and
replace their values? Give it a try.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Score the Deck for Hearts}\vspace{3mm}

Assign a value of \texttt{1} to every card in \texttt{deck4} that has a
suit of hearts.

\end{tcolorbox}

To do this, first write a test that identifies cards in the
\texttt{hearts} suit:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4}\SpecialCharTok{$}\NormalTok{suit }\SpecialCharTok{==} \StringTok{"hearts"}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE}
\DocumentationTok{\#\#   TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE}
\DocumentationTok{\#\#   TRUE  TRUE  TRUE}
\end{Highlighting}
\end{Shaded}

Then use your test to select the values of these cards:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4}\SpecialCharTok{$}\NormalTok{value[deck4}\SpecialCharTok{$}\NormalTok{suit }\SpecialCharTok{==} \StringTok{"hearts"}\NormalTok{]}
\DocumentationTok{\#\# 0 0 0 0 0 0 0 0 0 0 0 0 0}
\end{Highlighting}
\end{Shaded}

Finally, assign a new number to these values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4}\SpecialCharTok{$}\NormalTok{value[deck4}\SpecialCharTok{$}\NormalTok{suit }\SpecialCharTok{==} \StringTok{"hearts"}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

Now all of your \texttt{hearts} cards have been updated:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4}\SpecialCharTok{$}\NormalTok{value[deck4}\SpecialCharTok{$}\NormalTok{suit }\SpecialCharTok{==} \StringTok{"hearts"}\NormalTok{]}
\DocumentationTok{\#\# 1 1 1 1 1 1 1 1 1 1 1 1 1}
\end{Highlighting}
\end{Shaded}

In hearts, the queen of spades has the most unusual value of all: she's
worth 13 points. It should be simple to change her value, but she's
surprisingly hard to find. You could find all of the \emph{queens}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4[deck4}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{==} \StringTok{"queen"}\NormalTok{, ]}
\DocumentationTok{\#\#   face     suit value}
\DocumentationTok{\#\#  queen   spades     0}
\DocumentationTok{\#\#  queen    clubs     0}
\DocumentationTok{\#\#  queen diamonds     0}
\DocumentationTok{\#\#  queen   hearts     1}
\end{Highlighting}
\end{Shaded}

But that's three cards too many. On the other hand, you could find all
of the cards in \emph{spades}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4[deck4}\SpecialCharTok{$}\NormalTok{suit }\SpecialCharTok{==} \StringTok{"spades"}\NormalTok{, ]}
\DocumentationTok{\#\#   face   suit value}
\DocumentationTok{\#\#   king spades     0}
\DocumentationTok{\#\#  queen spades     0}
\DocumentationTok{\#\#   jack spades     0}
\DocumentationTok{\#\#    ten spades     0}
\DocumentationTok{\#\#   nine spades     0}
\DocumentationTok{\#\#  eight spades     0}
\DocumentationTok{\#\#  seven spades     0}
\DocumentationTok{\#\#    six spades     0}
\DocumentationTok{\#\#   five spades     0}
\DocumentationTok{\#\#   four spades     0}
\DocumentationTok{\#\#  three spades     0}
\DocumentationTok{\#\#    two spades     0}
\DocumentationTok{\#\#    ace spades     0}
\end{Highlighting}
\end{Shaded}

But that's 12 cards too many. What you really want to find is all of the
cards that have both a face value equal to queen and a suit value equal
to spades. You can do that with a \emph{Boolean operator}. Boolean
operators combine multiple logical tests together into a single test.

\subsection{Boolean Operators}\label{boolean-operators}

Boolean operators are things like \emph{and} (\texttt{\&}) and \emph{or}
(\texttt{\textbar{}}). They collapse the results of multiple logical
tests into a single \texttt{TRUE} or \texttt{FALSE}. R has six boolean
operators, shown in Table~\ref{tbl-boole}.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.0909}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.6091}}@{}}
\caption{Boolean operators}\label{tbl-boole}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Syntax
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Tests
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Syntax
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Tests
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\&} & \texttt{cond1\ \&\ cond2} & Are both \texttt{cond1} and
\texttt{cond2} true? \\
\texttt{\textbar{}} & \texttt{cond1\ \textbar{}\ cond2} & Is one or more
of \texttt{cond1} and \texttt{cond2} true? \\
\texttt{xor} & \texttt{xor(cond1,\ cond2)} & Is exactly one of
\texttt{cond1} and \texttt{cond2} true? \\
\texttt{!} & \texttt{!cond1} & Is \texttt{cond1} false? (e.g.,
\texttt{!} flips the results of a logical test) \\
\texttt{any} & \texttt{any(cond1,\ cond2,\ cond3,\ ...)} & Are any of
the conditions true? \\
\texttt{all} & \texttt{all(cond1,\ cond2,\ cond3,\ ...)} & Are all of
the conditions true? \\
\end{longtable}

To use a Boolean operator, place it between two \emph{complete} logical
tests. R will execute each logical test and then use the Boolean
operator to combine the results into a single \texttt{TRUE} or
\texttt{FALSE}, Figure~\ref{fig-boolean}.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-warning-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{The most common mistake with Boolean operators}, toprule=.15mm]

It is easy to forget to put a complete test on either side of a Boolean
operator. In English, it is efficient to say ``Is \emph{x} greater than
two and less than nine?'' But in R, you need to write the equivalent of
``Is \emph{x} greater than two and \emph{is x} less than nine?'' This is
shown in Figure~\ref{fig-boolean}.

\end{tcolorbox}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0501.png}}

}

\caption{\label{fig-boolean}R will evaluate the expressions on each side
of a Boolean operator separately, and then combine the results into a
single TRUE or FALSE. If you do not supply a complete test to each side
of the operator, R will return an error.}

\end{figure}%

When used with vectors, Boolean operators will follow the same
element-wise execution as arithmetic and logical operators:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{c }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{)}

\NormalTok{a }\SpecialCharTok{==}\NormalTok{ b}
\DocumentationTok{\#\#  TRUE TRUE TRUE}

\NormalTok{b }\SpecialCharTok{==}\NormalTok{ c}
\DocumentationTok{\#\#  TRUE  TRUE FALSE}

\NormalTok{a }\SpecialCharTok{==}\NormalTok{ b }\SpecialCharTok{\&}\NormalTok{ b }\SpecialCharTok{==}\NormalTok{ c}
\DocumentationTok{\#\#  TRUE  TRUE FALSE}
\end{Highlighting}
\end{Shaded}

Could you use a Boolean operator to locate the queen of spades in your
deck? Of course you can. You want to test each card to see if it is both
a queen \emph{and} a spade. You can write this test in R with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{==} \StringTok{"queen"} \SpecialCharTok{\&}\NormalTok{ deck4}\SpecialCharTok{$}\NormalTok{suit }\SpecialCharTok{==} \StringTok{"spades"}
\DocumentationTok{\#\#  FALSE  TRUE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\DocumentationTok{\#\#  FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

I'll save the results of this test to its own object. That will make the
results easier to work with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{queenOfSpades }\OtherTok{\textless{}{-}}\NormalTok{ deck4}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{==} \StringTok{"queen"} \SpecialCharTok{\&}\NormalTok{ deck4}\SpecialCharTok{$}\NormalTok{suit }\SpecialCharTok{==} \StringTok{"spades"}
\end{Highlighting}
\end{Shaded}

Next, you can use the test as an index to select the value of the queen
of spades. Make sure the test actually selects the correct value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4[queenOfSpades, ]}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\# queen spades     0}

\NormalTok{deck4}\SpecialCharTok{$}\NormalTok{value[queenOfSpades]}
\DocumentationTok{\#\# 0}
\end{Highlighting}
\end{Shaded}

Now that you've found the queen of spades, you can update her value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck4}\SpecialCharTok{$}\NormalTok{value[queenOfSpades] }\OtherTok{\textless{}{-}} \DecValTok{13}

\NormalTok{deck4[queenOfSpades, ]}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\# queen spades     13}
\end{Highlighting}
\end{Shaded}

Your deck is now ready to play hearts.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Practice with Tests}\vspace{3mm}

If you think you have the hang of logical tests, try converting these
sentences into tests written with R code. To help you out, I've defined
some R objects after the sentences that you can use to test your
answers:

\begin{itemize}
\tightlist
\item
  Is w positive?
\item
  Is x greater than 10 and less than 20?
\item
  Is object y the word February?
\item
  Is \emph{every} value in z a day of the week?
\end{itemize}

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{w }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{15}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \StringTok{"February"}
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Monday"}\NormalTok{, }\StringTok{"Tuesday"}\NormalTok{, }\StringTok{"Friday"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here are some model answers. If you got stuck, be sure to re-read how R
evaluates logical tests that use Boolean values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{w }\SpecialCharTok{\textgreater{}} \DecValTok{0}
\DecValTok{10} \SpecialCharTok{\textless{}}\NormalTok{ x }\SpecialCharTok{\&}\NormalTok{ x }\SpecialCharTok{\textless{}} \DecValTok{20}
\NormalTok{y }\SpecialCharTok{==} \StringTok{"February"}
\FunctionTok{all}\NormalTok{(z }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"Monday"}\NormalTok{, }\StringTok{"Tuesday"}\NormalTok{, }\StringTok{"Wednesday"}\NormalTok{, }\StringTok{"Thursday"}\NormalTok{, }\StringTok{"Friday"}\NormalTok{, }
  \StringTok{"Saturday"}\NormalTok{, }\StringTok{"Sunday"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Let's consider one last game, blackjack. In blackjack, each number card
has a value equal to its face value. Each face card (king, queen, or
jack) has a value of 10. Finally, each ace has a value of 11 or 1,
depending on the final results of the game.

Let's begin with a fresh copy of \texttt{deck}---that way the number
cards (\texttt{two} through \texttt{ten}) will start off with the
correct value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck5 }\OtherTok{\textless{}{-}}\NormalTok{ deck}

\FunctionTok{head}\NormalTok{(deck5, }\DecValTok{13}\NormalTok{)}
\DocumentationTok{\#\#   king spades    13}
\DocumentationTok{\#\#  queen spades    12}
\DocumentationTok{\#\#   jack spades    11}
\DocumentationTok{\#\#    ten spades    10}
\DocumentationTok{\#\#   nine spades     9}
\DocumentationTok{\#\#  eight spades     8}
\DocumentationTok{\#\#  seven spades     7}
\DocumentationTok{\#\#    six spades     6}
\DocumentationTok{\#\#   five spades     5}
\DocumentationTok{\#\#   four spades     4}
\DocumentationTok{\#\#  three spades     3}
\DocumentationTok{\#\#    two spades     2}
\DocumentationTok{\#\#    ace spades     1}
\end{Highlighting}
\end{Shaded}

You can change the value of the face cards in one fell swoop with
\texttt{\%in\%}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{facecard }\OtherTok{\textless{}{-}}\NormalTok{ deck5}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{)}

\NormalTok{deck5[facecard, ]}
\DocumentationTok{\#\#   face     suit value}
\DocumentationTok{\#\#   king   spades    13}
\DocumentationTok{\#\#  queen   spades    12}
\DocumentationTok{\#\#   jack   spades    11}
\DocumentationTok{\#\#   king    clubs    13}
\DocumentationTok{\#\#  queen    clubs    12}
\DocumentationTok{\#\#   jack    clubs    11}
\DocumentationTok{\#\#   king diamonds    13}
\DocumentationTok{\#\#  queen diamonds    12}
\DocumentationTok{\#\#   jack diamonds    11}
\DocumentationTok{\#\#   king   hearts    13}
\DocumentationTok{\#\#  queen   hearts    12}
\DocumentationTok{\#\#   jack   hearts    11}

\NormalTok{deck5}\SpecialCharTok{$}\NormalTok{value[facecard] }\OtherTok{\textless{}{-}} \DecValTok{10}

\FunctionTok{head}\NormalTok{(deck5, }\DecValTok{13}\NormalTok{)}
\DocumentationTok{\#\#   face   suit value}
\DocumentationTok{\#\#   king spades    10}
\DocumentationTok{\#\#  queen spades    10}
\DocumentationTok{\#\#   jack spades    10}
\DocumentationTok{\#\#    ten spades    10}
\DocumentationTok{\#\#   nine spades     9}
\DocumentationTok{\#\#  eight spades     8}
\DocumentationTok{\#\#  seven spades     7}
\DocumentationTok{\#\#    six spades     6}
\DocumentationTok{\#\#   five spades     5}
\DocumentationTok{\#\#   four spades     4}
\DocumentationTok{\#\#  three spades     3}
\DocumentationTok{\#\#    two spades     2}
\DocumentationTok{\#\#    ace spades     1}
\end{Highlighting}
\end{Shaded}

Now you just need to fix the ace values---or do you? It is hard to
decide what value to give the aces because their exact value will change
from hand to hand. At the end of each hand, an ace will equal 11 if the
sum of the player's cards does not exceed 21. Otherwise, the ace will
equal 1. The actual value of the ace will depend on the other cards in
the player's hand. This is a case of missing information. At the moment,
you do not have enough information to assign a correct point value to
the ace cards.

\section{Missing Information}\label{sec-missing}

Missing information problems happen frequently in data science. Usually,
they are more straightforward: you don't know a value because the
measurement was lost, corrupted, or never taken to begin with. R has a
way to help you manage these missing values.

The \texttt{NA} character is a special symbol in R. It stands for ``not
available'' and can be used as a placeholder for missing information. R
will treat NA exactly as you should want missing information treated.
For example, what result would you expect if you add 1 to a piece of
missing information?

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{+} \ConstantTok{NA}
\DocumentationTok{\#\# NA}
\end{Highlighting}
\end{Shaded}

R will return a second piece of missing information. It would not be
correct to say that \texttt{1\ +\ NA\ =\ 1} because there is a good
chance that the missing quantity is not zero. You do not have enough
information to determine the result.

What if you tested whether a piece of missing information is equal to 1?

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{NA} \SpecialCharTok{==} \DecValTok{1}
\DocumentationTok{\#\# NA}
\end{Highlighting}
\end{Shaded}

Again, your answer would be something like ``I do not know if this is
equal to one,'' that is, \texttt{NA}. Generally, \texttt{NA}s will
propagate whenever you use them in an R operation or function. This can
save you from making errors based on missing data.

\subsection{na.rm}\label{na.rm}

Missing values can help you work around holes in your data sets, but
they can also create some frustrating problems. Suppose, for example,
that you've collected 1,000 observations and wish to take their average
with R's \texttt{mean} function. If even one of the values is
\texttt{NA}, your result will be \texttt{NA}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\ConstantTok{NA}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{50}\NormalTok{)}
\DocumentationTok{\#\# NA  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16}
\DocumentationTok{\#\# 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33}
\DocumentationTok{\#\# 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50}

\FunctionTok{mean}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\ConstantTok{NA}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{50}\NormalTok{))}
\DocumentationTok{\#\# NA}
\end{Highlighting}
\end{Shaded}

Understandably, you may prefer a different behavior. Most R functions
come with the optional argument, \texttt{na.rm}, which stands for
\texttt{NA} remove. R will ignore \texttt{NA}s when it evaluates a
function if you add the argument \texttt{na.rm\ =\ TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\ConstantTok{NA}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{50}\NormalTok{), }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\DocumentationTok{\#\# 25.5}
\end{Highlighting}
\end{Shaded}

\subsection{is.na}\label{is.na}

On occasion, you may want to identify the \texttt{NA}s in your data set
with a logical test, but that too creates a problem. How would you go
about it? If something is a missing value, any logical test that uses it
will return a missing value, even this test:

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{NA} \SpecialCharTok{==} \ConstantTok{NA}
\DocumentationTok{\#\# NA}
\end{Highlighting}
\end{Shaded}

Which means that tests like this won't help you find missing values:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\ConstantTok{NA}\NormalTok{) }\SpecialCharTok{==} \ConstantTok{NA}
\DocumentationTok{\#\# NA NA NA NA}
\end{Highlighting}
\end{Shaded}

But don't worry too hard; R supplies a special function that can test
whether a value is an \texttt{NA}. The function is sensibly named
\texttt{is.na}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.na}\NormalTok{(}\ConstantTok{NA}\NormalTok{)}
\DocumentationTok{\#\# TRUE}

\NormalTok{vec }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\ConstantTok{NA}\NormalTok{)}
\FunctionTok{is.na}\NormalTok{(vec)}
\DocumentationTok{\#\# FALSE FALSE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

Let's set all of your ace values to \texttt{NA}. This will accomplish
two things. First, it will remind you that you do not know the final
value of each ace. Second, it will prevent you from accidentally scoring
a hand that has an ace before you determine the ace's final value.

You can set your ace values to \texttt{NA} in the same way that you
would set them to a number:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck5}\SpecialCharTok{$}\NormalTok{value[deck5}\SpecialCharTok{$}\NormalTok{face }\SpecialCharTok{==} \StringTok{"ace"}\NormalTok{] }\OtherTok{\textless{}{-}} \ConstantTok{NA}

\FunctionTok{head}\NormalTok{(deck5, }\DecValTok{13}\NormalTok{)}
\DocumentationTok{\#\#   face   suit value}
\DocumentationTok{\#\#   king spades    10}
\DocumentationTok{\#\#  queen spades    10}
\DocumentationTok{\#\#   jack spades    10}
\DocumentationTok{\#\#    ten spades    10}
\DocumentationTok{\#\#   nine spades     9}
\DocumentationTok{\#\#  eight spades     8}
\DocumentationTok{\#\#  seven spades     7}
\DocumentationTok{\#\#    six spades     6}
\DocumentationTok{\#\#   five spades     5}
\DocumentationTok{\#\#   four spades     4}
\DocumentationTok{\#\#  three spades     3}
\DocumentationTok{\#\#    two spades     2}
\DocumentationTok{\#\#    ace spades    NA}
\end{Highlighting}
\end{Shaded}

Congratulations. Your deck is now ready for a game of blackjack.

\section{Summary}\label{summary-4}

You can modify values in place inside an R object when you combine R's
notation syntax with the assignment operator, \texttt{\textless{}-}.
This lets you update your data and clean your data sets

When you work with large data sets, modifying and retrieving values
creates a logistical problem of its own. How can you search through the
data to find the values that you want to modify or retrieve? As an R
user, you can do this with logical subsetting. Create a logical test
with logical and Boolean operators and then use the test as an index in
R's bracket notation. R will return the values that you are looking for,
even if you do not know where they are.

Retrieving individual values will not be your only concern as an R
programmer. You'll also need to retrieve entire data sets themselves;
for example, you may call one in a function.
\hyperref[sec-environments]{Environments} will teach you how R looks up
and saves data sets and other R objects in its environment system.
You'll then use this knowledge to fix the \texttt{deal} and
\texttt{shuffle} functions.

\chapter{Environments}\label{sec-environments}

Your deck is now ready for a game of blackjack (or hearts or war), but
are your \texttt{shuffle} and \texttt{deal} functions up to snuff?
Definitely not. For example, \texttt{deal} deals the same card over and
over again:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{deal}\NormalTok{(deck)}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}

\FunctionTok{deal}\NormalTok{(deck)}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}

\FunctionTok{deal}\NormalTok{(deck)}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# king spades    13}
\end{Highlighting}
\end{Shaded}

And the \texttt{shuffle} function doesn't actually shuffle \texttt{deck}
(it returns a copy of \texttt{deck} that has been shuffled). In short,
both of these functions use \texttt{deck}, but neither manipulates
\texttt{deck}---and we would like them to.

To fix these functions, you will need to learn how R stores, looks up,
and manipulates objects like \texttt{deck}. R does all of these things
with the help of an environment system.

\section{Environments}\label{environments}

Consider for a moment how your computer stores files. Every file is
saved in a folder, and each folder is saved in another folder, which
forms a hierarchical file system. If your computer wants to open up a
file, it must first look up the file in this file system.

You can see your file system by opening a finder window. For example,
Figure~\ref{fig-folders} shows part of the file system on my computer. I
have tons of folders. Inside one of them is a subfolder named
\emph{Documents}, inside of that subfolder is a sub-subfolder named
\emph{ggsubplot}, inside of that folder is a folder named \emph{inst},
inside of that is a folder named \emph{doc}, and inside of that is a
file named \emph{manual.pdf}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0601.png}}

}

\caption{\label{fig-folders}Your computer arranges files into a
hierarchy of folders and subfolders. To look at a file, you need to find
where it is saved in the file system.}

\end{figure}%

R uses a similar system to save R objects. Each object is saved inside
of an environment, a list-like object that resembles a folder on your
computer. Each environment is connected to a \emph{parent environment},
a higher-level environment, which creates a hierarchy of environments.

You can see R's environment system with the \texttt{parenvs} function in
the pryr package (note \texttt{parenvs} came in the pryr package when
this book was first published). \texttt{parenvs(all\ =\ TRUE)} will
return a list of the environments that your R session is using. The
actual output will vary from session to session depending on which
packages you have loaded. Here's the output from my current session:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(pryr)}
\FunctionTok{parenvs}\NormalTok{(}\AttributeTok{all =} \ConstantTok{TRUE}\NormalTok{)}
\DocumentationTok{\#\#    label                            name               }
\DocumentationTok{\#\# 1  \textless{}environment: R\_GlobalEnv\textgreater{}       ""                 }
\DocumentationTok{\#\# 2  \textless{}environment: package:pryr\textgreater{}  "package:pryr" }
\DocumentationTok{\#\# 3  \textless{}environment: 0x7fff3321c388\textgreater{}    "tools:rstudio"    }
\DocumentationTok{\#\# 4  \textless{}environment: package:stats\textgreater{}     "package:stats"    }
\DocumentationTok{\#\# 5  \textless{}environment: package:graphics\textgreater{}  "package:graphics" }
\DocumentationTok{\#\# 6  \textless{}environment: package:grDevices\textgreater{} "package:grDevices"}
\DocumentationTok{\#\# 7  \textless{}environment: package:utils\textgreater{}     "package:utils"    }
\DocumentationTok{\#\# 8  \textless{}environment: package:datasets\textgreater{}  "package:datasets" }
\DocumentationTok{\#\# 9  \textless{}environment: package:methods\textgreater{}   "package:methods"  }
\DocumentationTok{\#\# 10 \textless{}environment: 0x7fff3193dab0\textgreater{}    "Autoloads"        }
\DocumentationTok{\#\# 11 \textless{}environment: base\textgreater{}              ""                 }
\DocumentationTok{\#\# 12 \textless{}environment: R\_EmptyEnv\textgreater{}        ""                 }
\end{Highlighting}
\end{Shaded}

It takes some imagination to interpret this output, so let's visualize
the environments as a system of folders, Figure~\ref{fig-environments}.
You can think of the environment tree like this. The lowest-level
environment is named \texttt{R\_GlobalEnv} and is saved inside an
environment named \texttt{package:pryr}, which is saved inside the
environment named \texttt{0x7fff3321c388}, and so on, until you get to
the final, highest-level environment, \texttt{R\_EmptyEnv}.
\texttt{R\_EmptyEnv} is the only R environment that does not have a
parent environment.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0602.png}}

}

\caption{\label{fig-environments}R stores R objects in an environment
tree that resembles your computer's folder system.}

\end{figure}%

Remember that this example is just a metaphor. R's environments exist in
your RAM memory, and not in your file system. Also, R environments
aren't technically saved inside one another. Each environment is
connected to a parent environment, which makes it easy to search up R's
environment tree. But this connection is one-way: there's no way to look
at one environment and tell what its ``children'' are. So you cannot
search down R's environment tree. In other ways, though, R's environment
system works similar to a file system.

\section{Working with Environments}\label{working-with-environments}

R comes with some helper functions that you can use to explore your
environment tree. First, you can refer to any of the environments in
your tree with \texttt{as.environment}. \texttt{as.environment} takes an
environment name (as a character string) and returns the corresponding
environment:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.environment}\NormalTok{(}\StringTok{"package:stats"}\NormalTok{)}
\DocumentationTok{\#\# \textless{}environment: package:stats\textgreater{}}
\DocumentationTok{\#\# attr(,"name")}
\DocumentationTok{\#\# [1] "package:stats"}
\DocumentationTok{\#\# attr(,"path")}
\DocumentationTok{\#\# [1] "/Library/Frameworks/R.framework/Versions/3.0/Resources/library/stats"}
\end{Highlighting}
\end{Shaded}

Three environments in your tree also come with their own accessor
functions. These are the global environment (\texttt{R\_GlobalEnv}), the
base environment (\texttt{base}), and the empty environment
(\texttt{R\_EmptyEnv}). You can refer to them with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{globalenv}\NormalTok{()}
\DocumentationTok{\#\# \textless{}environment: R\_GlobalEnv\textgreater{}}

\FunctionTok{baseenv}\NormalTok{()}
\DocumentationTok{\#\# \textless{}environment: base\textgreater{}}

\FunctionTok{emptyenv}\NormalTok{()}
\DocumentationTok{\#\#\textless{}environment: R\_EmptyEnv\textgreater{}}
\end{Highlighting}
\end{Shaded}

Next, you can look up an environment's parent with \texttt{parent.env}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{parent.env}\NormalTok{(}\FunctionTok{globalenv}\NormalTok{())}
\DocumentationTok{\#\# \textless{}environment: package:pryr\textgreater{}}
\DocumentationTok{\#\# attr(,"name")}
\DocumentationTok{\#\# [1] "package:pryr"}
\DocumentationTok{\#\# attr(,"path")}
\DocumentationTok{\#\# [1] "/Library/Frameworks/R.framework/Versions/3.0/Resources/library/pryr"}
\end{Highlighting}
\end{Shaded}

Notice that the empty environment is the only R environment without a
parent:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{parent.env}\NormalTok{(}\FunctionTok{emptyenv}\NormalTok{())}
\DocumentationTok{\#\# Error in parent.env(emptyenv()) : the empty environment has no parent}
\end{Highlighting}
\end{Shaded}

You can view the objects saved in an environment with \texttt{ls} or
\texttt{ls.str}. \texttt{ls} will return just the object names, but
\texttt{ls.str} will display a little about each object's structure:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}\NormalTok{(}\FunctionTok{emptyenv}\NormalTok{())}
\DocumentationTok{\#\# character(0)}

\FunctionTok{ls}\NormalTok{(}\FunctionTok{globalenv}\NormalTok{())}
\DocumentationTok{\#\#  "deal"    "deck"    "deck2"   "deck3"   "deck4"   "deck5"  }
\DocumentationTok{\#\#  "die"     "gender"  "hand"    "lst"     "mat"     "mil"    }
\DocumentationTok{\#\#  "new"     "now"     "shuffle" "vec"  }
\end{Highlighting}
\end{Shaded}

The empty environment is---not surprisingly---empty; the base
environment has too many objects to list here; and the global
environment has some familiar faces. It is where R has saved all of the
objects that you've created so far.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, toprule=.15mm]

RStudio's environment pane displays all of the objects in your global
environment.

\end{tcolorbox}

You can use R's \texttt{\$} syntax to access an object in a specific
environment. For example, you can access \texttt{deck} from the global
environment:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(}\FunctionTok{globalenv}\NormalTok{()}\SpecialCharTok{$}\NormalTok{deck, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  king spades    13}
\DocumentationTok{\#\# queen spades    12}
\DocumentationTok{\#\#  jack spades    11}
\end{Highlighting}
\end{Shaded}

And you can use the \texttt{assign} function to save an object into a
particular environment. First give \texttt{assign} the name of the new
object (as a character string). Then give \texttt{assign} the value of
the new object, and finally the environment to save the object in:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{assign}\NormalTok{(}\StringTok{"new"}\NormalTok{, }\StringTok{"Hello Global"}\NormalTok{, }\AttributeTok{envir =} \FunctionTok{globalenv}\NormalTok{())}

\FunctionTok{globalenv}\NormalTok{()}\SpecialCharTok{$}\NormalTok{new}
\DocumentationTok{\#\# "Hello Global"}
\end{Highlighting}
\end{Shaded}

Notice that \texttt{assign} works similar to \texttt{\textless{}-}. If
an object already exists with the given name in the given environment,
\texttt{assign} will overwrite it without asking for permission. This
makes \texttt{assign} useful for updating objects but creates the
potential for heartache.

Now that you can explore R's environment tree, let's examine how R uses
it. R works closely with the environment tree to look up objects, store
objects, and evaluate functions. How R does each of these tasks will
depend on the current active environment.

\subsection{The Active Environment}\label{the-active-environment}

At any moment of time, R is working closely with a single environment. R
will store new objects in this environment (if you create any), and R
will use this environment as a starting point to look up existing
objects (if you call any). I'll call this special environment the
\emph{active environment}. The active environment is usually the global
environment, but this may change when you run a function.

You can use \texttt{environment} to see the current active environment:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{environment}\NormalTok{()}
\SpecialCharTok{\textless{}}\NormalTok{environment}\SpecialCharTok{:}\NormalTok{ R\_GlobalEnv}\SpecialCharTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

The global environment plays a special role in R. It is the active
environment for every command that you run at the command line. As a
result, any object that you create at the command line will be saved in
the global environment. You can think of the global environment as your
user workspace.

When you call an object at the command line, R will look for it first in
the global environment. But what if the object is not there? In that
case, R will follow a series of rules to look up the object.

\section{Scoping Rules}\label{scoping-rules}

R follows a special set of rules to look up objects. These rules are
known as R's scoping rules, and you've already met a couple of them:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  R looks for objects in the current active environment.
\item
  When you work at the command line, the active environment is the
  global environment. Hence, R looks up objects that you call at the
  command line in the global environment.
\end{enumerate}

Here is a third rule that explains how R finds objects that are not in
the active environment

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  When R does not find an object in an environment, R looks in the
  environment's parent environment, then the parent of the parent, and
  so on, until R finds the object or reaches the empty environment.
\end{enumerate}

So, if you call an object at the command line, R will look for it in the
global environment. If R can't find it there, R will look in the parent
of the global environment, and then the parent of the parent, and so on,
working its way up the environment tree until it finds the object, as in
Figure~\ref{fig-path}. If R cannot find the object in any environment,
it will return an error that says the object is not found.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0603.png}}

}

\caption{\label{fig-path}R will search for an object by name in the
active environment, here the global environment. If R does not find the
object there, it will search in the active environment's parent, and
then the parent's parent, and so on until R finds the object or runs out
of environments.}

\end{figure}%

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, toprule=.15mm]

Remember that functions are a type of object in R. R will store and look
up functions the same way it stores and looks up other objects, by
searching for them by name in the environment tree.

\end{tcolorbox}

\section{Assignment}\label{assignment}

When you assign a value to an object, R saves the value in the active
environment under the object's name. If an object with the same name
already exists in the active environment, R will overwrite it.

For example, an object named \texttt{new} exists in the global
environment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new}
\DocumentationTok{\#\# "Hello Global"}
\end{Highlighting}
\end{Shaded}

You can save a new object named \texttt{new} to the global environment
with this command. R will overwrite the old object as a result:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new }\OtherTok{\textless{}{-}} \StringTok{"Hello Active"}

\NormalTok{new}
\DocumentationTok{\#\# "Hello Active"}
\end{Highlighting}
\end{Shaded}

This arrangement creates a quandary for R whenever R runs a function.
Many functions save temporary objects that help them do their jobs. For
example, the \texttt{roll} function from
\hyperref[sec-project-1]{Project 1: Weighted Dice} saved an object named
\texttt{die} and an object named \texttt{dice}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  die }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}
\NormalTok{  dice }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
  \FunctionTok{sum}\NormalTok{(dice)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

R must save these temporary objects in the active environment; but if R
does that, it may overwrite existing objects. Function authors cannot
guess ahead of time which names may already exist in your active
environment. How does R avoid this risk? Every time R runs a function,
it creates a new active environment to evaluate the function in.

\section{Evaluation}\label{evaluation}

R creates a new environment \emph{each} time it evaluates a function. R
will use the new environment as the active environment while it runs the
function, and then R will return to the environment that you called the
function from, bringing the function's result with it. Let's call these
new environments \emph{runtime environments} because R creates them at
runtime to evaluate functions.

We'll use the following function to explore R's runtime environments. We
want to know what the environments look like: what are their parent
environments, and what objects do they contain? \texttt{show\_env} is
designed to tell us:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show\_env }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{()\{}
  \FunctionTok{list}\NormalTok{(}\AttributeTok{ran.in =} \FunctionTok{environment}\NormalTok{(), }
    \AttributeTok{parent =} \FunctionTok{parent.env}\NormalTok{(}\FunctionTok{environment}\NormalTok{()), }
    \AttributeTok{objects =} \FunctionTok{ls.str}\NormalTok{(}\FunctionTok{environment}\NormalTok{()))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{show\_env} is itself a function, so when we call
\texttt{show\_env()}, R will create a runtime environment to evaluate
the function in. The results of \texttt{show\_env} will tell us the name
of the runtime environment, its parent, and which objects the runtime
environment contains:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{show\_env}\NormalTok{()}
\DocumentationTok{\#\# $ran.in}
\DocumentationTok{\#\# \textless{}environment: 0x7ff711d12e28\textgreater{}}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $parent}
\DocumentationTok{\#\# \textless{}environment: R\_GlobalEnv\textgreater{}}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $objects}
\end{Highlighting}
\end{Shaded}

The results reveal that R created a new environment named
\texttt{0x7ff711d12e28} to run \texttt{show\_env()} in. The environment
had no objects in it, and its parent was the
\texttt{global\ environment}. So for purposes of running
\texttt{show\_env}, R's environment tree looked like
Figure~\ref{fig-tree}.

Let's run \texttt{show\_env} again:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{show\_env}\NormalTok{()}
\DocumentationTok{\#\# $ran.in}
\DocumentationTok{\#\# \textless{}environment: 0x7ff715f49808\textgreater{}}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $parent}
\DocumentationTok{\#\# \textless{}environment: R\_GlobalEnv\textgreater{}}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $objects}
\end{Highlighting}
\end{Shaded}

This time \texttt{show\_env} ran in a new environment,
\texttt{0x7ff715f49808}. R creates a new environment \emph{each} time
you run a function. The \texttt{0x7ff715f49808} environment looks
exactly the same as \texttt{0x7ff711d12e28}. It is empty and has the
same global environment as its parent.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0604.png}}

}

\caption{\label{fig-tree}R creates a new environment to run show\_env
in. The environment is a child of the global environment.}

\end{figure}%

Now let's consider which environment R will use as the parent of the
runtime environment.

R will connect a function's runtime environment to the environment that
the function \emph{was first created in}. This environment plays an
important role in the function's life---because all of the function's
runtime environments will use it as a parent. Let's call this
environment the \emph{origin environment}. You can look up a function's
origin environment by running \texttt{environment} on the function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{environment}\NormalTok{(show\_env)}
\DocumentationTok{\#\# \textless{}environment: R\_GlobalEnv\textgreater{}}
\end{Highlighting}
\end{Shaded}

The origin environment of \texttt{show\_env} is the global environment
because we created \texttt{show\_env} at the command line, but the
origin environment does not need to be the global environment. For
example, the environment of \texttt{parenvs} is the \texttt{pryr}
package:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{environment}\NormalTok{(parenvs)}
\DocumentationTok{\#\# \textless{}environment: namespace:pryr\textgreater{}}
\end{Highlighting}
\end{Shaded}

In other words, the parent of a runtime environment will not always be
the global environment; it will be whichever environment the function
was first created in.

Finally, let's look at the objects contained in a runtime environment.
At the moment, \texttt{show\_env}'s runtime environments do not contain
any objects, but that is easy to fix. Just have \texttt{show\_env}
create some objects in its body of code. R will store any objects
created by \texttt{show\_env} in its runtime environment. Why? Because
the runtime environment will be the active environment when those
objects are created:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show\_env }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{  a }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{  b }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{  c }\OtherTok{\textless{}{-}} \DecValTok{3}
  \FunctionTok{list}\NormalTok{(}\AttributeTok{ran.in =} \FunctionTok{environment}\NormalTok{(), }
    \AttributeTok{parent =} \FunctionTok{parent.env}\NormalTok{(}\FunctionTok{environment}\NormalTok{()), }
    \AttributeTok{objects =} \FunctionTok{ls.str}\NormalTok{(}\FunctionTok{environment}\NormalTok{()))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This time when we run \texttt{show\_env}, R stores \texttt{a},
\texttt{b}, and \texttt{c} in the runtime environment:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{show\_env}\NormalTok{()}
\DocumentationTok{\#\# $ran.in}
\DocumentationTok{\#\# \textless{}environment: 0x7ff712312cd0\textgreater{}}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $parent}
\DocumentationTok{\#\# \textless{}environment: R\_GlobalEnv\textgreater{}}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $objects}
\DocumentationTok{\#\# a :  num 1}
\DocumentationTok{\#\# b :  num 2}
\DocumentationTok{\#\# c :  num 3}
\end{Highlighting}
\end{Shaded}

This is how R ensures that a function does not overwrite anything that
it shouldn't. Any objects created by the function are stored in a safe,
out-of-the-way runtime environment.

R will also put a second type of object in a runtime environment. If a
function has arguments, R will copy over each argument to the runtime
environment. The argument will appear as an object that has the name of
the argument but the value of whatever input the user provided for the
argument. This ensures that a function will be able to find and use each
of its arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{foo }\OtherTok{\textless{}{-}} \StringTok{"take me to your runtime"}

\NormalTok{show\_env }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{x =}\NormalTok{ foo)\{}
  \FunctionTok{list}\NormalTok{(}\AttributeTok{ran.in =} \FunctionTok{environment}\NormalTok{(), }
    \AttributeTok{parent =} \FunctionTok{parent.env}\NormalTok{(}\FunctionTok{environment}\NormalTok{()), }
    \AttributeTok{objects =} \FunctionTok{ls.str}\NormalTok{(}\FunctionTok{environment}\NormalTok{()))}
\NormalTok{\}}

\FunctionTok{show\_env}\NormalTok{()}
\DocumentationTok{\#\# $ran.in}
\DocumentationTok{\#\# \textless{}environment: 0x7ff712398958\textgreater{}}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $parent}
\DocumentationTok{\#\# \textless{}environment: R\_GlobalEnv\textgreater{}}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $objects}
\DocumentationTok{\#\# x :  chr "take me to your runtime"}
\end{Highlighting}
\end{Shaded}

Let's put this all together to see how R evaluates a function. Before
you call a function, R is working in an active environment; let's call
this the \emph{calling environment}. It is the environment R calls the
function from.

Then you call the function. R responds by setting up a new runtime
environment. This environment will be a child of the function's origin
enviornment. R will copy each of the function's arguments into the
runtime environment and then make the runtime environment the new active
environment.

Next, R runs the code in the body of the function. If the code creates
any objects, R stores them in the active, that is, runtime environment.
If the code calls any objects, R uses its scoping rules to look them up.
R will search the runtime environment, then the parent of the runtime
environment (which will be the origin environment), then the parent of
the origin environment, and so on. Notice that the calling environment
might not be on the search path. Usually, a function will only call its
arguments, which R can find in the active runtime environment.

Finally, R finishes running the function. It switches the active
environment back to the calling environment. Now R executes any other
commands in the line of code that called the function. So if you save
the result of the function to an object with \texttt{\textless{}-}, the
new object will be stored in the calling environment.

To recap, R stores its objects in an environment system. At any moment
of time, R is working closely with a single active environment. It
stores new objects in this environment, and it uses the environment as a
starting point when it searches for existing objects. R's active
environment is usually the global environment, but R will adjust the
active environment to do things like run functions in a safe manner.

How can you use this knowledge to fix the \texttt{deal} and
\texttt{shuffle} functions?

First, let's start with a warm-up question. Suppose I redefine
\texttt{deal} at the command line like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  deck[}\DecValTok{1}\NormalTok{, ]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice that \texttt{deal} no longer takes an argument, and it calls the
\texttt{deck} object, which lives in the global environment.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Will deal work?}\vspace{3mm}

Will R be able to find \texttt{deck} and return an answer when I call
the new version of \texttt{deal}, such as \texttt{deal()}?

\end{tcolorbox}

Yes. \texttt{deal} will still work the same as before. R will run
\texttt{deal} in a runtime environment that is a child of the global
environment. Why will it be a child of the global environment? Because
the global environment is the origin environment of \texttt{deal} (we
defined \texttt{deal} in the global environment):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{environment}\NormalTok{(deal)}
\DocumentationTok{\#\# \textless{}environment: R\_GlobalEnv\textgreater{}}
\end{Highlighting}
\end{Shaded}

When \texttt{deal} calls \texttt{deck}, R will need to look up the
\texttt{deck} object. R's scoping rules will lead it to the version of
\texttt{deck} in the global environment, as in Figure~\ref{fig-deal}.
\texttt{deal} works as expected as a result:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  king spades    13}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0605.png}}

}

\caption{\label{fig-deal}R finds \texttt{deck} by looking in the parent
of deal's runtime environment. The parent is the global environment,
deal's origin environment. Here, R finds the copy of \texttt{deck}.}

\end{figure}%

Now let's fix the \texttt{deal} function to remove the cards it has
dealt from \texttt{deck}. Recall that \texttt{deal} returns the top card
of \texttt{deck} but does not remove the card from the deck. As a
result, \texttt{deal} always returns the same card:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  king spades    13}

\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  king spades    13}
\end{Highlighting}
\end{Shaded}

You know enough R syntax to remove the top card of \texttt{deck}. The
following code will save a prisitine copy of \texttt{deck} and then
remove the top card:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DECK }\OtherTok{\textless{}{-}}\NormalTok{ deck}

\NormalTok{deck }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, ]}

\FunctionTok{head}\NormalTok{(deck, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\# queen spades    12}
\DocumentationTok{\#\#  jack spades    11}
\DocumentationTok{\#\#   ten spades    10}
\end{Highlighting}
\end{Shaded}

Now let's add the code to \texttt{deal}. Here \texttt{deal} saves (and
then returns) the top card of \texttt{deck}. In between, it removes the
card from \texttt{deck}\ldots or does it?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  card }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\DecValTok{1}\NormalTok{, ]}
\NormalTok{  deck }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, ]}
\NormalTok{  card}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This code won't work because R will be in a runtime environment when it
executes \texttt{deck\ \textless{}-\ deck{[}-1,\ {]}}. Instead of
overwriting the global copy of \texttt{deck} with
\texttt{deck{[}-1,\ {]}}, \texttt{deal} will just create a slightly
altered copy of \texttt{deck} in its runtime environment, as in
Figure~\ref{fig-second-deck}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0606.png}}

}

\caption{\label{fig-second-deck}The deal function looks up deck in the
global environment but saves \texttt{deck{[}-1,\ {]}} in the runtime
environment as a new object named deck.}

\end{figure}%

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Overwrite deck}\vspace{3mm}

Rewrite the \texttt{deck\ \textless{}-\ deck{[}-1,\ {]}} line of
\texttt{deal} to \emph{assign} \texttt{deck{[}-1,\ {]}} to an object
named \texttt{deck} in the global environment. Hint: consider the
\texttt{assign} function.

\end{tcolorbox}

You can assign an object to a specific environment with the
\texttt{assign} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  card }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\DecValTok{1}\NormalTok{, ]}
  \FunctionTok{assign}\NormalTok{(}\StringTok{"deck"}\NormalTok{, deck[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, ], }\AttributeTok{envir =} \FunctionTok{globalenv}\NormalTok{())}
\NormalTok{  card}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now \texttt{deal} will finally clean up the global copy of
\texttt{deck}, and we can \texttt{deal} cards just as we would in real
life:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\# queen spades    12}

\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\# jack spades    11}

\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\#  ten spades    10}
\end{Highlighting}
\end{Shaded}

Let's turn our attention to the \texttt{shuffle} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{shuffle }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(cards) \{ }
\NormalTok{  random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{)}
\NormalTok{  cards[random, ]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{shuffle(deck)} doesn't shuffle the \texttt{deck} object; it
returns a shuffled copy of the \texttt{deck} object:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(deck, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  nine spades     9}
\DocumentationTok{\#\# eight spades     8}
\DocumentationTok{\#\# seven spades     7}

\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{shuffle}\NormalTok{(deck)}

\FunctionTok{head}\NormalTok{(deck, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  nine spades     9}
\DocumentationTok{\#\# eight spades     8}
\DocumentationTok{\#\# seven spades     7}

\FunctionTok{head}\NormalTok{(a, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\#  face     suit value}
\DocumentationTok{\#\#   ace diamonds     1}
\DocumentationTok{\#\# seven    clubs     7}
\DocumentationTok{\#\#   two    clubs     2}
\end{Highlighting}
\end{Shaded}

This behavior is now undesirable in two ways. First, \texttt{shuffle}
fails to shuffle \texttt{deck}. Second, \texttt{shuffle} returns a copy
of \texttt{deck}, which may be missing the cards that have been dealt
away. It would be better if \texttt{shuffle} returned the dealt cards to
the deck and then shuffled. This is what happens when you shuffle a deck
of cards in real life.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Rewrite shuffle}\vspace{3mm}

Rewrite \texttt{shuffle} so that it replaces the copy of \texttt{deck}
that lives in the global environment with a shuffled version of
\texttt{DECK}, the intact copy of \texttt{deck} that also lives in the
global environment. The new version of \texttt{shuffle} should have no
arguments and return no output.

\end{tcolorbox}

You can update \texttt{shuffle} in the same way that you updated
\texttt{deck}. The following version will do the job:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{shuffle }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{  random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{)}
  \FunctionTok{assign}\NormalTok{(}\StringTok{"deck"}\NormalTok{, DECK[random, ], }\AttributeTok{envir =} \FunctionTok{globalenv}\NormalTok{())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Since \texttt{DECK} lives in the global environment, \texttt{shuffle}'s
environment of origin, \texttt{shuffle} will be able to find
\texttt{DECK} at runtime. R will search for \texttt{DECK} first in
\texttt{shuffle}'s runtime environment, and then in \texttt{shuffle}'s
origin environment---the global environment---which is where
\texttt{DECK} is stored.

The second line of \texttt{shuffle} will create a reordered copy of
\texttt{DECK} and save it as \texttt{deck} in the global environment.
This will overwrite the previous, nonshuffled version of \texttt{deck}.

\section{Closures}\label{closures}

Our system finally works. For example, you can shuffle the cards and
then deal a hand of blackjack:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{shuffle}\NormalTok{()}

\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\# queen hearts    12}

\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\# eight hearts     8}
\end{Highlighting}
\end{Shaded}

But the system requires \texttt{deck} and \texttt{DECK} to exist in the
global environment. Lots of things happen in this environment, and it is
possible that \texttt{deck} may get modified or erased by accident.

It would be better if we could store \texttt{deck} in a safe,
out-of-the-way place, like one of those safe, out-of-the-way
environments that R creates to run functions in. In fact, storing
\texttt{deck} in a runtime environment is not such a bad idea.

You could create a function that takes \texttt{deck} as an argument and
saves a copy of \texttt{deck} as \texttt{DECK}. The function could also
save its own copies of \texttt{deal} and \texttt{shuffle}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setup }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(deck) \{}
\NormalTok{  DECK }\OtherTok{\textless{}{-}}\NormalTok{ deck}

\NormalTok{  DEAL }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    card }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\DecValTok{1}\NormalTok{, ]}
    \FunctionTok{assign}\NormalTok{(}\StringTok{"deck"}\NormalTok{, deck[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, ], }\AttributeTok{envir =} \FunctionTok{globalenv}\NormalTok{())}
\NormalTok{    card}
\NormalTok{  \}}

\NormalTok{  SHUFFLE }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{    random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{)}
    \FunctionTok{assign}\NormalTok{(}\StringTok{"deck"}\NormalTok{, DECK[random, ], }\AttributeTok{envir =} \FunctionTok{globalenv}\NormalTok{())}
\NormalTok{ \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When you run \texttt{setup}, R will create a runtime environment to
store these objects in. The environment will look like
Figure~\ref{fig-closure1}.

Now all of these things are safely out of the way in a child of the
global environment. That makes them safe but hard to use. Let's ask
\texttt{setup} to return \texttt{DEAL} and \texttt{SHUFFLE} so we can
use them. The best way to do this is to return the functions as a list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setup }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(deck) \{}
\NormalTok{  DECK }\OtherTok{\textless{}{-}}\NormalTok{ deck}

\NormalTok{  DEAL }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    card }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\DecValTok{1}\NormalTok{, ]}
    \FunctionTok{assign}\NormalTok{(}\StringTok{"deck"}\NormalTok{, deck[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, ], }\AttributeTok{envir =} \FunctionTok{globalenv}\NormalTok{())}
\NormalTok{    card}
\NormalTok{  \}}

\NormalTok{  SHUFFLE }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{    random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{)}
    \FunctionTok{assign}\NormalTok{(}\StringTok{"deck"}\NormalTok{, DECK[random, ], }\AttributeTok{envir =} \FunctionTok{globalenv}\NormalTok{())}
\NormalTok{ \}}

 \FunctionTok{list}\NormalTok{(}\AttributeTok{deal =}\NormalTok{ DEAL, }\AttributeTok{shuffle =}\NormalTok{ SHUFFLE)}
\NormalTok{\}}

\NormalTok{cards }\OtherTok{\textless{}{-}} \FunctionTok{setup}\NormalTok{(deck)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0607.png}}

}

\caption{\label{fig-closure1}Running setup will store deck and DECK in
an out-of-the-way place, and create a DEAL and SHUFFLE function. Each of
these objects will be stored in an environment whose parent is the
global environment.}

\end{figure}%

Then you can save each of the elements of the list to a dedicated object
in the global environment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deal }\OtherTok{\textless{}{-}}\NormalTok{ cards}\SpecialCharTok{$}\NormalTok{deal}
\NormalTok{shuffle }\OtherTok{\textless{}{-}}\NormalTok{ cards}\SpecialCharTok{$}\NormalTok{shuffle}
\end{Highlighting}
\end{Shaded}

Now you can run \texttt{deal} and \texttt{shuffle} just as before. Each
object contains the same code as the original \texttt{deal} and
\texttt{shuffle}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deal}
\DocumentationTok{\#\# function() \{}
\DocumentationTok{\#\#     card \textless{}{-} deck[1, ]}
\DocumentationTok{\#\#     assign("deck", deck[{-}1, ], envir = globalenv())}
\DocumentationTok{\#\#     card}
\DocumentationTok{\#\#   \}}
\DocumentationTok{\#\# \textless{}environment: 0x7ff7169c3390\textgreater{}}

\NormalTok{shuffle}
\DocumentationTok{\#\# function()\{}
\DocumentationTok{\#\#     random \textless{}{-} sample(1:52, size = 52)}
\DocumentationTok{\#\#     assign("deck", DECK[random, ], envir = globalenv())}
\DocumentationTok{\#\#  \}}
\DocumentationTok{\#\# \textless{}environment: 0x7ff7169c3390\textgreater{}}
\end{Highlighting}
\end{Shaded}

However, the functions now have one important difference. Their origin
environment is no longer the global environment (although \texttt{deal}
and \texttt{shuffle} \emph{are} currently saved there). Their origin
environment is the runtime environment that R made when you ran
\texttt{setup}. That's where R created \texttt{DEAL} and
\texttt{SHUFFLE}, the functions copied into the new \texttt{deal} and
\texttt{shuffle}, as shown in:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{environment}\NormalTok{(deal)}
\DocumentationTok{\#\# \textless{}environment: 0x7ff7169c3390\textgreater{}}

\FunctionTok{environment}\NormalTok{(shuffle)}
\DocumentationTok{\#\# \textless{}environment: 0x7ff7169c3390\textgreater{}}
\end{Highlighting}
\end{Shaded}

Why does this matter? Because now when you run \texttt{deal} or
\texttt{shuffle}, R will evaluate the functions in a runtime environment
that uses \texttt{0x7ff7169c3390} as its parent. \texttt{DECK} and
\texttt{deck} will be in this parent environment, which means that
\texttt{deal} and \texttt{shuffle} will be able to find them at runtime.
\texttt{DECK} and \texttt{deck} will be in the functions' search path
but still out of the way in every other respect, as shown in
Figure~\ref{fig-closure2}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0608.png}}

}

\caption{\label{fig-closure2}Now deal and shuffle will be run in an
environment that has the protected deck and DECK in its search path.}

\end{figure}%

This arrangement is called a \emph{closure}. \texttt{setup}'s runtime
environment ``encloses'' the \texttt{deal} and \texttt{shuffle}
functions. Both \texttt{deal} and \texttt{shuffle} can work closely with
the objects contained in the enclosing environment, but almost nothing
else can. The enclosing environment is not on the search path for any
other R function or environment.

You may have noticed that \texttt{deal} and \texttt{shuffle} still
update the \texttt{deck} object in the global environment. Don't worry,
we're about to change that. We want \texttt{deal} and \texttt{shuffle}
to work exclusively with the objects in the parent (enclosing)
environment of their runtime environments. Instead of having each
function reference the global environment to update \texttt{deck}, you
can have them reference their parent environment at runtime, as shown in
Figure~\ref{fig-closure3}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setup }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(deck) \{}
\NormalTok{  DECK }\OtherTok{\textless{}{-}}\NormalTok{ deck}

\NormalTok{  DEAL }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    card }\OtherTok{\textless{}{-}}\NormalTok{ deck[}\DecValTok{1}\NormalTok{, ]}
    \FunctionTok{assign}\NormalTok{(}\StringTok{"deck"}\NormalTok{, deck[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, ], }\AttributeTok{envir =} \FunctionTok{parent.env}\NormalTok{(}\FunctionTok{environment}\NormalTok{()))}
\NormalTok{    card}
\NormalTok{  \}}

\NormalTok{  SHUFFLE }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{    random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{)}
    \FunctionTok{assign}\NormalTok{(}\StringTok{"deck"}\NormalTok{, DECK[random, ], }\AttributeTok{envir =} \FunctionTok{parent.env}\NormalTok{(}\FunctionTok{environment}\NormalTok{()))}
\NormalTok{ \}}

 \FunctionTok{list}\NormalTok{(}\AttributeTok{deal =}\NormalTok{ DEAL, }\AttributeTok{shuffle =}\NormalTok{ SHUFFLE)}
\NormalTok{\}}

\NormalTok{cards }\OtherTok{\textless{}{-}} \FunctionTok{setup}\NormalTok{(deck)}
\NormalTok{deal }\OtherTok{\textless{}{-}}\NormalTok{ cards}\SpecialCharTok{$}\NormalTok{deal}
\NormalTok{shuffle }\OtherTok{\textless{}{-}}\NormalTok{ cards}\SpecialCharTok{$}\NormalTok{shuffle}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0609.png}}

}

\caption{\label{fig-closure3}When you change your code, deal and shuffle
will go from updating the global environment (left) to updating their
parent environment (right).}

\end{figure}%

We finally have a self-contained card game. You can delete (or modify)
the global copy of \texttt{deck} as much as you want and still play
cards. \texttt{deal} and \texttt{shuffle} will use the pristine,
protected copy of \texttt{deck}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{(deck)}

\FunctionTok{shuffle}\NormalTok{()}

\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\# face   suit value}
\DocumentationTok{\#\#  ace hearts     1}

\FunctionTok{deal}\NormalTok{()}
\DocumentationTok{\#\# face  suit value}
\DocumentationTok{\#\# jack clubs    11}
\end{Highlighting}
\end{Shaded}

Blackjack!

\section{Summary}\label{summary-5}

R saves its objects in an environment system that resembles your
computer's file system. If you understand this system, you can predict
how R will look up objects. If you call an object at the command line, R
will look for the object in the global environment and then the parents
of the global environment, working its way up the environment tree one
environment at a time.

R will use a slightly different search path when you call an object from
inside of a function. When you run a function, R creates a new
environment to execute commands in. This environment will be a child of
the environment where the function was originally defined. This may be
the global environment, but it also may not be. You can use this
behavior to create closures, which are functions linked to objects in
protected environments.

As you become familiar with R's environment system, you can use it to
produce elegant results, like we did here. However, the real value of
understanding the environment system comes from knowing how R functions
do their job. You can use this knowledge to figure out what is going
wrong when a function does not perform as expected.

\section{Project 2 Wrap-up}\label{project-2-wrap-up}

You now have full control over the data sets and values that you load
into R. You can store data as R objects, you can retrieve and manipulate
data values at will, and you can even predict how R will store and look
up your objects in your computer's memory.

You may not realize it yet, but your expertise makes you a powerful,
computer-augmented data user. You can use R to save and work with larger
data sets than you could otherwise handle. So far we've only worked with
\texttt{deck}, a small data set; but you can use the same techniques to
work with any data set that fits in your computer's memory.

However, storing data is not the only logistical task that you will face
as a data scientist. You will often want to do tasks with your data that
are so complex or repetitive that they are difficult to do without a
computer. Some of the things can be done with functions that already
exist in R and its packages, but others cannot. You will be the most
versatile as a data scientist if you can write your own programs for
computers to follow. R can help you do this. When you are ready,
\hyperref[sec-project-slots]{Project 3: Slot Machine} will teach you the
most useful skills for writing programs in R.

\part{Project 3: Slot Machine}

Slot machines are the most popular game in modern casinos. If you've
never seen one, a slot machine resembles an arcade game that has a lever
on its side. For a small fee you can pull the lever, and the machine
will generate a random combination of three symbols. If the correct
combination appears, you can win a prize, maybe even the jackpot.

Slot machines make fantastic profits for casinos because they offer a
very low payout rate. In many games, such as Blackjack and Roulette, the
odds are only slightly stacked in the casino's favor. In the long run,
the casino pays back 97 to 98 cents in prizes of every dollar that a
gambler spends on these games. With slot machines, it is typical for a
casino to only pay back 90 to 95 cents---and the casino keeps the rest.
If this seems underhanded, keep in mind that slot machines are one of
the most popular games at a casino; few people seem to mind. And if you
consider that state lotteries have payout rates that are much closer to
50 cents on the dollar, slot machines don't look that bad.

In this project, you will build a real, working slot machine modeled
after some real life Video Lottery Terminals from Manitoba, Canada. The
terminals were a source of scandal in the 1990s. You'll get to the
bottom of this scandal by writing a program that recreates the slot
machines. You'll then do some calculations and run some simulations that
reveal the true payout rate of the machines.

This project will teach you how to write programs and run simulations in
R. You will also learn how to:

\begin{itemize}
\tightlist
\item
  Use a practical strategy to design programs
\item
  Use \texttt{if} and \texttt{else} statements to tell R what to do when
\item
  Create lookup tables to find values
\item
  Use \texttt{for}, \texttt{while}, and \texttt{repeat} loops to
  automate repetitive operations
\item
  Use S3 methods, R's version of Object-Oriented Programming
\item
  Measure the speed of R code
\item
  Write fast, vectorized R code
\end{itemize}

\chapter{Programs}\label{sec-programs}

In this chapter, you will build a real, working slot machine that you
can play by running an R function. When you're finished, you'll be able
to play it like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# 0 0 DD}
\DocumentationTok{\#\# $0}

\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# 7 7 7}
\DocumentationTok{\#\# $80}
\end{Highlighting}
\end{Shaded}

The \texttt{play} function will need to do two things. First, it will
need to randomly generate three symbols; and, second, it will need to
calculate a prize based on those symbols.

The first step is easy to simulate. You can randomly generate three
symbols with the \texttt{sample} function---just like you randomly
``rolled'' two dice in \hyperref[sec-project-dice]{Project 1: Weighted
Dice}. The following function generates three symbols from a group of
common slot machine symbols: diamonds (\texttt{DD}), sevens
(\texttt{7}), triple bars (\texttt{BBB}), double bars (\texttt{BB}),
single bars (\texttt{B}), cherries (\texttt{C}), and zeroes
(\texttt{0}). The symbols are selected randomly, and each symbol appears
with a different probability:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get\_symbols }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  wheel }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"}\NormalTok{, }\StringTok{"7"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"0"}\NormalTok{)}
  \FunctionTok{sample}\NormalTok{(wheel, }\AttributeTok{size =} \DecValTok{3}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }
    \AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.03}\NormalTok{, }\FloatTok{0.03}\NormalTok{, }\FloatTok{0.06}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.25}\NormalTok{, }\FloatTok{0.01}\NormalTok{, }\FloatTok{0.52}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You can use \texttt{get\_symbols} to generate the symbols used in your
slot machine:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{get\_symbols}\NormalTok{()}
\DocumentationTok{\#\# "BBB" "0"   "C"  }

\FunctionTok{get\_symbols}\NormalTok{()}
\DocumentationTok{\#\# "0" "0" "0"}

\FunctionTok{get\_symbols}\NormalTok{()}
\DocumentationTok{\#\# "7" "0" "B"}
\end{Highlighting}
\end{Shaded}

\texttt{get\_symbols} uses the probabilities observed in a group of
video lottery terminals from Manitoba, Canada. These slot machines
became briefly controversial in the 1990s, when a reporter decided to
test their payout rate. The machines appeared to pay out only 40 cents
on the dollar, even though the manufacturer claimed they would pay out
92 cents on the dollar. The original data collected on the machines and
a description of the controversy is available online in
\href{http://bit.ly/jse_Braun}{a journal article by W. John Braun}. The
controversy died down when additional testing showed that the
manufacturer was correct.

The Manitoba slot machines use the complicated payout scheme shown in
Table~\ref{tbl-prizes}. A player will win a prize if he gets:

\begin{itemize}
\tightlist
\item
  Three of the same type of symbol (except for three zeroes)
\item
  Three bars (of mixed variety)
\item
  One or more cherries
\end{itemize}

Otherwise, the player receives no prize.

The monetary value of the prize is determined by the exact combination
of symbols and is further modified by the presence of diamonds. Diamonds
are treated like ``wild cards,'' which means they can be considered any
other symbol if it would increase a player's prize. For example, a
player who rolls \texttt{7} \texttt{7} \texttt{DD} would earn a prize
for getting three sevens. There is one exception to this rule, however:
a diamond cannot be considered a cherry unless the player also gets one
real cherry. This prevents a dud roll like, \texttt{0} \texttt{DD}
\texttt{0} from being scored as \texttt{0} \texttt{C} \texttt{0}.

Diamonds are also special in another way. Every diamond that appears in
a combination doubles the amount of the final prize. So \texttt{7}
\texttt{7} \texttt{DD} would actually be scored \emph{higher} than
\texttt{7} \texttt{7} \texttt{7}. Three sevens would earn you \$80, but
two sevens and a diamond would earn you \$160. One seven and two
diamonds would be even better, resulting in a prize that has been
doubled twice, or \$320. A jackpot occurs when a player rolls
\texttt{DD} \texttt{DD} \texttt{DD}. Then a player earns \$100 doubled
three times, which is \$800.

\begin{longtable}[]{@{}ll@{}}
\caption{Each play of the slot machine costs \$1. A player's symbols
determine how much they win. Diamonds (\texttt{DD}) are wild, and each
diamond doubles the final prize. * = any
symbol}\label{tbl-prizes}\tabularnewline
\toprule\noalign{}
Combination & Prize(\$) \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Combination & Prize(\$) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{DD\ \ DD\ \ DD} & 100 \\
\texttt{7\ \ 7\ \ 7} & 80 \\
\texttt{BBB\ \ BBB\ \ BBB} & 40 \\
\texttt{BB\ \ BB\ \ BB} & 25 \\
\texttt{B\ \ B\ \ B} & 10 \\
\texttt{C\ \ C\ \ C} & 10 \\
Any combination of bars & 5 \\
\texttt{C\ \ C\ \ *} & 5 \\
\texttt{C\ \ *\ \ C} & 5 \\
\texttt{*\ \ C\ \ C} & 5 \\
\texttt{C\ \ *\ \ *} & 2 \\
\texttt{*\ \ C\ \ *} & 2 \\
\texttt{*\ \ *\ \ C} & 2 \\
\end{longtable}

To create your \texttt{play} function, you will need to write a program
that can take the output of \texttt{get\_symbols} and calculate the
correct prize based on Table~\ref{tbl-prizes}.

In R, programs are saved either as R scripts or as functions. We'll save
your program as a function named \texttt{score}. When you are finished,
you will be able to use \texttt{score} to calculate a prize like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{score}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"DD"}\NormalTok{, }\StringTok{"DD"}\NormalTok{, }\StringTok{"DD"}\NormalTok{))}
\DocumentationTok{\#\# 800}
\end{Highlighting}
\end{Shaded}

After that it will be easy to create the full slot machine, like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{get\_symbols}\NormalTok{()}
  \FunctionTok{print}\NormalTok{(symbols)}
  \FunctionTok{score}\NormalTok{(symbols)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

The \texttt{print} command prints its output to the console window,
which makes \texttt{print} a useful way to display messages from within
the body of a function.

\end{tcolorbox}

You may notice that \texttt{play} calls a new function, \texttt{print}.
This will help \texttt{play} display the three slot machine symbols,
since they do not get returned by the last line of the function. The
\texttt{print} command prints its output to the console window -- even
if R calls it from within a function.

In \hyperref[sec-project-dice]{Project 1: Weighted Dice}, I encouraged
you to write all of your R code in an R script, a text file where you
can compose and save code. That advice will become very important as you
work through this chapter. Remember that you can open an R script in
RStudio by going to the menu bar and clicking on File \textgreater{} New
File \textgreater{} R Script.

\section{Strategy}\label{strategy}

Scoring slot-machine results is a complex task that will require a
complex algorithm. You can make this, and other coding tasks, easier by
using a simple strategy:

\begin{itemize}
\tightlist
\item
  Break complex tasks into simple subtasks.
\item
  Use concrete examples.
\item
  Describe your solutions in English, then convert them to R.
\end{itemize}

Let's start by looking at how you can divide a program into subtasks
that are simple to work with.

A program is a set of step-by-step instructions for your computer to
follow. Taken together, these instructions may accomplish something very
sophisticated. Taken apart, each individual step will likely be simple
and straightforward.

You can make coding easier by identifying the individual steps or
subtasks within your program. You can then work on each subtask
separately. If a subtask seems complicated, try to divide it again into
even subtasks that are even more simple. You can often reduce an R
program into substasks so simple that each can be performed with a
preexisting function.

R programs contain two types of subtasks: sequential steps and parallel
cases.

\subsection{Sequential Steps}\label{sequential-steps}

One way to subdivide a program is into a series of sequential steps. The
\texttt{play} function takes the approach, shown in
Figure~\ref{fig-subdivide1}. First, it generates three symbols (step 1),
then it displays them in the console window (step 2), and then it scores
them (step 3):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}

  \CommentTok{\# step 1: generate symbols}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{get\_symbols}\NormalTok{()}

  \CommentTok{\# step 2: display the symbols}
  \FunctionTok{print}\NormalTok{(symbols)}

  \CommentTok{\# step 3: score the symbols}
  \FunctionTok{score}\NormalTok{(symbols)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To have R execute steps in sequence, place the steps one after another
in an R script or function body.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0701.png}}

}

\caption{\label{fig-subdivide1}The play function uses a series of
steps.}

\end{figure}%

\subsection{Parallel Cases}\label{parallel-cases}

Another way to divide a task is to spot groups of similar cases within
the task. Some tasks require different algorithms for different groups
of input. If you can identify those groups, you can work out their
algorithms one at a time.

For example, \texttt{score} will need to calculate the prize one way if
\texttt{symbols} contains three of a kind (In that case, \texttt{score}
will need to match the common symbol to a prize). \texttt{score} will
need to calculate the prize a second way if the symbols are all bars (In
that case, \texttt{score} can just assign a prize of \$5). And, finally,
\texttt{score} will need to calculate the prize in a third way if the
symbols do not contain three of a kind or all bars (In that case,
\texttt{score} must count the number of cherries present).
\texttt{score} will never use all three of these algorithms at once; it
will always choose just one algorithm to run based on the combination of
symbols.

Diamonds complicate all of this because diamonds can be treated as wild
cards. Let's ignore that for now and focus on the simpler case where
diamonds double the prize but are not wilds. \texttt{score} can double
the prize as necessary after it runs one of the following algorithms, as
shown in Figure~\ref{fig-subdivide2}.

Adding the \texttt{score} cases to the \texttt{play} steps reveals a
strategy for the complete slot machine program, as shown in
Figure~\ref{fig-subdivide3}.

We've already solved the first few steps in this strategy. Our program
can get three slot machine symbols with the \texttt{get\_symbols}
function. Then it can display the symbols with the \texttt{print}
function. Now let's examine how the program can handle the parallel
score cases.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0702.png}}

}

\caption{\label{fig-subdivide2}The score function must distinguish
between parallel cases.}

\end{figure}%

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0703.png}}

}

\caption{\label{fig-subdivide3}The complete slot machine simulation will
involve subtasks that are arranged both in series and in parallel.}

\end{figure}%

\section{if Statements}\label{if-statements}

Linking cases together in parallel requires a bit of structure; your
program faces a fork in the road whenever it must choose between cases.
You can help the program navigate this fork with an \texttt{if}
statement.

An \texttt{if} statement tells R to do a certain task for a certain
case. In English you would say something like, ``If this is true, do
that.'' In R, you would say:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (this) \{}
\NormalTok{  that}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{this} object should be a logical test or an R expression
that evaluates to a single \texttt{TRUE} or \texttt{FALSE}. If
\texttt{this} evaluates to \texttt{TRUE}, R will run all of the code
that appears between the braces that follow the \texttt{if} statement
(i.e., between the \texttt{\{} and \texttt{\}} symbols). If
\texttt{this} evaluates to \texttt{FALSE}, R will skip the code between
the braces without running it.

For example, you could write an \texttt{if} statement that ensures some
object, \texttt{num}, is positive:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (num }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{) \{}
\NormalTok{  num }\OtherTok{\textless{}{-}}\NormalTok{ num }\SpecialCharTok{*} \SpecialCharTok{{-}}\DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If \texttt{num\ \textless{}\ 0} is \texttt{TRUE}, R will multiply
\texttt{num} by negative one, which will make \texttt{num} positive:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{2}

\ControlFlowTok{if}\NormalTok{ (num }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{) \{}
\NormalTok{  num }\OtherTok{\textless{}{-}}\NormalTok{ num }\SpecialCharTok{*} \SpecialCharTok{{-}}\DecValTok{1}
\NormalTok{\}}

\NormalTok{num}
\DocumentationTok{\#\# 2}
\end{Highlighting}
\end{Shaded}

If \texttt{num\ \textless{}\ 0} is \texttt{FALSE}, R will do nothing and
\texttt{num} will remain as it is---positive (or zero):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num }\OtherTok{\textless{}{-}} \DecValTok{4}

\ControlFlowTok{if}\NormalTok{ (num }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{) \{}
\NormalTok{  num }\OtherTok{\textless{}{-}}\NormalTok{ num }\SpecialCharTok{*} \SpecialCharTok{{-}}\DecValTok{1}
\NormalTok{\}}

\NormalTok{num}
\DocumentationTok{\#\# 4}
\end{Highlighting}
\end{Shaded}

The condition of an \texttt{if} statement must evaluate to a
\emph{single} \texttt{TRUE} or \texttt{FALSE}. If the condition creates
a vector of \texttt{TRUE}s and \texttt{FALSE}s (which is easier to make
than you may think), your \texttt{if} statement will print a warning
message and use only the first element of the vector. Remember that you
can condense vectors of logical values to a single \texttt{TRUE} or
\texttt{FALSE} with the functions \texttt{any} and \texttt{all}.

You don't have to limit your \texttt{if} statements to a single line of
code; you can include as many lines as you like between the braces. For
example, the following code uses many lines to ensure that \texttt{num}
is positive. The additional lines print some informative statements if
\texttt{num} begins as a negative number. R will skip the entire code
block---\texttt{print} statements and all---if \texttt{num} begins as a
positive number:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{1}

\ControlFlowTok{if}\NormalTok{ (num }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{) \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"num is negative."}\NormalTok{)}
  \FunctionTok{print}\NormalTok{(}\StringTok{"Don\textquotesingle{}t worry, I\textquotesingle{}ll fix it."}\NormalTok{)}
\NormalTok{  num }\OtherTok{\textless{}{-}}\NormalTok{ num }\SpecialCharTok{*} \SpecialCharTok{{-}}\DecValTok{1}
  \FunctionTok{print}\NormalTok{(}\StringTok{"Now num is positive."}\NormalTok{)}
\NormalTok{\}}
\DocumentationTok{\#\# "num is negative."}
\DocumentationTok{\#\# "Don\textquotesingle{}t worry, I\textquotesingle{}ll fix it."}
\DocumentationTok{\#\# "Now num is positive."}

\NormalTok{num}
\DocumentationTok{\#\# 1}
\end{Highlighting}
\end{Shaded}

Try the following quizzes to develop your understanding of \texttt{if}
statements.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Quiz A}\vspace{3mm}

What will this return?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}
\ControlFlowTok{if}\NormalTok{ (}\DecValTok{3} \SpecialCharTok{==} \DecValTok{3}\NormalTok{) \{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{\}}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

The code will return the number 2. \texttt{x} begins as 1, and then R
encounters the \texttt{if} statement. Since the condition evaluates to
\texttt{TRUE}, R will run \texttt{x\ \textless{}-\ 2}, changing the
value of \texttt{x}.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Quiz B}\vspace{3mm}

What will this return?

\begin{verbatim}
```r
x <- 1
if (TRUE) {
  x <- 2
}
x
\end{verbatim}

\end{tcolorbox}

This code will also return the number 2. It works the same as the code
in Quiz A, except the condition in this statement is already
\texttt{TRUE}. R doesn't even need to evaluate it. As a result, the code
inside the \texttt{if} statement will be run, and \texttt{x} will be set
to 2.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Quiz C}\vspace{3mm}

What will this return?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}
\ControlFlowTok{if}\NormalTok{ (x }\SpecialCharTok{==} \DecValTok{1}\NormalTok{) \{}
\NormalTok{  x }\OtherTok{\textless{}{-}} \DecValTok{2}
  \ControlFlowTok{if}\NormalTok{ (x }\SpecialCharTok{==} \DecValTok{1}\NormalTok{) \{}
\NormalTok{    x }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{  \}}
\NormalTok{\}}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

Once again, the code will return the number 2. \texttt{x} starts out as
1, and the condition of the first \texttt{if} statement will evaluate to
\texttt{TRUE}, which causes R to run the code in the body of the
\texttt{if} statement. First, R sets \texttt{x} equal to 2, then R
evaluates the second \texttt{if} statement, which is in the body of the
first. This time \texttt{x\ ==\ 1} will evaluate to \texttt{FALSE}
because \texttt{x} now equals 2. As a result, R ignores
\texttt{x\ \textless{}-\ 3} and exits both \texttt{if} statements.

\section{else Statements}\label{else-statements}

\texttt{if} statements tell R what to do when your condition is
\emph{true}, but you can also tell R what to do when the condition is
\emph{false}. \texttt{else} is a counterpart to \texttt{if} that extends
an \texttt{if} statement to include a second case. In English, you would
say, ``If this is true, do plan A; else do plan B.'' In R, you would
say:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (this) \{}
\NormalTok{  Plan A}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  Plan B}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When \texttt{this} evaluates to \texttt{TRUE}, R will run the code in
the first set of braces, but not the code in the second. When
\texttt{this} evaluates to \texttt{FALSE}, R will run the code in the
second set of braces, but not the first. You can use this arrangement to
cover all of the possible cases. For example, you could write some code
that rounds a decimal to the nearest integer.

Start with a decimal:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FloatTok{3.14}
\end{Highlighting}
\end{Shaded}

Then isolate the decimal component with \texttt{trunc}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dec }\OtherTok{\textless{}{-}}\NormalTok{ a }\SpecialCharTok{{-}} \FunctionTok{trunc}\NormalTok{(a)}
\NormalTok{dec}
\DocumentationTok{\#\# 0.14}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

\texttt{trunc} takes a number and returns only the portion of the number
that appears to the left of the decimal place (i.e., the integer part of
the number).

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

\texttt{a\ -\ trunc(a)} is a convenient way to return the decimal part
of \texttt{a}.

\end{tcolorbox}

Then use an \texttt{if\ else} tree to round the number (either up or
down):

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (dec }\SpecialCharTok{\textgreater{}=} \FloatTok{0.5}\NormalTok{) \{}
\NormalTok{  a }\OtherTok{\textless{}{-}} \FunctionTok{trunc}\NormalTok{(a) }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  a }\OtherTok{\textless{}{-}} \FunctionTok{trunc}\NormalTok{(a)}
\NormalTok{\}}

\NormalTok{a}
\DocumentationTok{\#\# 3}
\end{Highlighting}
\end{Shaded}

If your situation has more than two mutually exclusive cases, you can
string multiple \texttt{if} and \texttt{else} statements together by
adding a new \texttt{if} statement immediately after \texttt{else}. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{1}

\ControlFlowTok{if}\NormalTok{ (a }\SpecialCharTok{\textgreater{}}\NormalTok{ b) \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"A wins!"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (a }\SpecialCharTok{\textless{}}\NormalTok{ b) \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"B wins!"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"Tie."}\NormalTok{)}
\NormalTok{\}}
\DocumentationTok{\#\# "Tie."}
\end{Highlighting}
\end{Shaded}

R will work through the \texttt{if} conditions until one evaluates to
\texttt{TRUE}, then R will ignore any remaining \texttt{if} and
\texttt{else} clauses in the tree. If no conditions evaluate to
\texttt{TRUE}, R will run the final \texttt{else} statement.

If two \texttt{if} statements describe mutually exclusive events, it is
better to join the \texttt{if} statements with an \texttt{else\ if} than
to list them separately. This lets R ignore the second \texttt{if}
statement whenever the first returns a \texttt{TRUE}, which saves work.

You can use \texttt{if} and \texttt{else} to link the subtasks in your
slot-machine function. Open a fresh R script, and copy this code into
it. The code will be the skeleton of our final \texttt{score} function.
Compare it to the flow chart for \texttt{score} in
Figure~\ref{fig-subdivide2}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ ( }\CommentTok{\# Case 1: all the }\hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# look up the }\hspace*{\fill}\NormalTok{\circled{3}}
\ErrorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ ( }\CommentTok{\# Case 2: all }\hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# assign }\hspace*{\fill}\NormalTok{\circled{4}}
\ErrorTok{\}} \ControlFlowTok{else}\NormalTok{ \{}
  \CommentTok{\# count }\hspace*{\fill}\NormalTok{\circled{5}}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# calculate a }\hspace*{\fill}\NormalTok{\circled{7}}
\NormalTok{\}}

\CommentTok{\# count }\hspace*{\fill}\NormalTok{\circled{6}}
\CommentTok{\# double the prize if }\hspace*{\fill}\NormalTok{\circled{8}}
\end{Highlighting}
\end{Shaded}

Our skeleton is rather incomplete; there are many sections that are just
code comments instead of real code. However, we've reduced the program
to eight simple subtasks:

\textbf{\textless1\textgreater{}} - Test whether the symbols are three
of a kind.\\
\textbf{\textless2\textgreater{}} - Test whether the symbols are all
bars.\\
\textbf{\textless3\textgreater{}} - Look up the prize for three of a
kind based on the common symbol.\\
\textbf{\textless4\textgreater{}} - Assign a prize of \$5.\\
\textbf{\textless5\textgreater{}} - Count the number of cherries.\\
\textbf{\textless6\textgreater{}} - Count the number of diamonds.\\
\textbf{\textless7\textgreater{}} - Calculate a prize based on the
number of cherries.\\
\textbf{\textless8\textgreater{}} - Adjust the prize for diamonds.

If you like, you can reorganize your flow chart around these tasks, as
in Figure~\ref{fig-subdivide4}. The chart will describe the same
strategy, but in a more precise way. I'll use a diamond shape to
symbolize an \texttt{if\ else} decision.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_0704.png}}

}

\caption{\label{fig-subdivide4}score can navigate three cases with two
if else decisions. We can also break some of our tasks into two steps.}

\end{figure}%

Now we can work through the subtasks one at a time, adding R code to the
\texttt{if} tree as we go. Each subtask will be easy to solve if you set
up a concrete example to work with and try to describe a solution in
English before coding in R.

The first subtask asks you to test whether the symbols are three of a
kind. How should you begin writing the code for this subtask?

You know that the final \texttt{score} function will look something like
this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{score }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(symbols) \{}

  \CommentTok{\# calculate a prize}

\NormalTok{  prize}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Its argument, \texttt{symbols}, will be the output of
\texttt{get\_symbols}, a vector that contains three character strings.
You could start writing \texttt{score} as I have written it, by defining
an object named \texttt{score} and then slowly filling in the body of
the function. However, this would be a bad idea. The eventual function
will have eight separate parts, and it will not work correctly until
\emph{all} of those parts are written (and themselves work correctly).
This means you would have to write the entire \texttt{score} function
before you could test any of the subtasks. If \texttt{score} doesn't
work---which is very likely---you will not know which subtask needs
fixed.

You can save yourself time and headaches if you focus on one subtask at
a time. For each subtask, create a concrete example that you can test
your code on. For example, you know that \texttt{score} will need to
work on a vector named \texttt{symbols} that contains three character
strings. If you make a real vector named \texttt{symbols}, you can run
the code for many of your subtasks on the vector as you go:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"7"}\NormalTok{, }\StringTok{"7"}\NormalTok{, }\StringTok{"7"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If a piece of code does not work on \texttt{symbols}, you will know that
you need to fix it before you move on. You can change the value of
\texttt{symbols} from subtask to subtask to ensure that your code works
in every situation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"C"}\NormalTok{, }\StringTok{"DD"}\NormalTok{, }\StringTok{"0"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Only combine your subtasks into a \texttt{score} function once each
subtask works on a concrete example. If you follow this plan, you will
spend more time using your functions and less time trying to figure out
why they do not work.

After you set up a concrete example, try to describe how you will do the
subtask in English. The more precisely you can describe your solution,
the easier it will be to write your R code.

Our first subtask asks us to ``test whether the symbols are three of a
kind.'' This phrase does not suggest any useful R code to me. However, I
could describe a more precise test for three of a kind: three symbols
will be the same if the first symbol is equal to the second and the
second symbol is equal to the third. Or, even more precisely:

\emph{A vector named \texttt{symbols} will contain three of the same
symbol if the first element of \texttt{symbols} is equal to the second
element of \texttt{symbols} and the second element of \texttt{symbols}
is equal to the third element of \texttt{symbols}}.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Write a Test}\vspace{3mm}

Turn the preceding statement into a logical test written in R. Use your
knowledge of logical tests, Boolean operators, and subsetting from
\hyperref[sec-r-notation]{R Notation}. The test should work with the
vector \texttt{symbols} and return a \texttt{TRUE} \emph{if and only if}
each element in \texttt{symbols} is the same. Be sure to test your code
on \texttt{symbols}.

\end{tcolorbox}

Here are a couple of ways to test that \texttt{symbols} contains three
of the same symbol. The first method parallels the English suggestion
above, but there are other ways to do the same test. There is no right
or wrong answer, so long as your solution works, which is easy to check
because you've created a vector named \texttt{symbols}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols}
\DocumentationTok{\#\#  "7" "7" "7"}

\NormalTok{symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\DocumentationTok{\#\# TRUE}

\NormalTok{symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\DocumentationTok{\#\# TRUE}

\FunctionTok{all}\NormalTok{(symbols }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{])}
\DocumentationTok{\#\# TRUE}
\end{Highlighting}
\end{Shaded}

As your vocabulary of R functions broadens, you'll think of more ways to
do basic tasks. One method that I like for checking three of a kind is:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(}\FunctionTok{unique}\NormalTok{(symbols) }\SpecialCharTok{==} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{unique} function returns every unique term that appears in a
vector. If your \texttt{symbols} vector contains three of a kind (i.e.,
one unique term that appears three times), then \texttt{unique(symbols)}
will return a vector of length \texttt{1}.

Now that you have a working test, you can add it to your slot-machine
script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}

\ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# look up the prize}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ ( }\CommentTok{\# Case 2: all bars ) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# assign $5}
\ErrorTok{\}} \ControlFlowTok{else}\NormalTok{ \{}
  \CommentTok{\# count cherries}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# calculate a prize}
\NormalTok{\}}

\CommentTok{\# count diamonds}
\CommentTok{\# double the prize if necessary}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

\texttt{\&\&} and \texttt{\textbar{}\textbar{}} behave like \texttt{\&}
and \texttt{\textbar{}} but can sometimes be more efficient. The double
operators will not evaluate the second test in a pair of tests if the
first test makes the result clear. For example, if
\texttt{symbols{[}1{]}} does not equal \texttt{symbols{[}2{]}} in the
next expression, \texttt{\&\&} will not evaluate
\texttt{symbols{[}2{]}\ ==\ symbols{[}3{]}}; it can immediately return a
\texttt{FALSE} for the whole expression (because
\texttt{FALSE\ \&\ TRUE} and \texttt{FALSE\ \&\ FALSE} both evaluate to
\texttt{FALSE}). This efficiency can speed up your programs; however,
double operators are not appropriate everywhere. \texttt{\&\&} and
\texttt{\textbar{}\textbar{}} are not vectorized, which means they can
only handle a single logical test on each side of the operator.

\end{tcolorbox}

The second prize case occurs when all the symbols are a type of bar, for
example, \texttt{B}, \texttt{BB}, and \texttt{BBB}. Let's begin by
creating a concrete example to work with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{, }\StringTok{"BB"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Test for All Bars}\vspace{3mm}

Use R's logical and Boolean operators to write a test that will
determine whether a vector named \texttt{symbols} contains only symbols
that are a type of bar. Check whether your test works with our example
\texttt{symbols} vector. Remember to describe how the test should work
in English, and then convert the solution to R.

\end{tcolorbox}

As with many things in R, there are multiple ways to test whether
\texttt{symbols} contains all bars. For example, you could write a very
long test that uses multiple Boolean operators, like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==} \StringTok{"B"} \SpecialCharTok{|}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==} \StringTok{"BB"} \SpecialCharTok{|}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==} \StringTok{"BBB"}\NormalTok{) }\SpecialCharTok{\&}
\NormalTok{  (symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==} \StringTok{"B"} \SpecialCharTok{|}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==} \StringTok{"BB"} \SpecialCharTok{|}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==} \StringTok{"BBB"}\NormalTok{) }\SpecialCharTok{\&}
\NormalTok{  (symbols[}\DecValTok{3}\NormalTok{] }\SpecialCharTok{==} \StringTok{"B"} \SpecialCharTok{|}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{] }\SpecialCharTok{==} \StringTok{"BB"} \SpecialCharTok{|}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{] }\SpecialCharTok{==} \StringTok{"BBB"}\NormalTok{)}
\DocumentationTok{\#\# TRUE}
\end{Highlighting}
\end{Shaded}

However, this is not a very efficient solution, because R has to run
nine logical tests (and you have to type them). You can often replace
multiple \texttt{\textbar{}} operators with a single \texttt{\%in\%}.
Also, you can check that a test is true for each element in a vector
with \texttt{all}. These two changes shorten the preceding code to:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{all}\NormalTok{(symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{))}
\DocumentationTok{\#\# TRUE}
\end{Highlighting}
\end{Shaded}

Let's add this code to our script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\NormalTok{bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# look up the prize}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# assign $5}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \CommentTok{\# count cherries}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# calculate a prize}
\NormalTok{\}}

\CommentTok{\# count diamonds}
\CommentTok{\# double the prize if necessary}
\end{Highlighting}
\end{Shaded}

You may have noticed that I split this test up into two steps,
\texttt{bars} and \texttt{all(bars)}. That's just a matter of personal
preference. Wherever possible, I like to write my code so it can be read
with function and object names conveying what they do.

You also may have noticed that our test for Case 2 will capture some
symbols that should be in Case 1 because they contain three of a kind:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"B"}\NormalTok{)}
\FunctionTok{all}\NormalTok{(symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{))}
\DocumentationTok{\#\# TRUE}
\end{Highlighting}
\end{Shaded}

That won't be a problem, however, because we've connected our cases with
\texttt{else\ if} in the \texttt{if} tree. As soon as R comes to a case
that evaluates to \texttt{TRUE}, it will skip over the rest of the tree.
Think of it this way: each \texttt{else} tells R to only run the code
that follows it \emph{if none of the previous conditions have been met}.
So when we have three of the same type of bar, R will evaluate the code
for Case 1 and then skip the code for Case 2 (and Case 3).

Our next subtask is to assign a prize for \texttt{symbols}. When the
\texttt{symbols} vector contains three of the same symbol, the prize
will depend on which symbol there are three of. If there are three
\texttt{DD}s, the prize will be \$100; if there are three \texttt{7}s,
the prize will be \$80; and so on.

This suggests another \texttt{if} tree. You could assign a prize with
some code like this:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{  symbol }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{]}
  \ControlFlowTok{if}\NormalTok{ (symbol }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{800}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (symbol }\SpecialCharTok{==} \StringTok{"7"}\NormalTok{) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{80}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (symbol }\SpecialCharTok{==} \StringTok{"BBB"}\NormalTok{) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{40}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (symbol }\SpecialCharTok{==} \StringTok{"BB"}\NormalTok{) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (symbol }\SpecialCharTok{==} \StringTok{"B"}\NormalTok{) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (symbol }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (symbol }\SpecialCharTok{==} \StringTok{"0"}\NormalTok{) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

While this code will work, it is a bit long to write and read, and it
may require R to perform multiple logical tests before delivering the
correct prize. We can do better with a different method.

\section{Lookup Tables}\label{lookup-tables}

Very often in R, the simplest way to do something will involve
subsetting. How could you use subsetting here? Since you know the exact
relationship between the symbols and their prizes, you can create a
vector that captures this information. This vector can store symbols as
names and prize values as elements:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }
  \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{payouts}
\DocumentationTok{\#\#  DD   7 BBB  BB   B   C   0 }
\DocumentationTok{\#\# 100  80  40  25  10  10   0 }
\end{Highlighting}
\end{Shaded}

Now you can extract the correct prize for any symbol by subsetting the
vector with the symbol's name:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{payouts[}\StringTok{"DD"}\NormalTok{]}
\DocumentationTok{\#\#  DD }
\DocumentationTok{\#\# 100 }

\NormalTok{payouts[}\StringTok{"B"}\NormalTok{]}
\DocumentationTok{\#\#  B}
\DocumentationTok{\#\# 10}
\end{Highlighting}
\end{Shaded}

If you want to leave behind the symbol's name when subsetting, you can
run the \texttt{unname} function on the output:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unname}\NormalTok{(payouts[}\StringTok{"DD"}\NormalTok{])}
\DocumentationTok{\#\# 100 }
\end{Highlighting}
\end{Shaded}

\texttt{unname} returns a copy of an object with the names attribute
removed.

\texttt{payouts} is a type of \emph{lookup table}, an R object that you
can use to look up values. Subsetting \texttt{payouts} provides a simple
way to find the prize for a symbol. It doesn't take many lines of code,
and it does the same amount of work whether your symbol is \texttt{DD}
or \texttt{0}. You can create lookup tables in R by creating named
objects that can be subsetted in clever ways.

Sadly, our method is not quite automatic; we need to tell R which symbol
to look up in \texttt{payouts}. Or do we? What would happen if you
subsetted \texttt{payouts} by \texttt{symbols{[}1{]}}? Give it a try:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"7"}\NormalTok{, }\StringTok{"7"}\NormalTok{, }\StringTok{"7"}\NormalTok{)}
\NormalTok{symbols[}\DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\# "7"}

\NormalTok{payouts[symbols[}\DecValTok{1}\NormalTok{]]}
\DocumentationTok{\#\#  7 }
\DocumentationTok{\#\# 80 }

\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"C"}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"C"}\NormalTok{)}
\NormalTok{payouts[symbols[}\DecValTok{1}\NormalTok{]]}
\DocumentationTok{\#\#  C }
\DocumentationTok{\#\# 10 }
\end{Highlighting}
\end{Shaded}

You don't need to know the exact symbol to look up because you can tell
R to look up whichever symbol happens to be in \texttt{symbols}. You can
find this symbol with \texttt{symbols{[}1{]}}, \texttt{symbols{[}2{]}},
or \texttt{symbols{[}3{]}}, because each contains the same symbol in
this case. You now have a simple automated way to calculate the prize
when \texttt{symbols} contains three of a kind. Let's add it to our code
and then look at Case 2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\NormalTok{bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{  payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }
    \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{unname}\NormalTok{(payouts[symbols[}\DecValTok{1}\NormalTok{]])}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# assign $5}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \CommentTok{\# count cherries}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# calculate a prize}
\NormalTok{\}}

\CommentTok{\# count diamonds}
\CommentTok{\# double the prize if necessary}
\end{Highlighting}
\end{Shaded}

Case 2 occurs whenever the symbols are all bars. In that case, the prize
will be \$5, which is easy to assign:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\NormalTok{bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{  payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }
    \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{unname}\NormalTok{(payouts[symbols[}\DecValTok{1}\NormalTok{]])}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \CommentTok{\# count cherries}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# calculate a prize}
\NormalTok{\}}

\CommentTok{\# count diamonds}
\CommentTok{\# double the prize if necessary}
\end{Highlighting}
\end{Shaded}

Now we can work on the last case. Here, you'll need to know how many
cherries are in \texttt{symbols} before you can calculate a prize.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Find C's}\vspace{3mm}

How can you tell which elements of a vector named \texttt{symbols} are a
\texttt{C}? Devise a test and try it out.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Challenge}, toprule=.15mm]

How might you count the number of \texttt{C}s in a vector named
\texttt{symbols}? Remember R's coercion rules.

\end{tcolorbox}

As always, let's work with a real example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"C"}\NormalTok{, }\StringTok{"DD"}\NormalTok{, }\StringTok{"C"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

One way to test for cherries would be to check which, if any, of the
symbols are a \texttt{C}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\SpecialCharTok{==} \StringTok{"C"}
\DocumentationTok{\#\# TRUE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

It'd be even more useful to count how many of the symbols are cherries.
You can do this with \texttt{sum}, which expects numeric input, not
logical. Knowing this, R will coerce the \texttt{TRUE}s and
\texttt{FALSE}s to \texttt{1}s and \texttt{0}s before doing the
summation. As a result, \texttt{sum} will return the number of
\texttt{TRUE}s, which is also the number of cherries:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{)}
\DocumentationTok{\#\# 2}
\end{Highlighting}
\end{Shaded}

You can use the same method to count the number of diamonds in
\texttt{symbols}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{)}
\DocumentationTok{\#\# 1}
\end{Highlighting}
\end{Shaded}

Let's add both of these subtasks to the program skeleton:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\NormalTok{bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{  payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }
    \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{unname}\NormalTok{(payouts[symbols[}\DecValTok{1}\NormalTok{]])}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  cherries }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \CommentTok{\# calculate a prize}
\NormalTok{\}}

\NormalTok{diamonds }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{)}
\CommentTok{\# double the prize if necessary}
\end{Highlighting}
\end{Shaded}

Since Case 3 appears further down the \texttt{if} tree than Cases 1 and
2, the code in Case 3 will only be applied to players that do not have
three of a kind or all bars. According to the slot machine's payout
scheme, these players will win \$5 if they have two cherries and \$2 if
they have one cherry. If the player has no cherries, she gets a prize of
\$0. We don't need to worry about three cherries because that outcome is
already covered in Case 1.

As in Case 1, you could write an \texttt{if} tree that handles each
combination of cherries, but just like in Case 1, this would be an
inefficient solution:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (cherries }\SpecialCharTok{==} \DecValTok{2}\NormalTok{) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (cherries }\SpecialCharTok{==} \DecValTok{1}\NormalTok{) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{\}}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \DecValTok{0}
\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

Again, I think the best solution will involve subsetting. If you are
feeling ambitious, you can try to work this solution out on your own,
but you will learn just as quickly by mentally working through the
following proposed solution.

We know that our prize should be \$0 if we have no cherries, \$2 if we
have one cherry, and \$5 if we have two cherries. You can create a
vector that contains this information. This will be a very simple lookup
table:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now, like in Case 1, you can subset the vector to retrieve the correct
prize. In this case, the prize's aren't identified by a symbol name, but
by the number of cherries present. Do we have that information? Yes, it
is stored in \texttt{cherries}. We can use basic integer subsetting to
get the correct prize from the prior lookup table, for example,
\texttt{c(0,\ 2,\ 5){[}1{]}}.

\texttt{cherries} isn't exactly suited for integer subsetting because it
could contain a zero, but that's easy to fix. We can subset with
\texttt{cherries\ +\ 1}. Now when \texttt{cherries} equals zero, we
have:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cherries }\SpecialCharTok{+} \DecValTok{1}
\DocumentationTok{\#\# 1}

\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\# 0}
\end{Highlighting}
\end{Shaded}

When \texttt{cherries} equals one, we have:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cherries }\SpecialCharTok{+} \DecValTok{1}
\DocumentationTok{\#\# 2}

\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\# 2}
\end{Highlighting}
\end{Shaded}

And when \texttt{cherries} equals two, we have:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cherries }\SpecialCharTok{+} \DecValTok{1}
\DocumentationTok{\#\# 3}

\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\# 5}
\end{Highlighting}
\end{Shaded}

Examine these solutions until you are satisfied that they return the
correct prize for each number of cherries. Then add the code to your
script, as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\NormalTok{bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{  payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }
    \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{unname}\NormalTok{(payouts[symbols[}\DecValTok{1}\NormalTok{]])}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  cherries }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\NormalTok{\}}

\NormalTok{diamonds }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{)}
\CommentTok{\# double the prize if necessary}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Lookup Tables Versus if Trees}, toprule=.15mm]

This is the second time we've created a lookup table to avoid writing an
\texttt{if} tree. Why is this technique helpful and why does it keep
appearing? Many \texttt{if} trees in R are essential. They provide a
useful way to tell R to use different algorithms in different cases.
However, \texttt{if} trees are not appropriate everywhere.

\texttt{if} trees have a couple of drawbacks. First, they require R to
run multiple tests as it works its way down the \texttt{if} tree, which
can create unnecessary work. Second, as you'll see in
\hyperref[sec-speed]{Speed}, it can be difficult to use \texttt{if}
trees in vectorized code, a style of code that takes advantage of R's
programming strengths to create fast programs. Lookup tables do not
suffer from either of these drawbacks.

You won't be able to replace every \texttt{if} tree with a lookup table,
nor should you. However, you can usually use lookup tables to avoid
assigning variables with \texttt{if} trees. As a general rule, use an
\texttt{if} tree if each branch of the tree runs different \emph{code}.
Use a lookup table if each branch of the tree only assigns a different
\emph{value}.

To convert an \texttt{if} tree to a lookup table, identify the values to
be assigned and store them in a vector. Next, identify the selection
criteria used in the conditions of the \texttt{if} tree. If the
conditions use character strings, give your vector names and use
name-based subsetting. If the conditions use integers, use integer-based
subsetting.

\end{tcolorbox}

The final subtask is to double the prize once for every diamond present.
This means that the final prize will be some multiple of the current
prize. For example, if no diamonds are present, the prize will be:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prize }\SpecialCharTok{*} \DecValTok{1}      \CommentTok{\# 1 = 2 \^{} 0}
\end{Highlighting}
\end{Shaded}

If one diamond is present, it will be:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prize }\SpecialCharTok{*} \DecValTok{2}      \CommentTok{\# 2 = 2 \^{} 1}
\end{Highlighting}
\end{Shaded}

If two diamonds are present, it will be:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prize }\SpecialCharTok{*} \DecValTok{4}      \CommentTok{\# 4 = 2 \^{} 2}
\end{Highlighting}
\end{Shaded}

And if three diamonds are present, it will be:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prize }\SpecialCharTok{*} \DecValTok{8}      \CommentTok{\# 8 = 2 \^{} 3}
\end{Highlighting}
\end{Shaded}

Can you think of an easy way to handle this? How about something similar
to these examples?

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Adjust for Diamonds}\vspace{3mm}

Write a method for adjusting \texttt{prize} based on \texttt{diamonds}.
Describe a solution in English first, and then write your code.

\end{tcolorbox}

Here is a concise solution inspired by the previous pattern. The
adjusted prize will equal:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prize }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{\^{}}\NormalTok{ diamonds}
\end{Highlighting}
\end{Shaded}

which gives us our final \texttt{score} script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\NormalTok{bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{  payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }
    \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{unname}\NormalTok{(payouts[symbols[}\DecValTok{1}\NormalTok{]])}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  cherries }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\NormalTok{\}}

\NormalTok{diamonds }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{)}
\NormalTok{prize }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{\^{}}\NormalTok{ diamonds}
\end{Highlighting}
\end{Shaded}

\section{Code Comments}\label{code-comments}

You now have a working score script that you can save to a function.
Before you save your script, though, consider adding comments to your
code with a \texttt{\#}. Comments can make your code easier to
understand by explaining \emph{why} the code does what it does. You can
also use comments to break long programs into scannable chunks. For
example, I would include three comments in the \texttt{score} code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# identify case}
\NormalTok{same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\NormalTok{bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}

\CommentTok{\# get prize}
\ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{  payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }
    \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{unname}\NormalTok{(payouts[symbols[}\DecValTok{1}\NormalTok{]])}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  cherries }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{)}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\NormalTok{\}}

\CommentTok{\# adjust for diamonds}
\NormalTok{diamonds }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{)}
\NormalTok{prize }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{\^{}}\NormalTok{ diamonds}
\end{Highlighting}
\end{Shaded}

Now that each part of your code works, you can wrap it into a function
with the methods you learned in \hyperref[sec-write-functions]{Writing
Your Own Functions}. Either use RStudio's Extract Function option in the
menu bar under Code, or use the \texttt{function} function. Ensure that
the last line of the function returns a result (it does), and identify
any arguments used by your function. Often the concrete examples that
you used to test your code, like \texttt{symbols}, will become the
arguments of your function. Run the following code to start using the
\texttt{score} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{score }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{ (symbols) \{}
  \CommentTok{\# identify case}
\NormalTok{  same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\NormalTok{  bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}
  
  \CommentTok{\# get prize}
  \ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{    payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }
      \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \FunctionTok{unname}\NormalTok{(payouts[symbols[}\DecValTok{1}\NormalTok{]])}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    cherries }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{)}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\NormalTok{  \}}
  
  \CommentTok{\# adjust for diamonds}
\NormalTok{  diamonds }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{)}
\NormalTok{  prize }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{\^{}}\NormalTok{ diamonds}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Once you have defined the \texttt{score} function, the \texttt{play}
function will work as well:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{get\_symbols}\NormalTok{()}
  \FunctionTok{print}\NormalTok{(symbols)}
  \FunctionTok{score}\NormalTok{(symbols)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now it is easy to play the slot machine:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# "0"  "BB" "B" }
\DocumentationTok{\#\# 0}

\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# "DD"  "0" "B"  }
\DocumentationTok{\#\# 0}

\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# "BB" "BB" "B" }
\DocumentationTok{\#\# 25}
\end{Highlighting}
\end{Shaded}

\section{Summary}\label{summary-6}

An R program is a set of instructions for your computer to follow that
has been organized into a sequence of steps and cases. This may make
programs seem simple, but don't be fooled: you can create complicated
results with the right combination of simple steps (and cases).

As a programmer, you are more likely to be fooled in the opposite way. A
program may seem impossible to write when you know that it must do
something impressive. Do not panic in these situations. Divide the job
before you into simple tasks, and then divide the tasks again. You can
visualize the relationship between tasks with a flow chart if it helps.
Then work on the subtasks one at a time. Describe solutions in English,
then convert them to R code. Test each solution against concrete
examples as you go. Once each of your subtasks works, combine your code
into a function that you can share and reuse.

R provides tools that can help you do this. You can manage cases with
\texttt{if} and \texttt{else} statements. You can create a lookup table
with objects and subsetting. You can add code comments with \texttt{\#}.
And you can save your programs as a function with \texttt{function}.

Things often go wrong when people write programs. It will be up to you
to find the source of any errors that occur and to fix them. It should
be easy to find the source of your errors if you use a stepwise approach
to writing functions, writing---and then testing---one bit at a time.
However, if the source of an error eludes you, or you find yourself
working with large chunks of untested code, consider using R's built in
debugging tools, described in \hyperref[sec-appendix-debug]{Debugging R
Code}.

The next two chapters will teach you more tools that you can use in your
programs. As you master these tools, you will find it easier to write R
programs that let you do whatever you wish to your data. In
\hyperref[sec-s3]{S3}, you will learn how to use R's S3 system, an
invisible hand that shapes many parts of R. You will use the system to
build a custom class for your slot machine output, and you will tell R
how to display objects that have your class.

\chapter{S3}\label{sec-s3}

You may have noticed that your slot machine results do not look the way
I promised they would. I suggested that the slot machine would display
its results like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# 0 0 DD}
\DocumentationTok{\#\# $0}
\end{Highlighting}
\end{Shaded}

But the current machine displays its results in a less pretty format:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# "0"  "0" "DD" }
\DocumentationTok{\#\# 0}
\end{Highlighting}
\end{Shaded}

Moreover, the slot machine uses a hack to display symbols (we call
\texttt{print} from within \texttt{play}). As a result, the symbols do
not follow your prize output if you save it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one\_play }\OtherTok{\textless{}{-}} \FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# "B" "0" "B" }

\NormalTok{one\_play}
\DocumentationTok{\#\# 0}
\end{Highlighting}
\end{Shaded}

You can fix both of these problems with R's S3 system.

\section{The S3 System}\label{the-s3-system}

S3 refers to a class system built into R. The system governs how R
handles objects of different classes. Certain R functions will look up
an object's S3 class, and then behave differently in response.

The \texttt{print} function is like this. When you print a numeric
vector, \texttt{print} will display a number:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num }\OtherTok{\textless{}{-}} \DecValTok{1000000000}
\FunctionTok{print}\NormalTok{(num)}
\DocumentationTok{\#\# 1000000000}
\end{Highlighting}
\end{Shaded}

But if you give that number the S3 class \texttt{POSIXct} followed by
\texttt{POSIXt}, \texttt{print} will display a time:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(num) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"POSIXct"}\NormalTok{, }\StringTok{"POSIXt"}\NormalTok{)}
\FunctionTok{print}\NormalTok{(num)}
\DocumentationTok{\#\# "2001{-}09{-}08 19:46:40 CST"}
\end{Highlighting}
\end{Shaded}

If you use objects with classes---and you do---you will run into R's S3
system. S3 behavior can seem odd at first, but is easy to predict once
you are familiar with it.

R's S3 system is built around three components: attributes (especially
the \texttt{class} attribute), generic functions, and methods.

\section{Attributes}\label{attributes}

In \hyperref[sec-attributes]{Attributes}, you learned that many R
objects come with attributes, pieces of extra information that are given
a name and appended to the object. Attributes do not affect the values
of the object, but stick to the object as a type of metadata that R can
use to handle the object. For example, a data frame stores its row and
column names as attributes. Data frames also store their class,
\texttt{"data.frame"}, as an attribute.

You can see an object's attributes with \texttt{attribute}. If you run
\texttt{attribute} on the \texttt{deck} data frame that you created in
\hyperref[sec-project-cards]{Project 2: Playing Cards}, you will see:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(deck)}
\DocumentationTok{\#\# $names}
\DocumentationTok{\#\# [1] "face"  "suit"  "value"}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $class}
\DocumentationTok{\#\# [1] "data.frame"}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $row.names}
\DocumentationTok{\#\#  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 }
\DocumentationTok{\#\# [20] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36}
\DocumentationTok{\#\# [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52}
\end{Highlighting}
\end{Shaded}

R comes with many helper functions that let you set and access the most
common attributes used in R. You've already met the \texttt{names},
\texttt{dim}, and \texttt{class} functions, which each work with an
eponymously named attribute. However, R also has \texttt{row.names},
\texttt{levels}, and many other attribute-based helper functions. You
can use any of these functions to retrieve an attribute's value:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{row.names}\NormalTok{(deck)}
\DocumentationTok{\#\#  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13"}
\DocumentationTok{\#\# [14] "14" "15" "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26"}
\DocumentationTok{\#\# [27] "27" "28" "29" "30" "31" "32" "33" "34" "35" "36" "37" "38" "39"}
\DocumentationTok{\#\# [40] "40" "41" "42" "43" "44" "45" "46" "47" "48" "49" "50" "51" "52"}
\end{Highlighting}
\end{Shaded}

or to change an attribute's value:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{row.names}\NormalTok{(deck) }\OtherTok{\textless{}{-}} \DecValTok{101}\SpecialCharTok{:}\DecValTok{152}
\end{Highlighting}
\end{Shaded}

or to give an object a new attribute altogether:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{levels}\NormalTok{(deck) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"level 1"}\NormalTok{, }\StringTok{"level 2"}\NormalTok{, }\StringTok{"level 3"}\NormalTok{)}

\FunctionTok{attributes}\NormalTok{(deck)}
\DocumentationTok{\#\# $names}
\DocumentationTok{\#\# [1] "face"  "suit"  "value"}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $class}
\DocumentationTok{\#\# [1] "data.frame"}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $row.names}
\DocumentationTok{\#\#  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117}
\DocumentationTok{\#\# [18] 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134}
\DocumentationTok{\#\# [35] 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151}
\DocumentationTok{\#\# [52] 152}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# $levels}
\DocumentationTok{\#\# [1] "level 1" "level 2" "level 3"}
\end{Highlighting}
\end{Shaded}

R is very laissez faire when it comes to attributes. It will let you add
any attributes that you like to an object (and then it will usually
ignore them). The only time R will complain is when a function needs to
find an attribute and it is not there.

You can add any general attribute to an object with \texttt{attr}; you
can also use \texttt{attr} to look up the value of any attribute of an
object. Let's see how this works with \texttt{one\_play}, the result of
playing our slot machine one time:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one\_play }\OtherTok{\textless{}{-}} \FunctionTok{play}\NormalTok{()}
\NormalTok{one\_play}
\DocumentationTok{\#\# 0}

\FunctionTok{attributes}\NormalTok{(one\_play)}
\DocumentationTok{\#\# NULL}
\end{Highlighting}
\end{Shaded}

\texttt{attr} takes two arguments: an R object and the name of an
attribute (as a character string). To give the R object an attribute of
the specified name, save a value to the output of \texttt{attr}. Let's
give \texttt{one\_play} an attribute named \texttt{symbols} that
contains a vector of character strings:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attr}\NormalTok{(one\_play, }\StringTok{"symbols"}\NormalTok{) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"0"}\NormalTok{, }\StringTok{"B"}\NormalTok{)}

\FunctionTok{attributes}\NormalTok{(one\_play)}
\DocumentationTok{\#\# $symbols}
\DocumentationTok{\#\# [1] "B" "0" "B"}
\end{Highlighting}
\end{Shaded}

To look up the value of any attribute, give \texttt{attr} an R object
and the name of the attribute you would like to look up:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attr}\NormalTok{(one\_play, }\StringTok{"symbols"}\NormalTok{)}
\DocumentationTok{\#\# "B" "0" "B"}
\end{Highlighting}
\end{Shaded}

If you give an attribute to an atomic vector, like \texttt{one\_play}, R
will usually display the attribute beneath the vector's values. However,
if the attribute changes the vector's class, R may display all of the
information in the vector in a new way (as we saw with \texttt{POSIXct}
objects):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one\_play}
\DocumentationTok{\#\# [1] 0}
\DocumentationTok{\#\# attr(,"symbols")}
\DocumentationTok{\#\# [1] "B" "0" "B"}
\end{Highlighting}
\end{Shaded}

R will generally ignore an object's attributes unless you give them a
name that an R function looks for, like \texttt{names} or
\texttt{class}. For example, R will ignore the \texttt{symbols}
attribute of \texttt{one\_play} as you manipulate \texttt{one\_play}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one\_play }\SpecialCharTok{+} \DecValTok{1}
\DocumentationTok{\#\#  1}
\DocumentationTok{\#\# attr(,"symbols")}
\DocumentationTok{\#\#  "B" "0" "B"}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Add an Attribute}\vspace{3mm}

Modify \texttt{play} to return a prize that contains the symbols
associated with it as an attribute named \texttt{symbols}. Remove the
redundant call to \texttt{print(symbols)}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{get\_symbols}\NormalTok{()}
  \FunctionTok{print}\NormalTok{(symbols)}
  \FunctionTok{score}\NormalTok{(symbols)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

You can create a new version of \texttt{play} by capturing the output of
\texttt{score(symbols)} and assigning an attribute to it. \texttt{play}
can then return the enhanced version of the output:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{get\_symbols}\NormalTok{()}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{score}\NormalTok{(symbols)}
  \FunctionTok{attr}\NormalTok{(prize, }\StringTok{"symbols"}\NormalTok{) }\OtherTok{\textless{}{-}}\NormalTok{ symbols}
\NormalTok{  prize}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now \texttt{play} returns both the prize and the symbols associated with
the prize. The results may not look pretty, but the symbols stick with
the prize when we copy it to a new object. We can work on tidying up the
display in a minute:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# [1] 0}
\DocumentationTok{\#\# attr(,"symbols")}
\DocumentationTok{\#\# [1] "B"  "BB" "0" }
 
\NormalTok{two\_play }\OtherTok{\textless{}{-}} \FunctionTok{play}\NormalTok{()}
 
\NormalTok{two\_play}
\DocumentationTok{\#\# [1] 0}
\DocumentationTok{\#\# attr(,"symbols")}
\DocumentationTok{\#\# [1] "0" "B" "0"}
\end{Highlighting}
\end{Shaded}

You can also generate a prize and set its attributes in one step with
the \texttt{structure} function. \texttt{structure} creates an object
with a set of attributes. The first argument of \texttt{structure}
should be an R object or set of values, and the remaining arguments
should be named attributes for \texttt{structure} to add to the object.
You can give these arguments any argument names you like.
\texttt{structure} will add the attributes to the object under the names
that you provide as argument names:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{get\_symbols}\NormalTok{()}
  \FunctionTok{structure}\NormalTok{(}\FunctionTok{score}\NormalTok{(symbols), }\AttributeTok{symbols =}\NormalTok{ symbols)}
\NormalTok{\}}

\NormalTok{three\_play }\OtherTok{\textless{}{-}} \FunctionTok{play}\NormalTok{()}
\NormalTok{three\_play}
\DocumentationTok{\#\#  0}
\DocumentationTok{\#\#  attr(,"symbols")}
\DocumentationTok{\#\#  "0"  "BB" "B" }
\end{Highlighting}
\end{Shaded}

Now that your \texttt{play} output contains a \texttt{symbols}
attribute, what can you do with it? You can write your own functions
that lookup and use the attribute. For example, the following function
will look up \texttt{one\_play}'s \texttt{symbols} attribute and use it
to display \texttt{one\_play} in a pretty manner. We will use this
function to display our slot results, so let's take a moment to study
what it does:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{slot\_display }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(prize)\{}

  \CommentTok{\# extract symbols}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{attr}\NormalTok{(prize, }\StringTok{"symbols"}\NormalTok{)}

  \CommentTok{\# collapse symbols into single string}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(symbols, }\AttributeTok{collapse =} \StringTok{" "}\NormalTok{)}

  \CommentTok{\# combine symbol with prize as a character string}
  \CommentTok{\# \textbackslash{}n is special escape sequence for a new line (i.e. return or enter)}
\NormalTok{  string }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(symbols, prize, }\AttributeTok{sep =} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{$"}\NormalTok{)}

  \CommentTok{\# display character string in console without quotes}
  \FunctionTok{cat}\NormalTok{(string)}
\NormalTok{\}}

\FunctionTok{slot\_display}\NormalTok{(one\_play)}
\DocumentationTok{\#\# B 0 B}
\DocumentationTok{\#\# $0}
\end{Highlighting}
\end{Shaded}

The function expects an object like \texttt{one\_play} that has both a
numerical value and a \texttt{symbols} attribute. The first line of the
function will look up the value of the \texttt{symbols} attribute and
save it as an object named \texttt{symbols}. Let's make an example
\texttt{symbols} object so we can see what the rest of the function
does. We can use \texttt{one\_play}'s \texttt{symbols} attribute to do
the job. \texttt{symbols} will be a vector of three-character strings:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{attr}\NormalTok{(one\_play, }\StringTok{"symbols"}\NormalTok{)}

\NormalTok{symbols}
\DocumentationTok{\#\# "B" "0" "B"}
\end{Highlighting}
\end{Shaded}

Next, \texttt{slot\_display} uses \texttt{paste} to collapse the three
strings in \texttt{symbols} into a single-character string.
\texttt{paste} collapses a vector of character strings into a single
string when you give it the \texttt{collapse} argument. \texttt{paste}
will use the value of \texttt{collapse} to separate the formerly
distinct strings. Hence, \texttt{symbols} becomes \texttt{B\ 0\ B} the
three strings separated by a space:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(symbols, }\AttributeTok{collapse =} \StringTok{" "}\NormalTok{)}

\NormalTok{symbols}
\DocumentationTok{\#\# "B 0 B"}
\end{Highlighting}
\end{Shaded}

Our function then uses \texttt{paste} in a new way to combine
\texttt{symbols} with the value of \texttt{prize}. \texttt{paste}
combines separate objects into a character string when you give it a
\texttt{sep} argument. For example, here \texttt{paste} will combine the
string in \texttt{symbols}, \texttt{B\ 0\ B}, with the number in
\texttt{prize}, 0. \texttt{paste} will use the value of \texttt{sep}
argument to separate the inputs in the new string. Here, that value is
\texttt{\textbackslash{}n\$}, so our result will look like
\texttt{"B\ 0\ B\textbackslash{}n\$0"}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prize }\OtherTok{\textless{}{-}}\NormalTok{ one\_play}
\NormalTok{string }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(symbols, prize, }\AttributeTok{sep =} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{$"}\NormalTok{)}

\NormalTok{string}
\DocumentationTok{\#\# "B 0 B\textbackslash{}n$0"}
\end{Highlighting}
\end{Shaded}

The last line of \texttt{slot\_display} calls \texttt{cat} on the new
string. \texttt{cat} is like \texttt{print}; it displays its input at
the command line. However, \texttt{cat} does not surround its output
with quotation marks. \texttt{cat} also replaces every
\texttt{\textbackslash{}n} with a new line or line break. The result is
what we see. Notice that it looks just how I suggested that our
\texttt{play} output should look in \hyperref[sec-programs]{Programs}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(string)}
\DocumentationTok{\#\# B 0 B}
\DocumentationTok{\#\# $0}
\end{Highlighting}
\end{Shaded}

You can use \texttt{slot\_display} to manually clean up the output of
\texttt{play}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{slot\_display}\NormalTok{(}\FunctionTok{play}\NormalTok{())}
\DocumentationTok{\#\# C B 0}
\DocumentationTok{\#\# $2}

\FunctionTok{slot\_display}\NormalTok{(}\FunctionTok{play}\NormalTok{())}
\DocumentationTok{\#\# 7 0 BB}
\DocumentationTok{\#\# $0}
\end{Highlighting}
\end{Shaded}

This method of cleaning the output requires you to manually intervene in
your R session (to call \texttt{slot\_display}). There is a function
that you can use to automatically clean up the output of \texttt{play}
\emph{each} time it is displayed. This function is \texttt{print}, and
it is a \emph{generic function}.

\section{Generic Functions}\label{generic-functions}

R uses \texttt{print} more often than you may think; R calls
\texttt{print} each time it displays a result in your console window.
This call happens in the background, so you do not notice it; but the
call explains how output makes it to the console window (recall that
\texttt{print} always prints its argument in the console window). This
\texttt{print} call also explains why the output of \texttt{print}
always matches what you see when you display an object at the command
line:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(pi)}
\DocumentationTok{\#\# 3.141593}

\NormalTok{pi}
\DocumentationTok{\#\# 3.141593}


\FunctionTok{print}\NormalTok{(}\FunctionTok{head}\NormalTok{(deck))}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  king spades    13}
\DocumentationTok{\#\# queen spades    12}
\DocumentationTok{\#\#  jack spades    11}
\DocumentationTok{\#\#   ten spades    10}
\DocumentationTok{\#\#  nine spades     9}
\DocumentationTok{\#\# eight spades     8}

\FunctionTok{head}\NormalTok{(deck)}
\DocumentationTok{\#\#  face   suit value}
\DocumentationTok{\#\#  king spades    13}
\DocumentationTok{\#\# queen spades    12}
\DocumentationTok{\#\#  jack spades    11}
\DocumentationTok{\#\#   ten spades    10}
\DocumentationTok{\#\#  nine spades     9}
\DocumentationTok{\#\# eight spades     8}


\FunctionTok{print}\NormalTok{(}\FunctionTok{play}\NormalTok{())}
\DocumentationTok{\#\#  5}
\DocumentationTok{\#\# attr(,"symbols")}
\DocumentationTok{\#\#  "B"  "BB" "B" }

\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\#  5}
\DocumentationTok{\#\# attr(,"symbols")}
\DocumentationTok{\#\#  "B"  "BB" "B" }
\end{Highlighting}
\end{Shaded}

You can change how R displays your slot output by rewriting
\texttt{print} to look like \texttt{slot\_display}. Then R would print
the output in our tidy format. However, this method would have negative
side effects. You do not want R to call \texttt{slot\_display} when it
prints a data frame, a numerical vector, or any other object.

Fortunately, \texttt{print} is not a normal function; it is a
\emph{generic} function. This means that \texttt{print} is written in a
way that lets it do different things in different cases. You've already
seen this behavior in action (although you may not have realized it).
\texttt{print} did one thing when we looked at the unclassed version of
\texttt{num}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num }\OtherTok{\textless{}{-}} \DecValTok{1000000000}
\FunctionTok{print}\NormalTok{(num)}
\DocumentationTok{\#\# 1000000000}
\end{Highlighting}
\end{Shaded}

and a different thing when we gave \texttt{num} a class:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(num) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"POSIXct"}\NormalTok{, }\StringTok{"POSIXt"}\NormalTok{)}
\FunctionTok{print}\NormalTok{(num)}
\DocumentationTok{\#\# "2001{-}09{-}08 19:46:40 CST"}
\end{Highlighting}
\end{Shaded}

Take a look at the code inside \texttt{print} to see how it does this.
You may imagine that print looks up the class attribute of its input and
then uses an +if+ tree to pick which output to display. If this occurred
to you, great job! \texttt{print} does something very similar, but much
more simple.

\section{Methods}\label{methods}

When you call \texttt{print}, \texttt{print} calls a special function,
\texttt{UseMethod}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print}
\DocumentationTok{\#\# function (x, ...) }
\DocumentationTok{\#\# UseMethod("print")}
\DocumentationTok{\#\# \textless{}bytecode: 0x7ffee4c62f80\textgreater{}}
\DocumentationTok{\#\# \textless{}environment: namespace:base\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{UseMethod} examines the class of the input that you provide for
the first argument of \texttt{print}, and then passes all of your
arguments to a new function designed to handle that class of input. For
example, when you give \texttt{print} a POSIXct object,
\texttt{UseMethod} will pass all of \texttt{print}'s arguments to
\texttt{print.POSIXct}. R will then run \texttt{print.POSIXct} and
return the results:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print.POSIXct}
\DocumentationTok{\#\# function (x, ...) }
\DocumentationTok{\#\# \{}
\DocumentationTok{\#\#     max.print \textless{}{-} getOption("max.print", 9999L)}
\DocumentationTok{\#\#     if (max.print \textless{} length(x)) \{}
\DocumentationTok{\#\#         print(format(x[seq\_len(max.print)], usetz = TRUE), ...)}
\DocumentationTok{\#\#         cat(" [ reached getOption(\textbackslash{}"max.print\textbackslash{}") {-}{-} omitted", }
\DocumentationTok{\#\#             length(x) {-} max.print, "entries ]\textbackslash{}n")}
\DocumentationTok{\#\#     \}}
\DocumentationTok{\#\#     else print(format(x, usetz = TRUE), ...)}
\DocumentationTok{\#\#     invisible(x)}
\DocumentationTok{\#\# \}}
\DocumentationTok{\#\# \textless{}bytecode: 0x7fa948f3d008\textgreater{}}
\DocumentationTok{\#\# \textless{}environment: namespace:base\textgreater{}}
\end{Highlighting}
\end{Shaded}

If you give \texttt{print} a factor object, \texttt{UseMethod} will pass
all of \texttt{print}'s arguments to \texttt{print.factor}. R will then
run \texttt{print.factor} and return the results:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print.factor}
\DocumentationTok{\#\# function (x, quote = FALSE, max.levels = NULL, width = getOption("width"), }
\DocumentationTok{\#\#     ...) }
\DocumentationTok{\#\# \{}
\DocumentationTok{\#\#     ord \textless{}{-} is.ordered(x)}
\DocumentationTok{\#\#     if (length(x) == 0L) }
\DocumentationTok{\#\#         cat(if (ord) }
\DocumentationTok{\#\#             "ordered"}
\DocumentationTok{\#\# ...}
\DocumentationTok{\#\#         drop \textless{}{-} n \textgreater{} maxl}
\DocumentationTok{\#\#         cat(if (drop) }
\DocumentationTok{\#\#             paste(format(n), ""), T0, paste(if (drop) }
\DocumentationTok{\#\#             c(lev[1L:max(1, maxl {-} 1)], "...", if (maxl \textgreater{} 1) lev[n])}
\DocumentationTok{\#\#         else lev, collapse = colsep), "\textbackslash{}n", sep = "")}
\DocumentationTok{\#\#     \}}
\DocumentationTok{\#\#     invisible(x)}
\DocumentationTok{\#\# \}}
\DocumentationTok{\#\# \textless{}bytecode: 0x7fa94a64d470\textgreater{}}
\DocumentationTok{\#\# \textless{}environment: namespace:base\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{print.POSIXct} and \texttt{print.factor} are called
\emph{methods} of \texttt{print}. By themselves, \texttt{print.POSIXct}
and \texttt{print.factor} work like regular R functions. However, each
was written specifically so \texttt{UseMethod} could call it to handle a
specific class of \texttt{print} input.

Notice that \texttt{print.POSIXct} and \texttt{print.factor} do two
different things (also notice that I abridged the middle of
\texttt{print.factor}---it is a long function). This is how
\texttt{print} manages to do different things in different cases.
\texttt{print} calls \texttt{UseMethod}, which calls a specialized
method based on the class of \texttt{print}'s first argument.

You can see which methods exist for a generic function by calling
\texttt{methods} on the function. For example, \texttt{print} has almost
200 methods (which gives you an idea of how many classes exist in R):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{methods}\NormalTok{(print)}
\DocumentationTok{\#\#   [1] print.acf*                                   }
\DocumentationTok{\#\#   [2] print.anova                                  }
\DocumentationTok{\#\#   [3] print.aov*                                   }
\DocumentationTok{\#\#  ...                      }
\DocumentationTok{\#\# [176] print.xgettext*                              }
\DocumentationTok{\#\# [177] print.xngettext*                             }
\DocumentationTok{\#\# [178] print.xtabs*}
\DocumentationTok{\#\#}
\DocumentationTok{\#\#   Nonvisible functions are asterisked}
\end{Highlighting}
\end{Shaded}

This system of generic functions, methods, and class-based dispatch is
known as S3 because it originated in the third version of S, the
programming language that would evolve into S-PLUS and R. Many common R
functions are S3 generics that work with a set of class methods. For
example, \texttt{summary} and \texttt{head} also call
\texttt{UseMethod}. More basic functions, like \texttt{c}, \texttt{+},
\texttt{-}, \texttt{\textless{}} and others also behave like generic
functions, although they call \texttt{.primitive} instead of
\texttt{UseMethod}.

The S3 system allows R functions to behave in different ways for
different classes. You can use S3 to format your slot output. First,
give your output its own class. Then write a print method for that
class. To do this efficiently, you will need to know a little about how
\texttt{UseMethod} selects a method function to use.

\subsection{Method Dispatch}\label{method-dispatch}

\texttt{UseMethod} uses a very simple system to match methods to
functions.

Every S3 method has a two-part name. The first part of the name will
refer to the function that the method works with. The second part will
refer to the class. These two parts will be separated by a period. So
for example, the print method that works with functions will be called
\texttt{print.function}. The summary method that works with matrices
will be called \texttt{summary.matrix}. And so on.

When \texttt{UseMethod} needs to call a method, it searches for an R
function with the correct S3-style name. The function does not have to
be special in any way; it just needs to have the correct name.

You can participate in this system by writing your own function and
giving it a valid S3-style name. For example, let's give
\texttt{one\_play} a class of its own. It doesn't matter what you call
the class; R will store any character string in the class attribute:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(one\_play) }\OtherTok{\textless{}{-}} \StringTok{"slots"}
\end{Highlighting}
\end{Shaded}

Now let's write an S3 print method for the +slots+ class. The method
doesn't need to do anything special---it doesn't even need to print
\texttt{one\_play}. But it \emph{does} need to be named
\texttt{print.slots}; otherwise \texttt{UseMethod} will not find it. The
method should also take the same arguments as \texttt{print}; otherwise,
R will give an error when it tries to pass the arguments to
\texttt{print.slots}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{args}\NormalTok{(print)}
\DocumentationTok{\#\# function (x, ...) }
\DocumentationTok{\#\# NULL}

\NormalTok{print.slots }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \FunctionTok{cat}\NormalTok{(}\StringTok{"I\textquotesingle{}m using the print.slots method"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Does our method work? Yes, and not only that; R uses the print method to
display the contents of \texttt{one\_play}. This method isn't very
useful, so I'm going to remove it. You'll have a chance to write a
better one in a minute:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(one\_play)}
\DocumentationTok{\#\# I\textquotesingle{}m using the print.slots method}

\NormalTok{one\_play}
\DocumentationTok{\#\# I\textquotesingle{}m using the print.slots method}

\FunctionTok{rm}\NormalTok{(print.slots)}
\end{Highlighting}
\end{Shaded}

Some R objects have multiple classes. For example, the output of
\texttt{Sys.time} has two classes. Which class will \texttt{UseMethod}
use to find a print method?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{now }\OtherTok{\textless{}{-}} \FunctionTok{Sys.time}\NormalTok{()}
\FunctionTok{attributes}\NormalTok{(now)}
\DocumentationTok{\#\# $class}
\DocumentationTok{\#\# [1] "POSIXct" "POSIXt" }
\end{Highlighting}
\end{Shaded}

\texttt{UseMethod} will first look for a method that matches the first
class listed in the object's class vector. If \texttt{UseMethod} cannot
find one, it will then look for the method that matches the second class
(and so on if there are more classes in an object's class vector).

If you give \texttt{print} an object whose class or classes do not have
a print method, \texttt{UseMethod} will call \texttt{print.default}, a
special method written to handle general cases.

Let's use this system to write a better print method for the slot
machine output.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Make a Print Method}\vspace{3mm}

Write a new print method for the slots class. The method should call
\texttt{slot\_display} to return well-formatted slot-machine output.

What name must you use for this method?

\end{tcolorbox}

It is surprisingly easy to write a good \texttt{print.slots} method
because we've already done all of the hard work when we wrote
\texttt{slot\_display}. For example, the following method will work.
Just make sure the method is named \texttt{print.slots} so
\texttt{UseMethod} can find it, and make sure that it takes the same
arguments as \texttt{print} so \texttt{UseMethod} can pass those
arguments to \texttt{print.slots} without any trouble:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print.slots }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \FunctionTok{slot\_display}\NormalTok{(x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now R will automatically use \texttt{slot\_display} to display objects
of class +slots+ (and only objects of class ``slots''):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one\_play}
\DocumentationTok{\#\# B 0 B}
\DocumentationTok{\#\# $0}
\end{Highlighting}
\end{Shaded}

Let's ensure that every piece of slot machine output has the
\texttt{slots} class.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Add a Class}\vspace{3mm}

Modify the \texttt{play} function so it assigns \texttt{slots} to the
\texttt{class} attribute of its output:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{get\_symbols}\NormalTok{()}
  \FunctionTok{structure}\NormalTok{(}\FunctionTok{score}\NormalTok{(symbols), }\AttributeTok{symbols =}\NormalTok{ symbols)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

You can set the \texttt{class} attribute of the output at the same time
that you set the +symbols+ attribute. Just add
\texttt{class\ =\ "slots"} to the \texttt{structure} call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{get\_symbols}\NormalTok{()}
  \FunctionTok{structure}\NormalTok{(}\FunctionTok{score}\NormalTok{(symbols), }\AttributeTok{symbols =}\NormalTok{ symbols, }\AttributeTok{class =} \StringTok{"slots"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now each of our slot machine plays will have the class \texttt{slots}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(}\FunctionTok{play}\NormalTok{())}
\DocumentationTok{\#\# "slots"}
\end{Highlighting}
\end{Shaded}

As a result, R will display them in the correct slot-machine format:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# BB BB BBB}
\DocumentationTok{\#\# $5}

\FunctionTok{play}\NormalTok{()}
\DocumentationTok{\#\# BB 0 0}
\DocumentationTok{\#\# $0}
\end{Highlighting}
\end{Shaded}

\section{Classes}\label{classes}

You can use the S3 system to make a robust new class of objects in R.
Then R will treat objects of your class in a consistent, sensible
manner. To make a class:

\begin{itemize}
\tightlist
\item
  Choose a name for your class.
\item
  Assign each instance of your class a +class+ attribute.
\item
  Write class methods for any generic function likely to use objects of
  your class.
\end{itemize}

Many R packages are based on classes that have been built in a similar
manner. While this work is simple, it may not be easy. For example,
consider how many methods exist for predefined classes.

You can call \texttt{methods} on a class with the \texttt{class}
argument, which takes a character string. \texttt{methods} will return
every method written for the class. Notice that \texttt{methods} will
not be able to show you methods that come in an unloaded R package:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{methods}\NormalTok{(}\AttributeTok{class =} \StringTok{"factor"}\NormalTok{)}
\DocumentationTok{\#\#  [1] [.factor             [[.factor           }
\DocumentationTok{\#\#  [3] [[\textless{}{-}.factor          [\textless{}{-}.factor          }
\DocumentationTok{\#\#  [5] all.equal.factor     as.character.factor }
\DocumentationTok{\#\#  [7] as.data.frame.factor as.Date.factor      }
\DocumentationTok{\#\#  [9] as.list.factor       as.logical.factor   }
\DocumentationTok{\#\# [11] as.POSIXlt.factor    as.vector.factor    }
\DocumentationTok{\#\# [13] droplevels.factor    format.factor       }
\DocumentationTok{\#\# [15] is.na\textless{}{-}.factor       length\textless{}{-}.factor     }
\DocumentationTok{\#\# [17] levels\textless{}{-}.factor      Math.factor         }
\DocumentationTok{\#\# [19] Ops.factor           plot.factor*        }
\DocumentationTok{\#\# [21] print.factor         relevel.factor*     }
\DocumentationTok{\#\# [23] relist.factor*       rep.factor          }
\DocumentationTok{\#\# [25] summary.factor       Summary.factor      }
\DocumentationTok{\#\# [27] xtfrm.factor        }
\DocumentationTok{\#\# }
\DocumentationTok{\#\#    Nonvisible functions are asterisked}
\end{Highlighting}
\end{Shaded}

This output indicates how much work is required to create a robust,
well-behaved class. You will usually need to write a \texttt{class}
method for every basic R operation.

Consider two challenges that you will face right away. First, R drops
attributes (like \texttt{class}) when it combines objects into a vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play1 }\OtherTok{\textless{}{-}} \FunctionTok{play}\NormalTok{()}
\NormalTok{play1}
\DocumentationTok{\#\# B BBB BBB}
\DocumentationTok{\#\# $5}

\NormalTok{play2 }\OtherTok{\textless{}{-}} \FunctionTok{play}\NormalTok{()}
\NormalTok{play2}
\DocumentationTok{\#\# 0 B 0}
\DocumentationTok{\#\# $0}

\FunctionTok{c}\NormalTok{(play1, play2)}
\DocumentationTok{\#\# [1] 5 0}
\end{Highlighting}
\end{Shaded}

Here, R stops using \texttt{print.slots} to display the vector because
the vector \texttt{c(play1,\ play2)} no longer has a ``slots'' +class+
attribute.

Next, R will drop the attributes of an object (like \texttt{class}) when
you subset the object:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play1[}\DecValTok{1}\NormalTok{]}
\DocumentationTok{\#\# [1] 5}
\end{Highlighting}
\end{Shaded}

You can avoid this behavior by writing a \texttt{c.slots} method and a
\texttt{{[}.slots} method, but then difficulties will quickly accrue.
How would you combine the \texttt{symbols} attributes of multiple plays
into a vector of symbols attributes? How would you change
\texttt{print.slots} to handle vectors of outputs? These challenges are
open for you to explore. However, you will usually not have to attempt
this type of large-scale programming as a data scientist.

In our case, it is very handy to let \texttt{slots} objects revert to
single prize values when we combine groups of them together into a
vector.

\section{S3 and Debugging}\label{s3-and-debugging}

S3 can be annoying if you are trying to understand R functions. It is
difficult to tell what a function does if its code body contains a call
to \texttt{UseMethod}. Now that you know that \texttt{UseMethod} calls a
class-specific method, you can search for and examine the method
directly. It will be a function whose name follows the
\texttt{\textless{}function.class\textgreater{}} syntax, or possibly
\texttt{\textless{}function.default\textgreater{}}. You can also use the
\texttt{methods} function to see what methods are associated with a
function or a class.

\section{S4 and R5}\label{s4-and-r5}

R also contains two other systems that create class specific behavior.
These are known as S4 and R5 (or reference classes). Each of these
systems is much harder to use than S3, and perhaps as a consequence,
more rare. However, they offer safeguards that S3 does not. If you'd
like to learn more about these systems, including how to write and use
your own generic functions, I recommend the book
\href{http://adv-r.had.co.nz/}{Advanced R Programming} by Hadley
Wickham.

\section{Summary}\label{summary-7}

Values are not the only place to store information in R, and functions
are not the only way to create unique behavior. You can also do both of
these things with R's S3 system. The S3 system provides a simple way to
create object-specific behavior in R. In other words, it is R's version
of object-oriented programming (OOP). The system is implemented by
generic functions. These functions examine the class attribute of their
input and call a class-specific method to generate output. Many S3
methods will look for and use additional information that is stored in
an object's attributes. Many common R functions are S3 generics.

R's S3 system is more helpful for the tasks of computer science than the
tasks of data science, but understanding S3 can help you troubleshoot
your work in R as a data scientist.

You now know quite a bit about how to write R code that performs custom
tasks, but how could you repeat these tasks? As a data scientist, you
will often repeat tasks, sometimes thousands or even millions of times.
Why? Because repetition lets you simulate results and estimate
probabilities. \hyperref[sec-loops]{Loops} will show you how to automate
repetition with R's \texttt{for} and \texttt{while} functions. You'll
use \texttt{for} to simulate various slot machine plays and to calculate
the payout rate of your slot machine.

\chapter{Loops}\label{sec-loops}

Loops are R's method for repeating a task, which makes them a useful
tool for programming simulations. This chapter will teach you how to use
R's loop tools.

Let's use the \texttt{score} function to solve a real-world problem.

Your slot machine is modeled after real machines that were accused of
fraud. The machines appeared to pay out 40 cents on the dollar, but the
manufacturer claimed that they paid out 92 cents on the dollar. You can
calculate the exact payout rate of your machine with the \texttt{score}
program. The payout rate will be the expected value of the slot
machine's prize.

\section{Expected Values}\label{expected-values}

The expected value of a random event is a type of weighted average; it
is the sum of each possible outcome of the event, weighted by the
probability that each outcome occurs:

\[
E(x) = \sum_{i = 1}^{n}\left( x_{i} \cdot P(x_{i}) \right)
\]

You can think of the expected value as the average prize that you would
observe if you played the slot machine an infinite number of times.
Let's use the formula to calculate some simple expected values. Then we
will apply the formula to your slot machine.

Do you remember the \texttt{die} you created in
\hyperref[sec-project-dice]{Project 1: Weighted Dice}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Each time you roll the die, it returns a value selected at random (one
through six). You can find the expected value of rolling the die with
the formula:

\[
E(\text{die}) = \sum_{i = 1}^{n}\left( \text{die}_{i} \cdot P(\text{die}_{i}) \right)
\]

The \(\text{die}_{i}\)s are the possible outcomes of rolling the die: 1,
2, 3, 4, 5, and 6; and the \(P(\text{die}_{i})\)'s are the probabilities
associated with each of the outcomes. If your die is fair, each outcome
will occur with the same probability: 1/6. So our equation simplifies
to:

\[
\begin{array}{rl}
E(\text{die}) & = \sum_{i = 1}^{n}\left( \text{die}_{i} \cdot P(\text{die}_{i}) \right)\\
& = 1 \cdot \frac{1}{6} +  2 \cdot \frac{1}{6} + 3 \cdot \frac{1}{6} + 4 \cdot \frac{1}{6} + 5 \cdot \frac{1}{6} + 6 \cdot \frac{1}{6}\\
& = 3.5\\
\end{array}
\]

Hence, the expected value of rolling a fair die is 3.5. You may notice
that this is also the average value of the die. The expected value will
equal the average if every outcome has the same chance of occurring.

But what if each outcome has a different chance of occurring? For
example, we weighted our dice in
\hyperref[sec-packages-and-help]{Packages and Help Pages} so that each
die rolled 1, 2, 3, 4, and 5 with probability 1/8 and 6 with probability
3/8. You can use the same formula to calculate the expected value in
these conditions:

\[
\begin{array}{rl}
  E(die) & = 1 \cdot \frac{1}{8} +  2 \cdot \frac{1}{8} + 3 \cdot \frac{1}{8} + 4 \cdot \frac{1}{8} + 5 \cdot \frac{1}{8} + 6 \cdot \frac{3}{8}\\
  & = 4.125\\
  \end{array} 
\]

Hence, the expected value of a loaded die does not equal the average
value of its outcomes. If you rolled a loaded die an infinite number of
times, the average outcome would be 4.125, which is higher than what you
would expect from a fair die.

Notice that we did the same three things to calculate both of these
expected values. We have:

\begin{itemize}
\tightlist
\item
  Listed out all of the possible outcomes
\item
  Determined the \emph{value} of each outcome (here just the value of
  the die)
\item
  Calculated the probability that each outcome occurred
\end{itemize}

The expected value was then just the sum of the values in step 2
multiplied by the probabilities in step 3.

You can use these steps to calculate more sophisticated expected values.
For example, you could calculate the expected value of rolling a pair of
weighted dice. Let's do this step by step.

First, list out all of the possible outcomes. A total of 36 different
outcomes can appear when you roll two dice. For example, you might roll
(1, 1), which notates one on the first die and one on the second die.
Or, you may roll (1, 2), one on the first die and two on the second. And
so on. Listing out these combinations can be tedious, but R has a
function that can help.

\section{expand.grid}\label{expand.grid}

The \texttt{expand.grid} function in R provides a quick way to write out
every combination of the elements in \emph{n} vectors. For example, you
can list every combination of two dice. To do so, run
\texttt{expand.grid} on two copies of \texttt{die}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rolls }\OtherTok{\textless{}{-}} \FunctionTok{expand.grid}\NormalTok{(die, die)}
\end{Highlighting}
\end{Shaded}

\texttt{expand.grid} will return a data frame that contains every way to
pair an element from the first \texttt{die} vector with an element from
the second \texttt{die} vector. This will capture all 36 possible
combinations of values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rolls}
\DocumentationTok{\#\#    Var1 Var2}
\DocumentationTok{\#\# 1     1    1}
\DocumentationTok{\#\# 2     2    1}
\DocumentationTok{\#\# 3     3    1}
\DocumentationTok{\#\# ...}
\DocumentationTok{\#\# 34    4    6}
\DocumentationTok{\#\# 35    5    6}
\DocumentationTok{\#\# 36    6    6}
\end{Highlighting}
\end{Shaded}

You can use \texttt{expand.grid} with more than two vectors if you like.
For example, you could list every combination of rolling three dice with
\texttt{expand.grid(die,\ die,\ die)} and every combination of rolling
four dice with \texttt{expand.grid(die,\ die,\ die,\ die)}, and so on.
\texttt{expand.grid} will always return a data frame that contains each
possible combination of \emph{n} elements from the \emph{n} vectors.
Each combination will contain exactly one element from each vector.

You can determine the value of each roll once you've made your list of
outcomes. This will be the sum of the two dice, which you can calculate
using R's element-wise execution:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rolls}\SpecialCharTok{$}\NormalTok{value }\OtherTok{\textless{}{-}}\NormalTok{ rolls}\SpecialCharTok{$}\NormalTok{Var1 }\SpecialCharTok{+}\NormalTok{ rolls}\SpecialCharTok{$}\NormalTok{Var2}
\FunctionTok{head}\NormalTok{(rolls, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Var1 Var2 value}
\DocumentationTok{\#\#    1    1     2}
\DocumentationTok{\#\#    2    1     3}
\DocumentationTok{\#\#    3    1     4}
\end{Highlighting}
\end{Shaded}

R will match up the elements in each vector before adding them together.
As a result, each element of \texttt{value} will refer to the elements
of \texttt{Var1} and \texttt{Var2} that appear in the same row.

Next, you must determine the probability that each combination appears.
You can calculate this with a basic rule of probability:

\emph{The probability that} n \emph{independent, random events all occur
is equal to the product of the probabilities that each random event
occurs}.

Or more succinctly:

\[
P(A \& B \& C \& ...) = P(A) \cdot P(B) \cdot P(C) \cdot ...
\]

So the probability that we roll a (1, 1) will be equal to the
probability that we roll a one on the first die, 1/8, times the
probability that we roll a one on the second die, 1/8:

\[
\begin{array}{rl}
P(1 \& 1) & = P(1) \cdot P(1) \\
& = \frac{1}{8} \cdot \frac{1}{8}\\
& = \frac{1}{64}
\end{array}
\]

And the probability that we roll a (1, 2) will be:

\[
\begin{array}{rl}
P(1 \& 2) & = P(1) \cdot P(2) \\
& = \frac{1}{8} \cdot \frac{1}{8}\\
& = \frac{1}{64}
\end{array}
\]

And so on.

Let me suggest a three-step process for calculating these probabilities
in R. First, we can look up the probabilities of rolling the values in
\texttt{Var1}. We'll do this with the lookup table that follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prob }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"1"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\StringTok{"2"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\StringTok{"3"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\StringTok{"4"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\StringTok{"5"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{/}\DecValTok{8}\NormalTok{, }\StringTok{"6"} \OtherTok{=} \DecValTok{3}\SpecialCharTok{/}\DecValTok{8}\NormalTok{)}

\NormalTok{prob}
\DocumentationTok{\#\#     1     2     3     4     5     6 }
\DocumentationTok{\#\# 0.125 0.125 0.125 0.125 0.125 0.375 }
\end{Highlighting}
\end{Shaded}

If you subset this table by \texttt{rolls\$Var1}, you will get a vector
of probabilities perfectly keyed to the values of \texttt{Var1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rolls}\SpecialCharTok{$}\NormalTok{Var1}
\DocumentationTok{\#\# 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6}

\NormalTok{prob[rolls}\SpecialCharTok{$}\NormalTok{Var1]}
\DocumentationTok{\#\#     1     2     3     4     5     6     1     2     3     4     5     6 }
\DocumentationTok{\#\# 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 }
\DocumentationTok{\#\#     1     2     3     4     5     6     1     2     3     4     5     6 }
\DocumentationTok{\#\# 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 }
\DocumentationTok{\#\#     1     2     3     4     5     6     1     2     3     4     5     6 }
\DocumentationTok{\#\# 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 }

\NormalTok{rolls}\SpecialCharTok{$}\NormalTok{prob1 }\OtherTok{\textless{}{-}}\NormalTok{ prob[rolls}\SpecialCharTok{$}\NormalTok{Var1]}
\FunctionTok{head}\NormalTok{(rolls, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Var1 Var2 value prob1}
\DocumentationTok{\#\#    1    1     2 0.125}
\DocumentationTok{\#\#    2    1     3 0.125}
\DocumentationTok{\#\#    3    1     4 0.125}
\end{Highlighting}
\end{Shaded}

Second, we can look up the probabilities of rolling the values in
\texttt{Var2}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rolls}\SpecialCharTok{$}\NormalTok{prob2 }\OtherTok{\textless{}{-}}\NormalTok{ prob[rolls}\SpecialCharTok{$}\NormalTok{Var2]}

\FunctionTok{head}\NormalTok{(rolls, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Var1 Var2 value prob1 prob2}
\DocumentationTok{\#\#    1    1     2 0.125 0.125}
\DocumentationTok{\#\#    2    1     3 0.125 0.125}
\DocumentationTok{\#\#    3    1     4 0.125 0.125}
\end{Highlighting}
\end{Shaded}

Third, we can calculate the probability of rolling each combination by
multiplying \texttt{prob1} by \texttt{prob2}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rolls}\SpecialCharTok{$}\NormalTok{prob }\OtherTok{\textless{}{-}}\NormalTok{ rolls}\SpecialCharTok{$}\NormalTok{prob1 }\SpecialCharTok{*}\NormalTok{ rolls}\SpecialCharTok{$}\NormalTok{prob2}

\FunctionTok{head}\NormalTok{(rolls, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Var1 Var2 value prob1 prob2     prob}
\DocumentationTok{\#\#    1    1     2 0.125 0.125 0.015625}
\DocumentationTok{\#\#    2    1     3 0.125 0.125 0.015625}
\DocumentationTok{\#\#    3    1     4 0.125 0.125 0.015625}
\end{Highlighting}
\end{Shaded}

It is easy to calculate the expected value now that we have each
outcome, the value of each outcome, and the probability of each outcome.
The expected value will be the summation of the dice values multiplied
by the dice probabilities:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(rolls}\SpecialCharTok{$}\NormalTok{value }\SpecialCharTok{*}\NormalTok{ rolls}\SpecialCharTok{$}\NormalTok{prob)}
\DocumentationTok{\#\# 8.25}
\end{Highlighting}
\end{Shaded}

So the expected value of rolling two loaded dice is 8.25. If you rolled
a pair of loaded dice an infinite number of times, the average sum would
be 8.25. (If you are curious, the expected value of rolling a pair of
fair dice is 7, which explains why 7 plays such a large role in dice
games like craps.)

Now that you've warmed up, let's use our method to calculate the
expected value of the slot machine prize. We will follow the same steps
we just took:

\begin{itemize}
\tightlist
\item
  We will list out every possible outcome of playing the machine. This
  will be a list of every combination of three slot symbols.
\item
  We will calculate the probability of getting each combination when you
  play the machine.
\item
  We will determine the prize that we would win for each combination.
\end{itemize}

When we are finished, we will have a data set that looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Var1 Var2 Var3 prob1 prob2 prob3     prob prize}
\DocumentationTok{\#\#   DD   DD   DD  0.03  0.03  0.03 0.000027   800}
\DocumentationTok{\#\#    7   DD   DD  0.03  0.03  0.03 0.000027     0}
\DocumentationTok{\#\#  BBB   DD   DD  0.06  0.03  0.03 0.000054     0}
\DocumentationTok{\#\# ... and so on.}
\end{Highlighting}
\end{Shaded}

The expected value will then be the sum of the prizes multiplied by
their probability of occuring:

\[
E(\text{prize}) = \sum_{i = 1}^{n}\left( \text{prize}_{i} \cdot P(\text{prize}_{i}) \right)
\]

Ready to begin?

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: List the Combinations}\vspace{3mm}

Use \texttt{expand.grid} to make a data frame that contains every
possible combination of \emph{three} symbols from the \texttt{wheel}
vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wheel }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"}\NormalTok{, }\StringTok{"7"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"0"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Be sure to add the argument \texttt{stringsAsFactors\ =\ FALSE} to your
\texttt{expand.grid} call; otherwise, \texttt{expand.grid} will save the
combinations as factors, an unfortunate choice that will disrupt the
\texttt{score} function.

\end{tcolorbox}

To create a data frame of each combination of \emph{three} symbols, you
need to run \texttt{expand.grid} and give it \emph{three} copies of
\texttt{wheel}. The result will be a data frame with 343 rows, one for
each unique combination of three slot symbols:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{combos }\OtherTok{\textless{}{-}} \FunctionTok{expand.grid}\NormalTok{(wheel, wheel, wheel, }\AttributeTok{stringsAsFactors =} \ConstantTok{FALSE}\NormalTok{)}

\NormalTok{combos}
\DocumentationTok{\#\#   Var1 Var2 Var3}
\DocumentationTok{\#\# 1   DD   DD   DD}
\DocumentationTok{\#\# 2    7   DD   DD}
\DocumentationTok{\#\# 3  BBB   DD   DD}
\DocumentationTok{\#\# 4   BB   DD   DD}
\DocumentationTok{\#\# 5    B   DD   DD}
\DocumentationTok{\#\# 6    C   DD   DD}
\DocumentationTok{\#\# ...}
\DocumentationTok{\#\# 341    B    0    0}
\DocumentationTok{\#\# 342    C    0    0}
\DocumentationTok{\#\# 343    0    0    0}
\end{Highlighting}
\end{Shaded}

Now, let's calculate the probability of getting each combination. You
can use the probabilities contained in the \texttt{prob} argument of
\texttt{get\_symbols} to do this. These probabilities determine how
frequently each symbol is chosen when your slot machine generates
symbols. They were calculated after observing 345 plays of the Manitoba
video lottery terminals. Zeroes have the largest chance of being
selected (0.52) and cherries the least (0.01):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get\_symbols }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  wheel }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"}\NormalTok{, }\StringTok{"7"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"0"}\NormalTok{)}
  \FunctionTok{sample}\NormalTok{(wheel, }\AttributeTok{size =} \DecValTok{3}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }
    \AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.03}\NormalTok{, }\FloatTok{0.03}\NormalTok{, }\FloatTok{0.06}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.25}\NormalTok{, }\FloatTok{0.01}\NormalTok{, }\FloatTok{0.52}\NormalTok{)}
\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Make a Lookup Table}\vspace{3mm}

Isolate the previous probabilities in a lookup table. What names will
you use in your table?

\end{tcolorbox}

Your names should match the input that you want to look up. In this
case, the input will be the character strings that appear in
\texttt{Var1}, \texttt{Var2}, and \texttt{Var3}. So your lookup table
should look like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prob }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \FloatTok{0.03}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \FloatTok{0.03}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \FloatTok{0.06}\NormalTok{, }
  \StringTok{"BB"} \OtherTok{=} \FloatTok{0.1}\NormalTok{, }\StringTok{"B"} \OtherTok{=} \FloatTok{0.25}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \FloatTok{0.01}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \FloatTok{0.52}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now let's look up our probabilities.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Lookup the Probabilities}\vspace{3mm}

Look up the probabilities of getting the values in \texttt{Var1}. Then
add them to \texttt{combos} as a column named \texttt{prob1}. Then do
the same for \texttt{Var2} (\texttt{prob2}) and \texttt{Var3}
(\texttt{prob3}).

\end{tcolorbox}

Remember that you use R's selection notation to look up values in a
lookup table. The values that result will be keyed to the index that you
use:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{combos}\SpecialCharTok{$}\NormalTok{prob1 }\OtherTok{\textless{}{-}}\NormalTok{ prob[combos}\SpecialCharTok{$}\NormalTok{Var1]}
\NormalTok{combos}\SpecialCharTok{$}\NormalTok{prob2 }\OtherTok{\textless{}{-}}\NormalTok{ prob[combos}\SpecialCharTok{$}\NormalTok{Var2]}
\NormalTok{combos}\SpecialCharTok{$}\NormalTok{prob3 }\OtherTok{\textless{}{-}}\NormalTok{ prob[combos}\SpecialCharTok{$}\NormalTok{Var3]}

\FunctionTok{head}\NormalTok{(combos, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Var1 Var2 Var3 prob1 prob2 prob3}
\DocumentationTok{\#\#   DD   DD   DD  0.03  0.03  0.03}
\DocumentationTok{\#\#    7   DD   DD  0.03  0.03  0.03}
\DocumentationTok{\#\#  BBB   DD   DD  0.06  0.03  0.03}
\end{Highlighting}
\end{Shaded}

Now how should we calculate the total probability of each combination?
Our three slot symbols are all chosen independently, which means that
the same rule that governed our dice probabilities governs our symbol
probabilities:

\[
P(A \& B \& C \& ...) = P(A) \cdot P(B) \cdot P(C) \cdot ...
\]

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Calculate Probabilities for Each Combination}\vspace{3mm}

Calculate the overall probabilities for each combination. Save them as a
column named \texttt{prob} in \texttt{combos}, then check your work.

You can check that the math worked by summing the probabilities. The
probabilities should add up to one, because one of the combinations
\emph{must} appear when you play the slot machine. In other words, a
combination will appear, with probability of one.

\end{tcolorbox}

You can calculate the probabilities of every possible combination in one
fell swoop with some element-wise execution:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{combos}\SpecialCharTok{$}\NormalTok{prob }\OtherTok{\textless{}{-}}\NormalTok{ combos}\SpecialCharTok{$}\NormalTok{prob1 }\SpecialCharTok{*}\NormalTok{ combos}\SpecialCharTok{$}\NormalTok{prob2 }\SpecialCharTok{*}\NormalTok{ combos}\SpecialCharTok{$}\NormalTok{prob3}

\FunctionTok{head}\NormalTok{(combos, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Var1 Var2 Var3 prob1 prob2 prob3     prob}
\DocumentationTok{\#\#   DD   DD   DD  0.03  0.03  0.03 0.000027}
\DocumentationTok{\#\#    7   DD   DD  0.03  0.03  0.03 0.000027}
\DocumentationTok{\#\#  BBB   DD   DD  0.06  0.03  0.03 0.000054}
\end{Highlighting}
\end{Shaded}

The sum of the probabilities is one, which suggests that our math is
correct:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(combos}\SpecialCharTok{$}\NormalTok{prob)}
\DocumentationTok{\#\# 1}
\end{Highlighting}
\end{Shaded}

You only need to do one more thing before you can calculate the expected
value: you must determine the prize for each combination in
\texttt{combos}. You can calculate the prize with \texttt{score}. For
example, we can calculate the prize for the first row of \texttt{combos}
like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(combos[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{], combos[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{], combos[}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\DocumentationTok{\#\# "DD" "DD" "DD"}

\FunctionTok{score}\NormalTok{(symbols)}
\DocumentationTok{\#\# 800}
\end{Highlighting}
\end{Shaded}

However there are 343 rows, which makes for tedious work if you plan to
calculate the scores manually. It will be quicker to automate this task
and have R do it for you, which you can do with a \texttt{for} loop.

\section{for Loops}\label{for-loops}

A \texttt{for} loop repeats a chunk of code many times, once for each
element in a set of input. \texttt{for} loops provide a way to tell R,
``Do this for every value of that.'' In R syntax, this looks like:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (value }\ControlFlowTok{in}\NormalTok{ that) \{}
\NormalTok{  this}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{that} object should be a set of objects (often a vector of
numbers or character strings). The for loop will run the code in that
appears between the braces once for each member of \texttt{that}. For
example, the for loop below runs \texttt{print("one\ run")} once for
each element in a vector of character strings:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (value }\ControlFlowTok{in} \FunctionTok{c}\NormalTok{(}\StringTok{"My"}\NormalTok{, }\StringTok{"first"}\NormalTok{, }\StringTok{"for"}\NormalTok{, }\StringTok{"loop"}\NormalTok{)) \{}
  \FunctionTok{print}\NormalTok{(}\StringTok{"one run"}\NormalTok{)}
\NormalTok{\}}
\DocumentationTok{\#\# "one run"}
\DocumentationTok{\#\# "one run"}
\DocumentationTok{\#\# "one run"}
\DocumentationTok{\#\# "one run"}
\end{Highlighting}
\end{Shaded}

The \texttt{value} symbol in a for loop acts like an argument in a
function. The for loop will create an object named \texttt{value} and
assign it a new value on each run of the loop. The code in your loop can
access this value by calling the \texttt{value} object.

What values will the for loop assign to \texttt{value}? It will use the
elements in the set that you run the loop on. \texttt{for} starts with
the first element and then assigns a different element to \texttt{value}
on each run of the for loop, until all of the elements have been
assigned to \texttt{value}. For example, the for loop below will run
\texttt{print(value)} four times and will print out one element of
\texttt{c("My",\ "second",\ "for",\ "loop")} each time:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (value }\ControlFlowTok{in} \FunctionTok{c}\NormalTok{(}\StringTok{"My"}\NormalTok{, }\StringTok{"second"}\NormalTok{, }\StringTok{"for"}\NormalTok{, }\StringTok{"loop"}\NormalTok{)) \{}
  \FunctionTok{print}\NormalTok{(value)}
\NormalTok{\}}
\DocumentationTok{\#\# "My"}
\DocumentationTok{\#\# "second"}
\DocumentationTok{\#\# "for"}
\DocumentationTok{\#\# "loop"}
\end{Highlighting}
\end{Shaded}

On the first run, the for loop substituted \texttt{"My"} for
\texttt{value} in \texttt{print(value)}. On the second run it
substituted \texttt{"second"}, and so on until \texttt{for} had run
\texttt{print(value)} once with every element in the set:

If you look at \texttt{value} after the loop runs, you will see that it
still contains the value of the last element in the set:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{value}
\DocumentationTok{\#\# "loop"}
\end{Highlighting}
\end{Shaded}

I've been using the symbol \texttt{value} in my for loops, but there is
nothing special about it. You can use any symbol you like in your loop
to do the same thing as long as the symbol appears before \texttt{in} in
the parentheses that follow \texttt{for}. For example, you could rewrite
the previous loop with any of the following:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (word }\ControlFlowTok{in} \FunctionTok{c}\NormalTok{(}\StringTok{"My"}\NormalTok{, }\StringTok{"second"}\NormalTok{, }\StringTok{"for"}\NormalTok{, }\StringTok{"loop"}\NormalTok{)) \{}
  \FunctionTok{print}\NormalTok{(word)}
\NormalTok{\}}
\ControlFlowTok{for}\NormalTok{ (string }\ControlFlowTok{in} \FunctionTok{c}\NormalTok{(}\StringTok{"My"}\NormalTok{, }\StringTok{"second"}\NormalTok{, }\StringTok{"for"}\NormalTok{, }\StringTok{"loop"}\NormalTok{)) \{}
  \FunctionTok{print}\NormalTok{(string)}
\NormalTok{\}}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \FunctionTok{c}\NormalTok{(}\StringTok{"My"}\NormalTok{, }\StringTok{"second"}\NormalTok{, }\StringTok{"for"}\NormalTok{, }\StringTok{"loop"}\NormalTok{)) \{}
  \FunctionTok{print}\NormalTok{(i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-warning-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Choose your symbols carefully}, toprule=.15mm]

R will run your loop in whichever environment you call it from. This is
bad news if your loop uses object names that already exist in the
environment. Your loop will overwrite the existing objects with the
objects that it creates. This applies to the value symbol as well.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{For loops run on sets}, toprule=.15mm]

In many programming languages, \texttt{for} loops are designed to work
with integers, not sets. You give the loop a starting value and an
ending value, as well as an increment to advance the value by between
loops. The \texttt{for} loop then runs until the loop value exceeds the
ending value.

You can recreate this effect in R by having a \texttt{for} loop execute
on a set of integers, but don't lose track of the fact that R's
\texttt{for} loops execute on members of a set, not sequences of
integers.

\end{tcolorbox}

\texttt{for} loops are very useful in programming because they help you
connect a piece of code with each element in a set. For example, we
could use a \texttt{for} loop to run \texttt{score} once for each row in
\texttt{combos}. However, R's \texttt{for} loops have a shortcoming that
you'll want to know about before you start using them: \texttt{for}
loops do not return output.

\texttt{for} loops are like Las Vegas: what happens in a \texttt{for}
loop stays in a \texttt{for} loop. If you want to use the products of a
\texttt{for} loop, you must write the \texttt{for} loop so that it saves
its own output as it goes.

Our previous examples appeared to return output, but this was
misleading. The examples worked because we called \texttt{print}, which
always prints its arguments in the console (even if it is called from a
function, a \texttt{for} loop, or anything else). Our \texttt{for} loops
won't return anything if you remove the \texttt{print} call:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (value }\ControlFlowTok{in} \FunctionTok{c}\NormalTok{(}\StringTok{"My"}\NormalTok{, }\StringTok{"third"}\NormalTok{, }\StringTok{"for"}\NormalTok{, }\StringTok{"loop"}\NormalTok{)) \{}
\NormalTok{  value}
\NormalTok{\}}
\DocumentationTok{\#\#}
\end{Highlighting}
\end{Shaded}

To save output from a \texttt{for} loop, you must write the loop so that
it saves its own output as it runs. You can do this by creating an empty
vector or list before you run the \texttt{for} loop. Then use the
\texttt{for} loop to fill up the vector or list. When the \texttt{for}
loop is finished, you'll be able to access the vector or list, which
will now have all of your results.

Let's see this in action. The following code creates an empty vector of
length 4:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chars }\OtherTok{\textless{}{-}} \FunctionTok{vector}\NormalTok{(}\AttributeTok{length =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The next loop will fill it with strings:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{words }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"My"}\NormalTok{, }\StringTok{"fourth"}\NormalTok{, }\StringTok{"for"}\NormalTok{, }\StringTok{"loop"}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{) \{}
\NormalTok{  chars[i] }\OtherTok{\textless{}{-}}\NormalTok{ words[i]}
\NormalTok{\}}

\NormalTok{chars}
\DocumentationTok{\#\# "My"    "fourth" "for"   "loop"}
\end{Highlighting}
\end{Shaded}

This approach will usually require you to change the sets that you
execute your \texttt{for} loop on. Instead of executing on a set of
objects, execute on a set of integers that you can use to index both
your object and your storage vector. This approach is very common in R.
You'll find in practice that you use \texttt{for} loops not so much to
run code, but to fill up vectors and lists with the results of code.

Let's use a \texttt{for} loop to calculate the prize for each row in
\texttt{combos}. To begin, create a new column in \texttt{combos} to
store the results of the \texttt{for} loop:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{combos}\SpecialCharTok{$}\NormalTok{prize }\OtherTok{\textless{}{-}} \ConstantTok{NA}

\FunctionTok{head}\NormalTok{(combos, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\#  Var1 Var2 Var3 prob1 prob2 prob3     prob prize}
\DocumentationTok{\#\#    DD   DD   DD  0.03  0.03  0.03 0.000027    NA}
\DocumentationTok{\#\#     7   DD   DD  0.03  0.03  0.03 0.000027    NA}
\DocumentationTok{\#\#   BBB   DD   DD  0.06  0.03  0.03 0.000054    NA}
\end{Highlighting}
\end{Shaded}

The code creates a new column named prize and fills it with
\texttt{NA}s. R uses its recycling rules to populate every value of the
column with \texttt{NA}.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Build a Loop}\vspace{3mm}

Construct a \texttt{for} loop that will run \texttt{score} on all 343
rows of \texttt{combos}. The loop should run \texttt{score} on the first
three entries of the \_i\_th row of \texttt{combos} and should store the
results in the \_i\_th entry of \texttt{combos\$prize}.

\end{tcolorbox}

You can score the rows in \texttt{combos} with:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(combos)) \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(combos[i, }\DecValTok{1}\NormalTok{], combos[i, }\DecValTok{2}\NormalTok{], combos[i, }\DecValTok{3}\NormalTok{])}
\NormalTok{  combos}\SpecialCharTok{$}\NormalTok{prize[i] }\OtherTok{\textless{}{-}} \FunctionTok{score}\NormalTok{(symbols)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

After you run the for loop, \texttt{combos\$prize} will contain the
correct prize for each row. This exercise also tests the \texttt{score}
function; \texttt{score} appears to work correctly for every possible
slot combination:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(combos, }\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Var1 Var2 Var3 prob1 prob2 prob3     prob prize}
\DocumentationTok{\#\#   DD   DD   DD  0.03  0.03  0.03 0.000027   800}
\DocumentationTok{\#\#    7   DD   DD  0.03  0.03  0.03 0.000027     0}
\DocumentationTok{\#\#  BBB   DD   DD  0.06  0.03  0.03 0.000054     0}
\end{Highlighting}
\end{Shaded}

We're now ready to calculate the expected value of the prize. The
expected value is the sum of \texttt{combos\$prize} weighted by
\texttt{combos\$prob}. This is also the payout rate of the slot machine:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(combos}\SpecialCharTok{$}\NormalTok{prize }\SpecialCharTok{*}\NormalTok{ combos}\SpecialCharTok{$}\NormalTok{prob)}
\DocumentationTok{\#\# 0.538014}
\end{Highlighting}
\end{Shaded}

Uh oh. The expected prize is about 0.54, which means our slot machine
only pays 54 cents on the dollar over the long run. Does this mean that
the manufacturer of the Manitoba slot machines \emph{was} lying?

No, because we ignored an important feature of the slot machine when we
wrote \texttt{score}: a diamond is wild. You can treat a \texttt{DD} as
any other symbol if it increases your prize, with one exception. You
cannot make a \texttt{DD} a \texttt{C} unless you already have another
\texttt{C} in your symbols (it'd be too easy if every \texttt{DD}
automatically earned you \$2).

The best thing about \texttt{DD}s is that their effects are cumulative.
For example, consider the combination \texttt{B}, \texttt{DD},
\texttt{B}. Not only does the \texttt{DD} count as a \texttt{B}, which
would earn a prize of \$10; the \texttt{DD} also doubles the prize to
\$20.

Adding this behavior to our code is a little tougher than what we have
done so far, but it involves all of the same principles. You can decide
that your slot machine doesn't use wilds and keep the code that we have.
In that case, your slot machine will have a payout rate of about 54
percent. Or, you could rewrite your code to use wilds. If you do, you
will find that your slot machine has a payout rate of 93 percent, one
percent higher than the manufacturer's claim. You can calculate this
rate with the same method that we used in this section.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Challenge}\vspace{3mm}

There are many ways to modify \texttt{score} that would count
\texttt{DD}s as wild. If you would like to test your skill as an R
programmer, try to write your own version of \texttt{score} that
correctly handles diamonds.

If you would like a more modest challenge, study the following
\texttt{score} code. It accounts for wild diamonds in a way that I find
elegant and succinct. See if you can understand each step in the code
and how it achieves its result.

\end{tcolorbox}

Here is a version of score that handles wild diamonds:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{score }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(symbols) \{}
  
\NormalTok{  diamonds }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{)}
\NormalTok{  cherries }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{)}
  
  \CommentTok{\# identify case}
  \CommentTok{\# since diamonds are wild, only nondiamonds }
  \CommentTok{\# matter for three of a kind and all bars}
\NormalTok{  slots }\OtherTok{\textless{}{-}}\NormalTok{ symbols[symbols }\SpecialCharTok{!=} \StringTok{"DD"}\NormalTok{]}
\NormalTok{  same }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(}\FunctionTok{unique}\NormalTok{(slots)) }\SpecialCharTok{==} \DecValTok{1}
\NormalTok{  bars }\OtherTok{\textless{}{-}}\NormalTok{ slots }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}

  \CommentTok{\# assign prize}
  \ControlFlowTok{if}\NormalTok{ (diamonds }\SpecialCharTok{==} \DecValTok{3}\NormalTok{) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{    payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{,}
      \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \FunctionTok{unname}\NormalTok{(payouts[slots[}\DecValTok{1}\NormalTok{]])}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (cherries }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{) \{}
    \CommentTok{\# diamonds count as cherries}
    \CommentTok{\# so long as there is one real cherry}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+}\NormalTok{ diamonds }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{  \}}
  
  \CommentTok{\# double for each diamond}
\NormalTok{  prize }\SpecialCharTok{*} \DecValTok{2}\SpecialCharTok{\^{}}\NormalTok{diamonds}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Calculate the Expected Value}\vspace{3mm}

Calculate the expected value of the slot machine when it uses the new
\texttt{score} function. You can use the existing \texttt{combos} data
frame, but you will need to build a \texttt{for} loop to recalculate
\texttt{combos\$prize}.

\end{tcolorbox}

To update the expected value, just update \texttt{combos\$prize}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(combos)) \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(combos[i, }\DecValTok{1}\NormalTok{], combos[i, }\DecValTok{2}\NormalTok{], combos[i, }\DecValTok{3}\NormalTok{])}
\NormalTok{  combos}\SpecialCharTok{$}\NormalTok{prize[i] }\OtherTok{\textless{}{-}} \FunctionTok{score}\NormalTok{(symbols)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Then recompute the expected value:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(combos}\SpecialCharTok{$}\NormalTok{prize }\SpecialCharTok{*}\NormalTok{ combos}\SpecialCharTok{$}\NormalTok{prob)}
\DocumentationTok{\#\# 0.934356}
\end{Highlighting}
\end{Shaded}

This result vindicates the manufacturer's claim. If anything, the slot
machines seem more generous than the manufacturer stated.

\section{while Loops}\label{while-loops}

R has two companions to the \texttt{for} loop: the \texttt{while} loop
and the \texttt{repeat} loop. A \texttt{while} loop reruns a chunk
\emph{while} a certain condition remains \texttt{TRUE}. To create a
\texttt{while} loop, follow \texttt{while} by a condition and a chunk of
code, like this:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while}\NormalTok{ (condition) \{}
\NormalTok{  code}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{while} will rerun \texttt{condition}, which should be a logical
test, at the start of each loop. If \texttt{condition} evaluates to
\texttt{TRUE}, \texttt{while} will run the code between its braces. If
\texttt{condition} evaluates to \texttt{FALSE}, \texttt{while} will
finish the loop.

Why might \texttt{condition} change from \texttt{TRUE} to
\texttt{FALSE}? Presumably because the code inside your loop has changed
whether the condition is still \texttt{TRUE}. If the code has no
relationship to the condition, a \texttt{while} loop will run until you
stop it. So be careful. You can stop a \texttt{while} loop by hitting
Escape or by clicking on the stop-sign icon at the top of the RStudio
console pane. The icon will appear once the loop begins to run.

Like \texttt{for} loops, \texttt{while} loops do not return a result, so
you must think about what you want the loop to return and save it to an
object during the loop.

You can use \texttt{while} loops to do things that take a varying number
of iterations, like calculating how long it takes to go broke playing
slots (as follows). However, in practice, \texttt{while} loops are much
less common than \texttt{for} loops in R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plays\_till\_broke }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(start\_with) \{}
\NormalTok{  cash }\OtherTok{\textless{}{-}}\NormalTok{ start\_with}
\NormalTok{  n }\OtherTok{\textless{}{-}} \DecValTok{0}
  \ControlFlowTok{while}\NormalTok{ (cash }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{) \{}
\NormalTok{    cash }\OtherTok{\textless{}{-}}\NormalTok{ cash }\SpecialCharTok{{-}} \DecValTok{1} \SpecialCharTok{+} \FunctionTok{play}\NormalTok{()}
\NormalTok{    n }\OtherTok{\textless{}{-}}\NormalTok{ n }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{  \}}
\NormalTok{  n}
\NormalTok{\}}

\FunctionTok{plays\_till\_broke}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\DocumentationTok{\#\# 260}
\end{Highlighting}
\end{Shaded}

\section{repeat Loops}\label{repeat-loops}

\texttt{repeat} loops are even more basic than \texttt{while} loops.
They will repeat a chunk of code until you tell them to stop (by hitting
Escape) or until they encounter the command \texttt{break}, which will
stop the loop.

You can use a \texttt{repeat} loop to recreate
\texttt{plays\_till\_broke}, my function that simulates how long it
takes to lose money while playing slots:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plays\_till\_broke }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(start\_with) \{}
\NormalTok{  cash }\OtherTok{\textless{}{-}}\NormalTok{ start\_with}
\NormalTok{  n }\OtherTok{\textless{}{-}} \DecValTok{0}
  \ControlFlowTok{repeat}\NormalTok{ \{}
\NormalTok{    cash }\OtherTok{\textless{}{-}}\NormalTok{ cash }\SpecialCharTok{{-}} \DecValTok{1} \SpecialCharTok{+} \FunctionTok{play}\NormalTok{()}
\NormalTok{    n }\OtherTok{\textless{}{-}}\NormalTok{ n }\SpecialCharTok{+} \DecValTok{1}
    \ControlFlowTok{if}\NormalTok{ (cash }\SpecialCharTok{\textless{}=} \DecValTok{0}\NormalTok{) \{}
      \ControlFlowTok{break}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  n}
\NormalTok{\}}

\FunctionTok{plays\_till\_broke}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\DocumentationTok{\#\# 237}
\end{Highlighting}
\end{Shaded}

\section{Summary}\label{summary-8}

You can repeat tasks in R with \texttt{for}, \texttt{while}, and
\texttt{repeat} loops. To use \texttt{for}, give it a chunk of code to
run and a set of objects to loop through. \texttt{for} will run the code
chunk once for each object. If you wish to save the output of your loop,
you can assign it to an object that exists outside of the loop.

Repetition plays an important role in data science. It is the basis for
simulation, as well as for estimates of variance and probability. Loops
are not the only way to create repetition in R (consider
\texttt{replicate} for example), but they are one of the most popular
ways.

Unfortunately, loops in R can sometimes be slower than loops in other
languages. As a result, R's loops get a bad rap. This reputation is not
entirely deserved, but it does highlight an important issue. Speed is
essential to data analysis. When your code runs fast, you can work with
bigger data and do more to it before you run out of time or
computational power. \hyperref[sec-speed]{Speed} will teach you how to
write fast \texttt{for} loops and fast code in general with R. There,
you will learn to write vectorized code, a style of lightning-fast code
that takes advantage of all of R's strengths.

\chapter{Speed}\label{sec-speed}

As a data scientist, you need speed. You can work with bigger data and
do more ambitious tasks when your code runs fast. This chapter will show
you a specific way to write fast code in R. You will then use the method
to simulate 10 million plays of your slot machine.

\section{Vectorized Code}\label{vectorized-code}

You can write a piece of code in many different ways, but the fastest R
code will usually take advantage of three things: logical tests,
subsetting, and element-wise execution. These are the things that R does
best. Code that uses these things usually has a certain quality: it is
\emph{vectorized}; the code can take a vector of values as input and
manipulate each value in the vector at the same time.

To see what vectorized code looks like, compare these two examples of an
absolute value function. Each takes a vector of numbers and transforms
it into a vector of absolute values (e.g., positive numbers). The first
example is not vectorized; \texttt{abs\_loop} uses a \texttt{for} loop
to manipulate each element of the vector one at a time:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{abs\_loop }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(vec)\{}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(vec)) \{}
    \ControlFlowTok{if}\NormalTok{ (vec[i] }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{) \{}
\NormalTok{      vec[i] }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\NormalTok{vec[i]}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  vec}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The second example, \texttt{abs\_set}, is a vectorized version of
\texttt{abs\_loop}. It uses logical subsetting to manipulate every
negative number in the vector at the same time:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{abs\_sets }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(vec)\{}
\NormalTok{  negs }\OtherTok{\textless{}{-}}\NormalTok{ vec }\SpecialCharTok{\textless{}} \DecValTok{0}
\NormalTok{  vec[negs] }\OtherTok{\textless{}{-}}\NormalTok{ vec[negs] }\SpecialCharTok{*} \SpecialCharTok{{-}}\DecValTok{1}
\NormalTok{  vec}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{abs\_set} is much faster than \texttt{abs\_loop} because it
relies on operations that R does quickly: logical tests, subsetting, and
element-wise execution.

You can use the \texttt{system.time} function to see just how fast
\texttt{abs\_set} is. \texttt{system.time} takes an R expression, runs
it, and then displays how much time elapsed while the expression ran.

To compare \texttt{abs\_loop} and \texttt{abs\_set}, first make a long
vector of positive and negative numbers. \texttt{long} will contain 10
million values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{long }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DecValTok{5000000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

\texttt{rep} repeats a value, or vector of values, many times. To use
\texttt{rep}, give it a vector of values and then the number of times to
repeat the vector. R will return the results as a new, longer vector.

\end{tcolorbox}

You can then use \texttt{system.time} to measure how much time it takes
each function to evaluate \texttt{long}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(}\FunctionTok{abs\_loop}\NormalTok{(long))}
\DocumentationTok{\#\#    user  system elapsed }
\DocumentationTok{\#\#  15.982   0.032  16.018}

\FunctionTok{system.time}\NormalTok{(}\FunctionTok{abs\_sets}\NormalTok{(long))}
\DocumentationTok{\#\#    user  system elapsed }
\DocumentationTok{\#\#   0.529   0.063   0.592}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-important-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-important-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important}, toprule=.15mm]

Don't confuse \texttt{system.time} with \texttt{Sys.time}, which returns
the current time.

\end{tcolorbox}

The first two columns of the output of \texttt{system.time} report how
many seconds your computer spent executing the call on the user side and
system sides of your process, a dichotomy that will vary from OS to OS.

The last column displays how many seconds elapsed while R ran the
expression. The results show that \texttt{abs\_set} calculated the
absolute value 30 times faster than \texttt{abs\_loop} when applied to a
vector of 10 million numbers. You can expect similar speed-ups whenever
you write vectorized code.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: How fast is abs?}\vspace{3mm}

Many preexisting R functions are already vectorized and have been
optimized to perform quickly. You can make your code faster by relying
on these functions whenever possible. For example, R comes with a
built-in absolute value function, \texttt{abs}.

Check to see how much faster \texttt{abs} computes the absolute value of
\texttt{long} than \texttt{abs\_loop} and \texttt{abs\_set} do.

\end{tcolorbox}

You can measure the speed of \texttt{abs} with \texttt{system.time}. It
takes \texttt{abs} a lightning-fast 0.05 seconds to calculate the
absolute value of 10 million numbers. This is 0.592 / 0.054 = 10.96
times faster than \texttt{abs\_set} and nearly 300 times faster than
\texttt{abs\_loop}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(}\FunctionTok{abs}\NormalTok{(long))}
\DocumentationTok{\#\#   user  system elapsed }
\DocumentationTok{\#\#  0.037   0.018   0.054}
\end{Highlighting}
\end{Shaded}

\section{How to Write Vectorized
Code}\label{how-to-write-vectorized-code}

Vectorized code is easy to write in R because most R functions are
already vectorized. Code based on these functions can easily be made
vectorized and therefore fast. To create vectorized code:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Use vectorized functions to complete the sequential steps in your
  program.
\item
  Use logical subsetting to handle parallel cases. Try to manipulate
  every element in a case at once.
\end{enumerate}

\texttt{abs\_loop} and \texttt{abs\_set} illustrate these rules. The
functions both handle two cases and perform one sequential step,
Figure~\ref{fig-abs}. If a number is positive, the functions leave it
alone. If a number is negative, the functions multiply it by negative
one.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_1001.png}}

}

\caption{\label{fig-abs}\texttt{abs\_loop} uses a for loop to sift data
into one of two cases: negative numbers and nonnegative numbers.}

\end{figure}%

You can identify all of the elements of a vector that fall into a case
with a logical test. R will execute the test in element-wise fashion and
return a \texttt{TRUE} for every element that belongs in the case. For
example, \texttt{vec\ \textless{}\ 0} identifies every value of
\texttt{vec} that belongs to the negative case. You can use the same
logical test to extract the set of negative values with logical
subsetting:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{10}\NormalTok{)}
\NormalTok{vec }\SpecialCharTok{\textless{}} \DecValTok{0}
\DocumentationTok{\#\# FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE}

\NormalTok{vec[vec }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{]}
\DocumentationTok{\#\# {-}2  {-}4  {-}6  {-}8 {-}10}
\end{Highlighting}
\end{Shaded}

The plan in Figure~\ref{fig-abs} now requires a sequential step: you
must multiply each of the negative values by negative one. All of R's
arithmetic operators are vectorized, so you can use \texttt{*} to
complete this step in vectorized fashion. \texttt{*} will multiply each
number in \texttt{vec{[}vec\ \textless{}\ 0{]}} by negative one at the
same time:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec[vec }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{] }\SpecialCharTok{*} \SpecialCharTok{{-}}\DecValTok{1}
\DocumentationTok{\#\# 2  4  6  8 10}
\end{Highlighting}
\end{Shaded}

Finally, you can use R's assignment operator, which is also vectorized,
to save the new set over the old set in the original \texttt{vec}
object. Since \texttt{\textless{}-} is vectorized, the elements of the
new set will be paired up to the elements of the old set, in order, and
then element-wise assignment will occur. As a result, each negative
value will be replaced by its positive partner, as in
Figure~\ref{fig-assignment}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_1002.png}}

}

\caption{\label{fig-assignment}Use logical subsetting to modify groups
of values in place. R's arithmetic and assignment operators are
vectorized, which lets you manipulate and update multiple values at
once.}

\end{figure}%

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Vectorize a Function}\vspace{3mm}

The following function converts a vector of slot symbols to a vector of
new slot symbols. Can you vectorize it? How much faster does the
vectorized version work?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{change\_symbols }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(vec)\{}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(vec))\{}
    \ControlFlowTok{if}\NormalTok{ (vec[i] }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{) \{}
\NormalTok{      vec[i] }\OtherTok{\textless{}{-}} \StringTok{"joker"}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (vec[i] }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{) \{}
\NormalTok{      vec[i] }\OtherTok{\textless{}{-}} \StringTok{"ace"}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (vec[i] }\SpecialCharTok{==} \StringTok{"7"}\NormalTok{) \{}
\NormalTok{      vec[i] }\OtherTok{\textless{}{-}} \StringTok{"king"}
\NormalTok{    \}}\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (vec[i] }\SpecialCharTok{==} \StringTok{"B"}\NormalTok{) \{}
\NormalTok{      vec[i] }\OtherTok{\textless{}{-}} \StringTok{"queen"}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (vec[i] }\SpecialCharTok{==} \StringTok{"BB"}\NormalTok{) \{}
\NormalTok{      vec[i] }\OtherTok{\textless{}{-}} \StringTok{"jack"}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (vec[i] }\SpecialCharTok{==} \StringTok{"BBB"}\NormalTok{) \{}
\NormalTok{      vec[i] }\OtherTok{\textless{}{-}} \StringTok{"ten"}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      vec[i] }\OtherTok{\textless{}{-}} \StringTok{"nine"}
\NormalTok{    \} }
\NormalTok{  \}}
\NormalTok{  vec}
\NormalTok{\}}

\NormalTok{vec }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"7"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{, }\StringTok{"0"}\NormalTok{)}

\FunctionTok{change\_symbols}\NormalTok{(vec)}
\DocumentationTok{\#\#  "joker" "ace"   "king"  "queen" "jack"  "ten"   "nine"}

\NormalTok{many }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(vec, }\DecValTok{1000000}\NormalTok{)}

\FunctionTok{system.time}\NormalTok{(}\FunctionTok{change\_symbols}\NormalTok{(many))}
\DocumentationTok{\#\#    user  system elapsed }
\DocumentationTok{\#\#  30.057   0.031  30.079}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\texttt{change\_symbols} uses a \texttt{for} loop to sort values into
seven different cases, as demonstrated in Figure~\ref{fig-change}.

To vectorize \texttt{change\_symbols}, create a logical test that can
identify each case:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{]}
\DocumentationTok{\#\# "DD"}

\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{]}
\DocumentationTok{\#\# "C"}

\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"7"}\NormalTok{]}
\DocumentationTok{\#\# "7"}

\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"B"}\NormalTok{]}
\DocumentationTok{\#\# "B"}

\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"BB"}\NormalTok{]}
\DocumentationTok{\#\# "BB"}

\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"BBB"}\NormalTok{]}
\DocumentationTok{\#\# "BBB"}

\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"0"}\NormalTok{]}
\DocumentationTok{\#\# "0"}
\end{Highlighting}
\end{Shaded}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_1003.png}}

}

\caption{\label{fig-change}\texttt{change\_many} does something
different for each of seven cases.}

\end{figure}%

Then write code that can change the symbols for each case:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"joker"}
\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"ace"}
\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"7"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"king"}
\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"B"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"queen"}
\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"BB"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"jack"}
\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"BBB"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"ten"}
\NormalTok{vec[vec }\SpecialCharTok{==} \StringTok{"0"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"nine"}
\end{Highlighting}
\end{Shaded}

When you combine this into a function, you have a vectorized version of
\texttt{change\_symbols} that runs about 14 times faster:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{change\_vec }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{ (vec) \{}
\NormalTok{  vec[vec }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"joker"}
\NormalTok{  vec[vec }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"ace"}
\NormalTok{  vec[vec }\SpecialCharTok{==} \StringTok{"7"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"king"}
\NormalTok{  vec[vec }\SpecialCharTok{==} \StringTok{"B"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"queen"}
\NormalTok{  vec[vec }\SpecialCharTok{==} \StringTok{"BB"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"jack"}
\NormalTok{  vec[vec }\SpecialCharTok{==} \StringTok{"BBB"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"ten"}
\NormalTok{  vec[vec }\SpecialCharTok{==} \StringTok{"0"}\NormalTok{] }\OtherTok{\textless{}{-}} \StringTok{"nine"}
  
\NormalTok{  vec}
\NormalTok{\}}

\FunctionTok{system.time}\NormalTok{(}\FunctionTok{change\_vec}\NormalTok{(many))}
\DocumentationTok{\#\#   user  system elapsed }
\DocumentationTok{\#\#  1.994   0.059   2.051 }
\end{Highlighting}
\end{Shaded}

Or, even better, use a lookup table. Lookup tables are a vectorized
method because they rely on R's vectorized selection operations:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{change\_vec2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(vec)\{}
\NormalTok{  tb }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \StringTok{"joker"}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \StringTok{"ace"}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \StringTok{"king"}\NormalTok{, }\StringTok{"B"} \OtherTok{=} \StringTok{"queen"}\NormalTok{, }
    \StringTok{"BB"} \OtherTok{=} \StringTok{"jack"}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \StringTok{"ten"}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \StringTok{"nine"}\NormalTok{)}
  \FunctionTok{unname}\NormalTok{(tb[vec])}
\NormalTok{\}}

\FunctionTok{system.time}\NormalTok{(}\FunctionTok{change\_vec}\NormalTok{(many))}
\DocumentationTok{\#\#   user  system elapsed }
\DocumentationTok{\#\#  0.687   0.059   0.746 }
\end{Highlighting}
\end{Shaded}

Here, a lookup table is 40 times faster than the original function.

\texttt{abs\_loop} and \texttt{change\_many} illustrate a characteristic
of vectorized code: programmers often write slower, nonvectorized code
by relying on unnecessary \texttt{for} loops, like the one in
\texttt{change\_many}. I think this is the result of a general
misunderstanding about R. \texttt{for} loops do not behave the same way
in R as they do in other languages, which means you should write code
differently in R than you would in other languages.

When you write in languages like C and Fortran, you must compile your
code before your computer can run it. This compilation step optimizes
how the \texttt{for} loops in the code use your computer's memory, which
makes the \texttt{for} loops very fast. As a result, many programmers
use \texttt{for} loops frequently when they write in C and Fortran.

When you write in R, however, you do not compile your code. You skip
this step, which makes programming in R a more user-friendly experience.
Unfortunately, this also means you do not give your loops the speed
boost they would receive in C or Fortran. As a result, your loops will
run slower than the other operations we have studied: logical tests,
subsetting, and element-wise execution. If you can write your code with
the faster operations instead of a \texttt{for} loop, you should do so.
No matter which language you write in, you should try to use the
features of the language that run the fastest.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{\texttt{if} and \texttt{for}}, toprule=.15mm]

A good way to spot \texttt{for} loops that could be vectorized is to
look for combinations of \texttt{if} and \texttt{for}. \texttt{if} can
only be applied to one value at a time, which means it is often used in
conjunction with a \texttt{for} loop. The \texttt{for} loop helps apply
\texttt{if} to an entire vector of values. This combination can usually
be replaced with logical subsetting, which will do the same thing but
run much faster.

\end{tcolorbox}

This doesn't mean that you should never use \texttt{for} loops in R.
There are still many places in R where \texttt{for} loops make sense.
\texttt{for} loops perform a basic task that you cannot always recreate
with vectorized code. \texttt{for} loops are also easy to understand and
run reasonably fast in R, so long as you take a few precautions.

\section{How to Write Fast for Loops in
R}\label{how-to-write-fast-for-loops-in-r}

You can dramatically increase the speed of your \texttt{for} loops by
doing two things to optimize each loop. First, do as much as you can
outside of the \texttt{for} loop. Every line of code that you place
inside of the \texttt{for} loop will be run many, many times. If a line
of code only needs to be run once, place it outside of the loop to avoid
repetition.

Second, make sure that any storage objects that you use with the loop
are large enough to contain \emph{all} of the results of the loop. For
example, both loops below will need to store one million values. The
first loop stores its values in an object named \texttt{output} that
begins with a length of \emph{one million}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(\{}
\NormalTok{  output }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\ConstantTok{NA}\NormalTok{, }\DecValTok{1000000}\NormalTok{) }
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{1000000}\NormalTok{) \{}
\NormalTok{    output[i] }\OtherTok{\textless{}{-}}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{  \}}
\NormalTok{\})}
\DocumentationTok{\#\#   user  system elapsed }
\DocumentationTok{\#\#  1.709   0.015   1.724 }
\end{Highlighting}
\end{Shaded}

The second loop stores its values in an object named \texttt{output}
that begins with a length of \emph{one}. R will expand the object to a
length of one million as it runs the loop. The code in this loop is very
similar to the code in the first loop, but the loop takes \emph{37
minutes} longer to run than the first loop:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(\{}
\NormalTok{  output }\OtherTok{\textless{}{-}} \ConstantTok{NA} 
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{1000000}\NormalTok{) \{}
\NormalTok{    output[i] }\OtherTok{\textless{}{-}}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{  \}}
\NormalTok{\})}
\DocumentationTok{\#\#     user   system  elapsed }
\DocumentationTok{\#\# 1689.537  560.951 2249.927}
\end{Highlighting}
\end{Shaded}

The two loops do the same thing, so what accounts for the difference? In
the second loop, R has to increase the length of \texttt{output} by one
for each run of the loop. To do this, R needs to find a new place in
your computer's memory that can contain the larger object. R must then
copy the \texttt{output} vector over and erase the old version of
\texttt{output} before moving on to the next run of the loop. By the end
of the loop, R has rewritten \texttt{output} in your computer's memory
one million times.

In the first case, the size of \texttt{output} never changes; R can
define one \texttt{output} object in memory and use it for each run of
the \texttt{for} loop.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, toprule=.15mm]

The authors of R use low-level languages like C and Fortran to write
basic R functions, many of which use \texttt{for} loops. These functions
are compiled and optimized before they become a part of R, which makes
them quite fast.

Whenever you see \texttt{.Primitive}, \texttt{.Internal}, or
\texttt{.Call} written in a function's definition, you can be confident
the function is calling code from another language. You'll get all of
the speed advantages of that language by using the function.

\end{tcolorbox}

\section{Vectorized Code in Practice}\label{vectorized-code-in-practice}

To see how vectorized code can help you as a data scientist, consider
our slot machine project. In \hyperref[sec-loops]{Loops}, you calculated
the exact payout rate for your slot machine, but you could have
estimated this payout rate with a simulation. If you played the slot
machine many, many times, the average prize over all of the plays would
be a good estimate of the true payout rate.

This method of estimation is based on the law of large numbers and is
similar to many statistical simulations. To run this simulation, you
could use a \texttt{for} loop:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{winnings }\OtherTok{\textless{}{-}} \FunctionTok{vector}\NormalTok{(}\AttributeTok{length =} \DecValTok{1000000}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{1000000}\NormalTok{) \{}
\NormalTok{  winnings[i] }\OtherTok{\textless{}{-}} \FunctionTok{play}\NormalTok{()}
\NormalTok{\}}

\FunctionTok{mean}\NormalTok{(winnings)}
\DocumentationTok{\#\# 0.9366984}
\end{Highlighting}
\end{Shaded}

The estimated payout rate after 10 million runs is 0.937, which is very
close to the true payout rate of 0.934. Note that I'm using the modified
\texttt{score} function that treats diamonds as wilds.

If you run this simulation, you will notice that it takes a while to
run. In fact, the simulation takes 342,308 seconds to run, which is
about 5.7 minutes. This is not particularly impressive, and you can do
better by using vectorized code:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{system.time}\NormalTok{(}\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{1000000}\NormalTok{) \{}
\NormalTok{  winnings[i] }\OtherTok{\textless{}{-}} \FunctionTok{play}\NormalTok{()}
\NormalTok{\})}
\DocumentationTok{\#\#    user  system elapsed }
\DocumentationTok{\#\# 342.041   0.355 342.308 }
\end{Highlighting}
\end{Shaded}

The current \texttt{score} function is not vectorized. It takes a single
slot combination and uses an \texttt{if} tree to assign a prize to it.
This combination of an \texttt{if} tree with a \texttt{for} loop
suggests that you could write a piece of vectorized code that takes
\emph{many} slot combinations and then uses logical subsetting to
operate on them all at once.

For example, you could rewrite \texttt{get\_symbols} to generate
\emph{n} slot combinations and return them as an \emph{n} x 3 matrix,
like the one that follows. Each row of the matrix will contain one slot
combination to be scored:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get\_many\_symbols }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n) \{}
\NormalTok{  wheel }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"}\NormalTok{, }\StringTok{"7"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"0"}\NormalTok{)}
\NormalTok{  vec }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(wheel, }\AttributeTok{size =} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ n, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{,}
    \AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.03}\NormalTok{, }\FloatTok{0.03}\NormalTok{, }\FloatTok{0.06}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.25}\NormalTok{, }\FloatTok{0.01}\NormalTok{, }\FloatTok{0.52}\NormalTok{))}
  \FunctionTok{matrix}\NormalTok{(vec, }\AttributeTok{ncol =} \DecValTok{3}\NormalTok{)}
\NormalTok{\}}

\FunctionTok{get\_many\_symbols}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\DocumentationTok{\#\#      [,1]  [,2] [,3] }
\DocumentationTok{\#\# [1,] "B"   "0"  "B"  }
\DocumentationTok{\#\# [2,] "0"   "BB" "7"  }
\DocumentationTok{\#\# [3,] "0"   "0"  "BBB"}
\DocumentationTok{\#\# [4,] "0"   "0"  "B"  }
\DocumentationTok{\#\# [5,] "BBB" "0"  "0" }
\end{Highlighting}
\end{Shaded}

You could also rewrite \texttt{play} to take a parameter, \texttt{n},
and return \texttt{n} prizes, in a data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{play\_many }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n) \{}
\NormalTok{  symb\_mat }\OtherTok{\textless{}{-}} \FunctionTok{get\_many\_symbols}\NormalTok{(}\AttributeTok{n =}\NormalTok{ n)}
  \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{w1 =}\NormalTok{ symb\_mat[,}\DecValTok{1}\NormalTok{], }\AttributeTok{w2 =}\NormalTok{ symb\_mat[,}\DecValTok{2}\NormalTok{],}
             \AttributeTok{w3 =}\NormalTok{ symb\_mat[,}\DecValTok{3}\NormalTok{], }\AttributeTok{prize =} \FunctionTok{score\_many}\NormalTok{(symb\_mat))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This new function would make it easy to simulate a million, or even 10
million plays of the slot machine, which will be our goal. When we're
finished, you will be able to estimate the payout rate with:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# plays \textless{}{-} play\_many(10000000))}
\CommentTok{\# mean(plays$prize)}
\end{Highlighting}
\end{Shaded}

Now you just need to write \texttt{score\_many}, a vectorized
(matix-ized?) version of \texttt{score} that takes an \emph{n} x 3
matrix and returns \emph{n} prizes. It will be difficult to write this
function because \texttt{score} is already quite complicated. I would
not expect you to feel confident doing this on your own until you have
more practice and experience than we've been able to develop here.

Should you like to test your skills and write a version of
\texttt{score\_many}, I recommend that you use the function
\texttt{rowSums} within your code. It calculates the sum of each row of
numbers (or logicals) in a matrix.

If you would like to test yourself in a more modest way, I recommend
that you study the following model \texttt{score\_many} function until
you understand how each part works and how the parts work together to
create a vectorized function. To do this, it will be helpful to create a
concrete example, like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{symbols }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}
  \FunctionTok{c}\NormalTok{(}\StringTok{"DD"}\NormalTok{, }\StringTok{"DD"}\NormalTok{, }\StringTok{"DD"}\NormalTok{, }
    \StringTok{"C"}\NormalTok{, }\StringTok{"DD"}\NormalTok{, }\StringTok{"0"}\NormalTok{, }
    \StringTok{"B"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }
    \StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{, }
    \StringTok{"C"}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"0"}\NormalTok{, }
    \StringTok{"7"}\NormalTok{, }\StringTok{"DD"}\NormalTok{, }\StringTok{"DD"}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{6}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}

\NormalTok{symbols}
\DocumentationTok{\#\#      [,1] [,2] [,3] }
\DocumentationTok{\#\# [1,] "DD" "DD" "DD" }
\DocumentationTok{\#\# [2,] "C"  "DD" "0"  }
\DocumentationTok{\#\# [3,] "B"  "B"  "B"  }
\DocumentationTok{\#\# [4,] "B"  "BB" "BBB"}
\DocumentationTok{\#\# [5,] "C"  "C"  "0"  }
\DocumentationTok{\#\# [6,] "7"  "DD" "DD" }
\end{Highlighting}
\end{Shaded}

Then you can run each line of \texttt{score\_many} against the example
and examine the results as you go.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Test Your Understanding}\vspace{3mm}

Study the model \texttt{score\_many} function until you are satisfied
that you understand how it works and could write a similar function
yourself.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, breakable, colback=white, colframe=quarto-callout-color-frame, leftrule=.75mm, bottomrule=.15mm, arc=.35mm, opacityback=0, rightrule=.15mm, toprule=.15mm]

\vspace{-3mm}\textbf{Exercise: Advanced Challenge}\vspace{3mm}

Instead of examining the model answer, write your own vectorized version
of \texttt{score}. Assume that the data is stored in an \emph{n}  3
matrix where each row of the matrix contains one combination of slots to
be scored.

You can use the version of \texttt{score} that treats diamonds as wild
or the version of \texttt{score} that doesn't. However, the model answer
will use the version treating diamonds as wild.

\end{tcolorbox}

\texttt{score\_many} is a vectorized version of \texttt{score}. You can
use it to run the simulation at the start of this section in a little
over 20 seconds. This is 17 times faster than using a \texttt{for} loop:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# symbols should be a matrix with a column for each slot machine window}
\NormalTok{score\_many }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(symbols) \{}

  \CommentTok{\# Step 1: Assign base prize based on cherries and diamonds {-}{-}{-}{-}{-}{-}{-}{-}{-}}
  \DocumentationTok{\#\# Count the number of cherries and diamonds in each combination}
\NormalTok{  cherries }\OtherTok{\textless{}{-}} \FunctionTok{rowSums}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{)}
\NormalTok{  diamonds }\OtherTok{\textless{}{-}} \FunctionTok{rowSums}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{) }
  
  \DocumentationTok{\#\# Wild diamonds count as cherries}
\NormalTok{  prize }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+}\NormalTok{ diamonds }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
  
  \DocumentationTok{\#\# ...but not if there are zero real cherries }
  \DocumentationTok{\#\#\# (cherries is coerced to FALSE where cherries == 0)}
\NormalTok{  prize[}\SpecialCharTok{!}\NormalTok{cherries] }\OtherTok{\textless{}{-}} \DecValTok{0}
  
  \CommentTok{\# Step 2: Change prize for combinations that contain three of a kind }
\NormalTok{  same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[, }\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[, }\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&} 
\NormalTok{    symbols[, }\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[, }\DecValTok{3}\NormalTok{]}
\NormalTok{  payoffs }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }
    \StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }\StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{  prize[same] }\OtherTok{\textless{}{-}}\NormalTok{ payoffs[symbols[same, }\DecValTok{1}\NormalTok{]]}
  
  \CommentTok{\# Step 3: Change prize for combinations that contain all bars {-}{-}{-}{-}{-}{-}}
\NormalTok{  bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{==} \StringTok{"B"} \SpecialCharTok{|}\NormalTok{ symbols }\SpecialCharTok{==}  \StringTok{"BB"} \SpecialCharTok{|}\NormalTok{ symbols }\SpecialCharTok{==} \StringTok{"BBB"}
\NormalTok{  all\_bars }\OtherTok{\textless{}{-}}\NormalTok{ bars[, }\DecValTok{1}\NormalTok{] }\SpecialCharTok{\&}\NormalTok{ bars[, }\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&}\NormalTok{ bars[, }\DecValTok{3}\NormalTok{] }\SpecialCharTok{\&} \SpecialCharTok{!}\NormalTok{same}
\NormalTok{  prize[all\_bars] }\OtherTok{\textless{}{-}} \DecValTok{5}
  
  \CommentTok{\# Step 4: Handle wilds {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
  
  \DocumentationTok{\#\# combos with two diamonds}
\NormalTok{  two\_wilds }\OtherTok{\textless{}{-}}\NormalTok{ diamonds }\SpecialCharTok{==} \DecValTok{2}

  \DocumentationTok{\#\#\# Identify the nonwild symbol}
\NormalTok{  one }\OtherTok{\textless{}{-}}\NormalTok{ two\_wilds }\SpecialCharTok{\&}\NormalTok{ symbols[, }\DecValTok{1}\NormalTok{] }\SpecialCharTok{!=}\NormalTok{ symbols[, }\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&} 
\NormalTok{    symbols[, }\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[, }\DecValTok{3}\NormalTok{]}
\NormalTok{  two }\OtherTok{\textless{}{-}}\NormalTok{ two\_wilds }\SpecialCharTok{\&}\NormalTok{ symbols[, }\DecValTok{1}\NormalTok{] }\SpecialCharTok{!=}\NormalTok{ symbols[, }\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&} 
\NormalTok{    symbols[, }\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[, }\DecValTok{3}\NormalTok{]}
\NormalTok{  three }\OtherTok{\textless{}{-}}\NormalTok{ two\_wilds }\SpecialCharTok{\&}\NormalTok{ symbols[, }\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[, }\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&} 
\NormalTok{    symbols[, }\DecValTok{2}\NormalTok{] }\SpecialCharTok{!=}\NormalTok{ symbols[, }\DecValTok{3}\NormalTok{]}
  
  \DocumentationTok{\#\#\# Treat as three of a kind}
\NormalTok{  prize[one] }\OtherTok{\textless{}{-}}\NormalTok{ payoffs[symbols[one, }\DecValTok{1}\NormalTok{]]}
\NormalTok{  prize[two] }\OtherTok{\textless{}{-}}\NormalTok{ payoffs[symbols[two, }\DecValTok{2}\NormalTok{]]}
\NormalTok{  prize[three] }\OtherTok{\textless{}{-}}\NormalTok{ payoffs[symbols[three, }\DecValTok{3}\NormalTok{]]}
  
  \DocumentationTok{\#\# combos with one wild}
\NormalTok{  one\_wild }\OtherTok{\textless{}{-}}\NormalTok{ diamonds }\SpecialCharTok{==} \DecValTok{1}
  
  \DocumentationTok{\#\#\# Treat as all bars (if appropriate)}
\NormalTok{  wild\_bars }\OtherTok{\textless{}{-}}\NormalTok{ one\_wild }\SpecialCharTok{\&}\NormalTok{ (}\FunctionTok{rowSums}\NormalTok{(bars) }\SpecialCharTok{==} \DecValTok{2}\NormalTok{)}
\NormalTok{  prize[wild\_bars] }\OtherTok{\textless{}{-}} \DecValTok{5}
  
  \DocumentationTok{\#\#\# Treat as three of a kind (if appropriate)}
\NormalTok{  one }\OtherTok{\textless{}{-}}\NormalTok{ one\_wild }\SpecialCharTok{\&}\NormalTok{ symbols[, }\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[, }\DecValTok{2}\NormalTok{]}
\NormalTok{  two }\OtherTok{\textless{}{-}}\NormalTok{ one\_wild }\SpecialCharTok{\&}\NormalTok{ symbols[, }\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[, }\DecValTok{3}\NormalTok{]}
\NormalTok{  three }\OtherTok{\textless{}{-}}\NormalTok{ one\_wild }\SpecialCharTok{\&}\NormalTok{ symbols[, }\DecValTok{3}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[, }\DecValTok{1}\NormalTok{]}
\NormalTok{  prize[one] }\OtherTok{\textless{}{-}}\NormalTok{ payoffs[symbols[one, }\DecValTok{1}\NormalTok{]]}
\NormalTok{  prize[two] }\OtherTok{\textless{}{-}}\NormalTok{ payoffs[symbols[two, }\DecValTok{2}\NormalTok{]]}
\NormalTok{  prize[three] }\OtherTok{\textless{}{-}}\NormalTok{ payoffs[symbols[three, }\DecValTok{3}\NormalTok{]]}
 
  \CommentTok{\# Step 5: Double prize for every diamond in combo {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
  \FunctionTok{unname}\NormalTok{(prize }\SpecialCharTok{*} \DecValTok{2}\SpecialCharTok{\^{}}\NormalTok{diamonds)}
  
\NormalTok{\}}

\FunctionTok{system.time}\NormalTok{(}\FunctionTok{play\_many}\NormalTok{(}\DecValTok{10000000}\NormalTok{))}
\DocumentationTok{\#\#   user  system elapsed }
\DocumentationTok{\#\# 20.942   1.433  22.367}
\end{Highlighting}
\end{Shaded}

\subsection{Loops Versus Vectorized
Code}\label{loops-versus-vectorized-code}

In many languages, \texttt{for} loops run very fast. As a result,
programmers learn to use \texttt{for} loops whenever possible when they
code. Often these programmers continue to rely on \texttt{for} loops
when they begin to program in R, usually without taking the simple steps
needed to optimize R's \texttt{for} loops. These programmers may become
disillusioned with R when their code does not work as fast as they would
like. If you think that this may be happening to you, examine how often
you are using \texttt{for} loops and what you are using them to do. If
you find yourself using \texttt{for} loops for every task, there is a
good chance that you are ``speaking R with a C accent.'' The cure is to
learn to write and use vectorized code.

This doesn't mean that \texttt{for} loops have no place in R.
\texttt{for} loops are a very useful feature; they can do many things
that vectorized code cannot do. You also should not become a slave to
vectorized code. Sometimes it would take more time to rewrite code in
vectorized format than to let a \texttt{for} loop run. For example,
would it be faster to let the slot simulation run for 5.7 minutes or to
rewrite \texttt{score}?

\section{Summary}\label{summary-9}

Fast code is an important component of data science because you can do
more with fast code than you can do with slow code. You can work with
larger data sets before computational constraints intervene, and you can
do more computation before time constraints intervene. The fastest code
in R will rely on the things that R does best: logical tests,
subsetting, and element-wise execution. I've called this type of code
vectorized code because code written with these operations will take a
vector of values as input and operate on each element of the vector at
the same time. The majority of the code written in R is already
vectorized.

If you use these operations, but your code does not appear vectorized,
analyze the sequential steps and parallel cases in your program. Ensure
that you've used vectorized functions to handle the steps and logical
subsetting to handle the cases. Be aware, however, that some tasks
cannot be vectorized.

\section{Project 3 Wrap-up}\label{project-3-wrap-up}

You have now written your first program in R, and it is a program that
you should be proud of. \texttt{play} is not a simple
\texttt{hello\ world} exercise, but a real program that does a real task
in a complicated way.

Writing new programs in R will always be challenging because programming
depends so much on your own creativity, problem-solving ability, and
experience writing similar types of programs. However, you can use the
suggestions in this chapter to make even the most complicated program
manageable: divide tasks into simple steps and cases, work with concrete
examples, and describe possible solutions in English.

This project completes the education you began in
\hyperref[sec-basics]{The Very Basics}. You can now use R to handle
data, which has augmented your ability to analyze data. You can:

\begin{itemize}
\tightlist
\item
  Load and store data in your computer---not on paper or in your mind
\item
  Accurately recall and change individual values without relying on your
  memory
\item
  Instruct your computer to do tedious, or complex, tasks on your behalf
\end{itemize}

These skills solve an important logistical problem faced by every data
scientist: \emph{how can you store and manipulate data without making
errors?} However, this is not the only problem that you will face as a
data scientist. The next problem will appear when you try to understand
the information contained in your data. It is nearly impossible to spot
insights or to discover patterns in raw data. A third problem will
appear when you try to use your data set to reason about reality, which
includes things not contained in your data set. What exactly does your
data imply about things outside of the data set? How certain can you be?

I refer to these problems as the logistical, tactical, and strategic
problems of data science, as shown in Figure~\ref{fig-venn}. You'll face
them whenever you try to learn from data:

\begin{itemize}
\tightlist
\item
  \textbf{A logistical problem:} - How can you store and manipulate data
  without making errors?
\item
  \textbf{A tactical problem} - How can you discover the information
  contained in your data?
\item
  \textbf{A strategic problem} - How can you use the data to draw
  conclusions about the world at large?
\end{itemize}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_1004.png}}

}

\caption{\label{fig-venn}The three core skill sets of data science:
computer programming, data comprehension, and scientific reasoning.}

\end{figure}%

A well-rounded data scientist will need to be able to solve each of
these problems in many different situations. By learning to program in
R, you have mastered the logistical problem, which is a prerequisite for
solving the tactical and strategic problems.

If you would like to learn how to reason with data, or how to transform,
visualize, and explore your data sets with R tools, I recommend the book
\href{http://r4ds.had.co.nz/}{\emph{R for Data Science}}, the companion
volume to this book. \emph{R for Data Science} teaches a simple workflow
for transforming, visualizing, and modeling data in R, as well as how to
report results with the R Markdown package.

\cleardoublepage
\phantomsection
\addcontentsline{toc}{part}{Appendices}
\appendix

\chapter{Installing R and RStudio}\label{sec-appendix-starting}

To get started with R, you need to acquire your own copy. This appendix
will show you how to download R as well as RStudio, a software
application that makes R easier to use. You'll go from downloading R to
opening your first R session.

Both R and RStudio are free and easy to download.

\section{How to Download and Install
R}\label{how-to-download-and-install-r}

R is maintained by an international team of developers who make the
language available through the web page of
\href{http://cran.r-project.org}{The Comprehensive R Archive Network}.
The top of the web page provides three links for downloading R. Follow
the link that describes your operating system: Windows, Mac, or Linux.

\subsection{Windows}\label{windows}

To install R on Windows, click the ``Download R for Windows'' link. Then
click the ``base'' link. Next, click the first link at the top of the
new page. This link should say something like ``Download R 3.0.3 for
Windows,'' except the 3.0.3 will be replaced by the most current version
of R. The link downloads an installer program, which installs the most
up-to-date version of R for Windows. Run this program and step through
the installation wizard that appears. The wizard will install R into
your program files folders and place a shortcut in your Start menu. Note
that you'll need to have all of the appropriate administration
privileges to install new software on your machine.

\subsection{Mac}\label{mac}

To install R on a Mac, click the ``Download R for Mac'' link. Next,
click on the \texttt{R-3.0.3} package link (or the package link for the
most current release of R). An installer will download to guide you
through the installation process, which is very easy. The installer lets
you customize your installation, but the defaults will be suitable for
most users. I've never found a reason to change them. If your computer
requires a password before installing new progams, you'll need it here.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Binaries Versus Source}, toprule=.15mm]

R can be installed from precompiled binaries or built from source on any
operating system. For Windows and Mac machines, installing R from
binaries is extremely easy. The binary comes preloaded in its own
installer. Although you can build R from source on these platforms, the
process is much more complicated and won't provide much benefit for most
users. For Linux systems, the opposite is true. Precompiled binaries can
be found for some systems, but it is much more common to build R from
source files when installing on Linux. The download pages on
\href{http://cran.r-project.org}{CRAN's website} provide information
about building R from source for the Windows, Mac, and Linux platforms.

\end{tcolorbox}

\subsection{Linux}\label{linux}

R comes preinstalled on many Linux systems, but you'll want the newest
version of R if yours is out of date.
\href{http://cran.r-project.org}{The CRAN website} provides files to
build R from source on Debian, Redhat, SUSE, and Ubuntu systems under
the link ``Download R for Linux.'' Click the link and then follow the
directory trail to the version of Linux you wish to install on. The
exact installation procedure will vary depending on the Linux system you
use. CRAN guides the process by grouping each set of source files with
documentation or README files that explain how to install on your
system.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{32-bit Versus 64-bit}, toprule=.15mm]

R comes in both 32-bit and 64-bit versions. Which should you use? In
most cases, it won't matter. Both versions use 32-bit integers, which
means they compute numbers to the same numerical precision. The
difference occurs in the way each version manages memory. 64-bit R uses
64-bit memory pointers, and 32-bit R uses 32-bit memory pointers. This
means 64-bit R has a larger memory space to use (and search through).

As a rule of thumb, 32-bit builds of R are faster than 64-bit builds,
though not always. On the other hand, 64-bit builds can handle larger
files and data sets with fewer memory management problems. In either
version, the maximum allowable vector size tops out at around 2 billion
elements. If your operating system doesn't support 64-bit programs, or
your RAM is less than 4 GB, 32-bit R is for you. The Windows and Mac
installers will automatically install both versions if your system
supports 64-bit R.

\end{tcolorbox}

\section{Using R}\label{using-r}

R isn't a program that you can open and start using, like Microsoft Word
or Internet Explorer. Instead, R is a computer language, like C, C++, or
UNIX. You use R by writing commands in the R language and asking your
computer to interpret them. In the old days, people ran R code in a UNIX
terminal window---as if they were hackers in a movie from the 1980s. Now
almost everyone uses R with an application called RStudio, and I
recommend that you do, too.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{R and UNIX}, toprule=.15mm]

You can still run R in a UNIX or BASH window by typing the command:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ R}
\end{Highlighting}
\end{Shaded}

which opens an R interpreter. You can then do your work and close the
interpreter by running \texttt{q()} when you are finished.

\end{tcolorbox}

\section{RStudio}\label{rstudio}

RStudio \emph{is} an application like Microsoft Word---except that
instead of helping you write in English, RStudio helps you write in R. I
use RStudio throughout the book because it makes using R much easier.
Also, the RStudio interface looks the same for Windows, Mac OS, and
Linux. That will help me match the book to your personal experience.

You can \href{http://www.rstudio.com/ide}{download RStudio} for free.
Just click the ``Download RStudio'' button and follow the simple
instructions that follow. Once you've installed RStudio, you can open it
like any other program on your computer---usually by clicking an icon on
your desktop.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{The R GUIs}, toprule=.15mm]

Windows and Mac users usually do not program from a terminal window, so
the Windows and Mac downloads for R come with a simple program that
opens a terminal-like window for you to run R code in. This is what
opens when you click the R icon on your Windows or Mac computer. These
programs do a little more than the basic terminal window, but not much.
You may hear people refer to them as the Windows or Mac R GUIs.

\end{tcolorbox}

When you open RStudio, a window appears with three panes in it, as in
Figure~\ref{fig-layout}. The largest pane is a console window. This is
where you'll run your R code and see results. The console window is
exactly what you'd see if you ran R from a UNIX console or the Windows
or Mac GUIs. Everything else you see is unique to RStudio. Hidden in the
other panes are a text editor, a graphics window, a debugger, a file
manager, and much more. You'll learn about these panes as they become
useful throughout the course of this book.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_aa01.png}}

}

\caption{\label{fig-layout}The RStudio IDE for R.}

\end{figure}%

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Do I still need to download R?}, toprule=.15mm]

Even if you use RStudio, you'll still need to download R to your
computer. RStudio helps you use the version of R that lives on your
computer, but it doesn't come with a version of R on its own.

\end{tcolorbox}

\section{Opening R}\label{opening-r}

Now that you have both R and RStudio on your computer, you can begin
using R by opening the RStudio program. Open RStudio just as you would
any program, by clicking on its icon or by typing ``RStudio'' at the
Windows Run prompt.

\chapter{R Packages}\label{sec-appendix-packages}

Many of R's most useful functions do not come preloaded when you start
R, but reside in \emph{packages} that can be installed on top of R. R
packages are similar to libraries in C, C++, and Javascript, packages in
Python, and gems in Ruby. An R package bundles together useful
functions, help files, and data sets. You can use these functions within
your own R code once you load the package they live in. Usually the
contents of an R package are all related to a single type of task, which
the package helps solve. R packages will let you take advantage of R's
most useful features: its large community of package writers (many of
whom are active data scientists) and its prewritten routines for
handling many common (and exotic) data-science tasks.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Base R}, toprule=.15mm]

You may hear R users (or me) refer to ``base R.'' What is base R? It is
just the collection of R functions that gets loaded every time you start
R. These functions provide the basics of the language, and you don't
have to load a package before you can use them.

\end{tcolorbox}

\section{Installing Packages}\label{installing-packages}

To use an R package, you must first install it on your computer and then
load it in your current R session. The easiest way to install an R
package is with the \texttt{install.packages} R function. Open R and
type the following into the command line:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"\textless{}package name\textgreater{}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This will search for the specified package in the collection of packages
hosted on the CRAN site. When R finds the package, it will download it
into a libraries folder on your computer. R can access the package here
in future R sessions without reinstalling it. Anyone can write an R
package and disseminate it as they like; however, almost all R packages
are published through the CRAN website. CRAN tests each R package before
publishing it. This doesn't eliminate every bug inside a package, but it
does mean that you can trust a package on CRAN to run in the current
version of R on your OS.

You can install multiple packages at once by linking their names with
R's concatenate function, \texttt{c}. For example, to install the
ggplot2, reshape2, and dplyr packages, run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{, }\StringTok{"reshape2"}\NormalTok{, }\StringTok{"dplyr"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

If this is your first time installing a package, R will prompt you to
choose an online mirror of to install from. Mirrors are listed by
location. Your downloads should be quickest if you select a mirror that
is close to you. If you want to download a new package, try the Austria
mirror first. This is the main CRAN repository, and new packages can
sometimes take a couple of days to make it around to all of the other
mirrors.

\section{Loading Packages}\label{loading-packages}

Installing a package doesn't immediately place its functions at your
fingertips. It just places them on your computer. To use an R package,
you next have to load it in your R session with the command:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\SpecialCharTok{\textless{}}\NormalTok{package name}\SpecialCharTok{\textgreater{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Notice that the quotation marks have disappeared. You can use them if
you like, but quotation marks are optional for the \texttt{library}
command. (This is not true for the \texttt{install.packages} command).

\texttt{library} will make all of the package's functions, data sets,
and help files available to you until you close your current R session.
The next time you begin an R session, you'll have to reload the package
with \texttt{library} if you want to use it, but you won't have to
reinstall it. You only have to install each package once. After that, a
copy of the package will live in your R library. To see which packages
you currently have in your R library, run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\texttt{library()} also shows the path to your actual R library, which
is the folder that contains your R packages. You may notice many
packages that you don't remember installing. This is because R
automatically downloads a set of useful packages when you first install
R.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Install packages from (almost) anywhere}, toprule=.15mm]

The \texttt{devtools} R package makes it easy to install packages from
locations other than the CRAN website. devtools provides functions like
\texttt{install\_github}, \texttt{install\_gitorious},
\texttt{install\_bitbucket}, and \texttt{install\_url}. These work
similar to \texttt{install.packages}, but they search new locations for
R packages. \texttt{install\_github} is especially useful because many R
developers provide development versions of their packages on GitHub. The
development version of a package will contain a sneak peek of new
functions and patches but may not be as stable or as bug free as the
CRAN version.

\end{tcolorbox}

Why does R make you bother with installing and loading packages? You can
imagine an R where every package came preloaded, but this would be a
very large and slow program. As of May 6, 2014, the CRAN website hosts
5,511 packages. It is simpler to only install and load the packages that
you want to use when you want to use them. This keeps your copy of R
fast because it has fewer functions and help pages to search through at
any one time. The arrangement has other benefits as well. For example,
it is possible to update your copy of an R package without updating your
entire copy of R.

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{What's the best way to learn about R packages?}, toprule=.15mm]

It is difficult to use an R package if you don't know that it exists.
You could go to the CRAN website and click the Packages link to see a
list of available packages, but you'll have to wade through thousands of
them. Moreover, many R packages do the same things.

How do you know which package does them best? The R-packages
\href{http://stat.ethz.ch/mailman/listinfo/r-packages}{mailing list} is
a place to start. It sends out announcements of new packages and
maintains an archive of old announcements. Blogs that aggregate posts
about R can also provide valuable leads. I recommend
\href{www.r-bloggers.com}{R-bloggers}. RStudio maintains a list of some
of the most useful R packages in the Getting Started section of
\url{http://support.rstudio.com}. Finally, CRAN groups together some of
the most useful---and most respected---packages by
\href{http://cran.r-project.org/web/views}{subject area}. This is an
excellent place to learn about the packages designed for your area of
work.

\end{tcolorbox}

\chapter{Updating R and Its Packages}\label{sec-appendix-updating}

The R Core Development Team continuously hones the R language by
catching bugs, improving performance, and updating R to work with new
technologies. As a result, new versions of R are released several times
a year. The easiest way to stay current with R is to periodically check
\href{http://cran.r-project.org}{the CRAN website}. The website is
updated for each new release and makes the release available for
download. You'll have to install the new release. The process is the
same as when you first installed R.

Don't worry if you're not interested in staying up-to-date on R Core's
doings. R changes only slightly between releases, and you're not likely
to notice the differences. However, updating to the current version of R
is a good place to start if you ever encounter a bug that you can't
explain.

RStudio also constantly improves its product. You can acquire the newest
updates just by downloading them from
\href{http://www.rstudio.com/ide}{RStudio}.

\section{R Packages}\label{r-packages}

Package authors occasionally release new versions of their packages to
add functions, fix bugs, or improve performance. The
\texttt{update.packages} command checks whether you have the most
current version of a package and installs the most current version if
you do not. The syntax for \texttt{update.packages} follows that of
\texttt{install.packages}. If you already have ggplot2, reshape2, and
dplyr on your computer, it'd be a good idea to check for updates before
you use them:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{update.packages}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{, }\StringTok{"reshape2"}\NormalTok{, }\StringTok{"dplyr"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

You should start a new R session after updating packages. If you have a
package loaded when you update it, you'll have to close your R session
and open a new one to begin using the updated version of the package.

\chapter{Loading and Saving Data in R}\label{sec-appendix-dataio}

This appendix will show you how to load and save data into R from
plain-text files, R files, and Excel spreadsheets. It will also show you
the R packages that you can use to load data from databases and other
common programs, like SAS and MATLAB.

\section{Data Sets in Base R}\label{data-sets-in-base-r}

R comes with many data sets preloaded in the \texttt{datasets} package,
which comes with base R. These data sets are not very interesting, but
they give you a chance to test code or make a point without having to
load a data set from outside R. You can see a list of R's data sets as
well as a short description of each by running:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{help}\NormalTok{(}\AttributeTok{package =} \StringTok{"datasets"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To use a data set, just type its name. Each data set is already presaved
as an R object. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris}
\DocumentationTok{\#\#   Sepal.Length Sepal.Width Petal.Length Petal.Width Species}
\DocumentationTok{\#\# 1          5.1         3.5          1.4         0.2  setosa}
\DocumentationTok{\#\# 2          4.9         3.0          1.4         0.2  setosa}
\DocumentationTok{\#\# 3          4.7         3.2          1.3         0.2  setosa}
\DocumentationTok{\#\# 4          4.6         3.1          1.5         0.2  setosa}
\DocumentationTok{\#\# 5          5.0         3.6          1.4         0.2  setosa}
\DocumentationTok{\#\# 6          5.4         3.9          1.7         0.4  setosa}
\end{Highlighting}
\end{Shaded}

However, R's data sets are no substitute for your own data, which you
can load into R from a wide variety of file formats. But before you load
any data files into R, you'll need to determine where your \emph{working
directory} is.

\section{Working Directory}\label{working-directory}

Each time you open R, it links itself to a directory on your computer,
which R calls the working directory. This is where R will look for files
when you attempt to load them, and it is where R will save files when
you save them. The location of your working directory will vary on
different computers. To determine which directory R is using as your
working directory, run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getwd}\NormalTok{()}
\DocumentationTok{\#\# "/Users/garrettgrolemund"}
\end{Highlighting}
\end{Shaded}

You can place data files straight into the folder that is your working
directory, or you can move your working directory to where your data
files are. You can move your working directory to any folder on your
computer with the function \texttt{setwd}. Just give \texttt{setwd} the
file path to your new working directory. I prefer to set my working
directory to a folder dedicated to whichever project I am currently
working on. That way I can keep all of my data, scripts, graphs, and
reports in the same place. For example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setwd}\NormalTok{(}\StringTok{"\textasciitilde{}/Users/garrettgrolemund/Documents/Book\_Project"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If the file path does not begin with your root directory, R will assume
that it begins at your current working directory.

You can also change your working directory by clicking on Session
\textgreater{} Set Working Directory \textgreater{} Choose Directory in
the RStudio menu bar. The Windows and Mac GUIs have similar options. If
you start R from a UNIX command line (as on Linux machines), the working
directory will be whichever directory you were in when you called R.

You can see what files are in your working directory with
\texttt{list.files()}. If you see the file that you would like to open
in your working directory, then you are ready to proceed. How you open
files in your working directory will depend on which type of file you
would like to open.

\section{Plain-text Files}\label{plain-text-files}

Plain-text files are one of the most common ways to save data. They are
very simple and can be read by many different computer programs---even
the most basic text editors. For this reason, public data often comes as
plain-text files. For example, the Census Bureau, the Social Security
Administration, and the Bureau of Labor Statistics all make their data
available as plain-text files.

Here's how the royal flush data set from Section~\ref{sec-r-objects}
would appear as a plain-text file (I've added a value column):

\begin{verbatim}
"card", "suit", "value"
"ace", "spades", 14
"king", "spades", 13
"queen", "spades", 12
"jack", "spades", 11
"ten", "spades", 10
\end{verbatim}

A plain-text file stores a table of data in a text document. Each row of
the table is saved on its own line, and a simple convention is used to
separate the cells within a row. Often cells are separated by a comma,
but they can also be separated by a tab, a pipe delimiter (i.e.,
\texttt{\textbar{}} ), or any other character. Each file only uses one
method of separating cells, which minimizes confusion. Within each cell,
data appears as you'd expect to see it, as words and numbers.

All plain-text files can be saved with the extension \emph{.txt} (for
text), but sometimes a file will receive a special extension that
advertises how it separates data-cell entries. Since entries in the data
set mentioned earlier are separated with a comma, this file would be a
\emph{comma-separated-values} file and would usually be saved with the
extension \emph{.csv}.

\subsection{read.table}\label{read.table}

To load a plain-text file, use \texttt{read.table}. The first argument
of \texttt{read.table} should be the name of your file (if it is in your
working directory), or the file path to your file (if it is not in your
working directory). If the file path does not begin with your root
directory, R will append it to the end of the file path that leads to
your working directory.You can give \texttt{read.table} other arguments
as well. The two most important are \texttt{sep} and \texttt{header}.

If the royal flush data set was saved as a file named \emph{poker.csv}
in your working directory, you could load it with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{poker }\OtherTok{\textless{}{-}} \FunctionTok{read.table}\NormalTok{(}\StringTok{"poker.csv"}\NormalTok{, }\AttributeTok{sep =} \StringTok{","}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsubsection{sep}\label{sep}

Use \texttt{sep} to tell \texttt{read.table} what character your file
uses to separate data entries. To find this out, you might have to open
your file in a text editor and look at it. If you don't specify a
\texttt{sep} argument, \texttt{read.table} will try to separate cells
whenever it comes to white space, such as a tab or space. R won't be
able to tell you if \texttt{read.table} does this correctly or not, so
rely on it at your own risk.

\subsubsection{header}\label{header}

Use \texttt{header} to tell \texttt{read.table} whether the first line
of the file contains variable names instead of values. If the first line
of the file is a set of variable names, you should set
\texttt{header\ =\ TRUE}.

\subsubsection{na.strings}\label{na.strings}

Oftentimes data sets will use special symbols to represent missing
information. If you know that your data uses a certain symbol to
represent missing entries, you can tell \texttt{read.table} (and the
preceding functions) what the symbol is with the \texttt{na.strings}
argument. \texttt{read.table} will convert all instances of the missing
information symbol to \texttt{NA}, which is R's missing information
symbol (see \hyperref[sec-missing]{Missing Information}).

For example, your poker data set contained missing values stored as a
\texttt{.}, like this:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# "card","suit","value"}
\DocumentationTok{\#\# "ace"," spades"," 14"}
\DocumentationTok{\#\# "king"," spades"," 13"}
\DocumentationTok{\#\# "queen",".","."}
\DocumentationTok{\#\# "jack",".","."}
\DocumentationTok{\#\# "ten",".","."}
\end{Highlighting}
\end{Shaded}

You could read the data set into R and convert the missing values into
NAs as you go with the command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{poker }\OtherTok{\textless{}{-}} \FunctionTok{read.table}\NormalTok{(}\StringTok{"poker.csv"}\NormalTok{, }\AttributeTok{sep =} \StringTok{","}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{na.string =} \StringTok{"."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

R would save a version of \texttt{poker} that looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\#  card    suit value}
\DocumentationTok{\#\#   ace  spades    14}
\DocumentationTok{\#\#  king  spades    13}
\DocumentationTok{\#\# queen    \textless{}NA\textgreater{}    NA}
\DocumentationTok{\#\#  jack    \textless{}NA\textgreater{}    NA}
\DocumentationTok{\#\#   ten    \textless{}NA\textgreater{}    NA}
\end{Highlighting}
\end{Shaded}

\subsubsection{skip and nrow}\label{skip-and-nrow}

Sometimes a plain-text file will come with introductory text that is not
part of the data set. Or, you may decide that you only wish to read in
part of a data set. You can do these things with the \texttt{skip} and
\texttt{nrow} arguments. Use \texttt{skip} to tell R to skip a specific
number of lines before it starts reading in values from the file. Use
\texttt{nrow} to tell R to stop reading in values after it has read in a
certain number of lines.

For example, imagine that the complete royal flush file looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{This data was collected by the National Poker Institute. }
\NormalTok{We accidentally repeated the last row of data.}

\StringTok{"card"}\NormalTok{, }\StringTok{"suit"}\NormalTok{, }\StringTok{"value"}
\StringTok{"ace"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\DecValTok{14}
\StringTok{"king"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\DecValTok{13}
\StringTok{"queen"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\DecValTok{12}
\StringTok{"jack"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\DecValTok{11}
\StringTok{"ten"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\DecValTok{10}
\StringTok{"ten"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

You can read just the six lines that you want (five rows plus a header)
with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{read.table}\NormalTok{(}\StringTok{"poker.csv"}\NormalTok{, }\AttributeTok{sep =} \StringTok{","}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{skip =} \DecValTok{3}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{5}\NormalTok{)}
\DocumentationTok{\#\#    card    suit value}
\DocumentationTok{\#\# 1   ace  spades    14}
\DocumentationTok{\#\# 2  king  spades    13}
\DocumentationTok{\#\# 3 queen  spades    12}
\DocumentationTok{\#\# 4  jack  spades    11}
\DocumentationTok{\#\# 5   ten  spades    10}
\end{Highlighting}
\end{Shaded}

Notice that the header row doesn't count towards the total rows allowed
by \texttt{nrow}.

\subsubsection{stringsAsFactors}\label{stringsasfactors}

R reads in numbers just as you'd expect, but when R comes across
character strings (e.g., letters and words) it begins to act strangely.
R wants to convert every character string into a factor. This is R's
default behavior, but I think it is a mistake. Sometimes factors are
useful. At other times, they're clearly the wrong data type for the job.
Also factors cause weird behavior, especially when you want to display
data. This behavior can be surprising if you didn't realize that R
converted your data to factors. In general, you'll have a smoother R
experience if you don't let R make factors until you ask for them.
Thankfully, it is easy to do this.

Setting the argument \texttt{stringsAsFactors} to \texttt{FALSE} will
ensure that R saves any character strings in your data set as character
strings, not factors. To use \texttt{stringsAsFactors}, you'd write:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{read.table}\NormalTok{(}\StringTok{"poker.csv"}\NormalTok{, }\AttributeTok{sep =} \StringTok{","}\NormalTok{, }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{stringsAsFactors =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you will be loading more than one data file, you can change the
default factoring behavior at the global level with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{options}\NormalTok{(}\AttributeTok{stringsAsFactors =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This will ensure that all strings will be read as strings, not as
factors, until you end your R session, or rechange the global default by
running:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{options}\NormalTok{(}\AttributeTok{stringsAsFactors =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{The read Family}\label{the-read-family}

R also comes with some prepackaged short cuts for \texttt{read.table},
shown in Table~\ref{tbl-shortcuts}.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1456}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3689}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4854}}@{}}
\caption{R's read functions. You can overwrite any of the default
arguments as necessary.}\label{tbl-shortcuts}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Defaults
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Use
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Defaults
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Use
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{read.table} & sep = '' ``, header = FALSE & General-purpose read
function \\
\texttt{read.csv} & sep = ``,'', header = TRUE &
Comma-separated-variable (CSV) files \\
\texttt{read.delim} & sep = ``\t", header = TRUE & Tab-delimited
files \\
\texttt{read.csv2} & sep = ``;'', header = TRUE, dec = ``,'' & CSV files
with European decimal format \\
\texttt{read.delim2} & sep = ``\t", header = TRUE, dec ='','' &
Tab-delimited files with European decimal format \\
\end{longtable}

The first shortcut, \texttt{read.csv}, behaves just like
\texttt{read.table} but automatically sets \texttt{sep\ =\ ","} and
\texttt{header\ =\ TRUE}, which can save you some typing:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{poker }\OtherTok{\textless{}{-}} \FunctionTok{read.csv}\NormalTok{(}\StringTok{"poker.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{read.delim} automatically sets \texttt{sep} to the tab
character, which is very handy for reading tab delimited files. These
are files where each cell is separated by a tab. \texttt{read.delim}
also sets \texttt{header\ =\ TRUE} by default.

\texttt{read.delim2} and \texttt{read.csv2} exist for European R users.
These functions tell R that the data uses a comma instead of a period to
denote decimal places. (If you're wondering how this works with CSV
files, CSV2 files usually separate cells with a semicolon, not a comma.)

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-tip-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Import Dataset}, toprule=.15mm]

You can also load plain text files with RStudio's Import Dataset button,
as described in \hyperref[loading]{Loading Data}. Import Dataset
provides a GUI version of \texttt{read.table}.

\end{tcolorbox}

\subsection{read.fwf}\label{read.fwf}

One type of plain-text file defies the pattern by using its layout to
separate data cells. Each row is placed in its own line (as with other
plain-text files), and then each column begins at a specific number of
characters from the lefthand side of the document. To achieve this, an
arbitrary number of character spaces is added to the end of each entry
to correctly position the next entry. These documents are known as
\emph{fixed-width files} and usually end with the extension \emph{.fwf}.

Here's one way the royal flush data set could look as a fixed-width
file. In each row, the suit entry begins exactly 10 characters from the
start of the line. It doesn't matter how many characters appeared in the
first cell of each row:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{card      suit       value}
\NormalTok{ace       spades     14}
\NormalTok{king      spades     13  }
\NormalTok{queen     spades     12  }
\NormalTok{jack      spades     11  }
\NormalTok{10        spades     10}
\end{Highlighting}
\end{Shaded}

Fixed-width files look nice to human eyes (but no better than a
tab-delimited file); however, they can be difficult to work with.
Perhaps because of this, R comes with a function for reading fixed-width
files, but no function for saving them. Unfortunately, US government
agencies seem to like fixed-width files, and you'll likely encounter one
or more during your career.

You can read fixed-width files into R with the function
\texttt{read.fwf}. The function takes the same arguments as
\texttt{read.table} but requires an additional argument,
\texttt{widths}, which should be a vector of numbers. Each \_i\_th entry
of the \texttt{widths} vector should state the width (in characters) of
the \_i\_th column of the data set.

If the aforementioned fixed-width royal flush data was saved as
\emph{poker.fwf} in your working directory, you could read it with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{poker }\OtherTok{\textless{}{-}} \FunctionTok{read.fwf}\NormalTok{(}\StringTok{"poker.fwf"}\NormalTok{, }\AttributeTok{widths =} \FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{), }\AttributeTok{header =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{HTML Links}\label{html-links}

Many data files are made available on the Internet at their own web
address. If you are connected to the Internet, you can open these files
straight into R with \texttt{read.table}, \texttt{read.csv}, etc. You
can pass a web address into the file name argument for any of R's
data-reading functions. As a result, you could read in the poker data
set from a web address like
\href{http://}{\emph{http://}}\emph{\ldots/poker.csv} with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{poker }\OtherTok{\textless{}{-}} \FunctionTok{read.csv}\NormalTok{(}\StringTok{"http://.../poker.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

That's obviously not a real address, but here's something that would
work---if you can manage to type it!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck }\OtherTok{\textless{}{-}} \FunctionTok{read.csv}\NormalTok{(}\StringTok{"https://gist.githubusercontent.com/garrettgman/9629323/raw/ee5dfc039fd581cb467cc69c226ea2524913c3d8/deck.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Just make sure that the web address links directly to the file and not
to a web page that links to the file. Usually, when you visit a data
file's web address, the file will begin to download or the raw data will
appear in your browser window.

Note that websites that begin with \_\url{https://_} are secure
websites, which means R may not be able to access the data provided at
these links.

\subsection{Saving Plain-Text Files}\label{saving-plain-text-files}

Once your data is in R, you can save it to any file format that R
supports. If you'd like to save it as a plain-text file, you can use the
+write+ family of functions. The three basic write functions appear in
Table~\ref{tbl-write}. Use \texttt{write.csv} to save your data as a
\emph{.csv} file and \texttt{write.table} to save your data as a tab
delimited document or a document with more exotic separators.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3772}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6228}}@{}}
\caption{R saves data sets to plain-text files with the write family of
functions}\label{tbl-write}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
File format
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Function and syntax
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
File format
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Function and syntax
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{.csv} &
\texttt{write.csv(r\_object,\ file\ =\ filepath,\ row.names\ =\ FALSE)} \\
\textbf{.csv} (with European decimal notation) &
\texttt{write.csv2(r\_object,\ file\ =\ filepath,\ row.names\ =\ FALSE)} \\
tab delimited &
\texttt{write.table(r\_object,\ file\ =\ filepath,\ sep\ =\ "\textbackslash{}t",\ row.names=FALSE)} \\
\end{longtable}

The first argument of each function is the R object that contains your
data set. The \texttt{file} argument is the file name (including
extension) that you wish to give the saved data. By default, each
function will save your data into your working directory. However, you
can supply a file path to the file argument. R will oblige by saving the
file at the end of the file path. If the file path does not begin with
your root directory, R will append it to the end of the file path that
leads to your working directory.

For example, you can save the (hypothetical) poker data frame to a
subdirectory named \emph{data} within your working directory with the
command:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write.csv}\NormalTok{(poker, }\StringTok{"data/poker.csv"}\NormalTok{, }\AttributeTok{row.names =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Keep in mind that \texttt{write.csv} and \texttt{write.table} cannot
create new directories on your computer. Each folder in the file path
must exist before you try to save a file with it.

The \texttt{row.names} argument prevents R from saving the data frame's
row names as a column in the plain-text file. You might have noticed
that R automatically names each row in a data frame with a number. For
example, each row in our poker data frame appears with a number next to
it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{poker}
\DocumentationTok{\#\#    card   suit value}
\DocumentationTok{\#\# 1   ace spades    14}
\DocumentationTok{\#\# 2  king spades    13}
\DocumentationTok{\#\# 3 queen spades    12}
\DocumentationTok{\#\# 4  jack spades    11}
\DocumentationTok{\#\# 5    10 spades    10}
\end{Highlighting}
\end{Shaded}

These row numbers are helpful, but can quickly accumulate if you start
saving them. R will add a new set of numbers by default each time you
read the file back in. Avoid this by always setting
\texttt{row.names\ =\ FALSE} when you use a function in the
\texttt{write} family.

\subsection{Compressing Files}\label{compressing-files}

To compress a plain-text file, surround the file name or file path with
the function \texttt{bzfile}, \texttt{gzfile}, or \texttt{xzfile}. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write.csv}\NormalTok{(poker, }\AttributeTok{file =} \FunctionTok{bzfile}\NormalTok{(}\StringTok{"data/poker.csv.bz2"}\NormalTok{), }\AttributeTok{row.names =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Each of these functions will compress the output with a different type
of compression format, shown in Table~\ref{tbl-compression}.

\begin{longtable}[]{@{}ll@{}}
\caption{R comes with three helper functions for compressing
files}\label{tbl-compression}\tabularnewline
\toprule\noalign{}
Function & Compression type \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Function & Compression type \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{bzfile} & bzip2 \\
\texttt{gzfile} & gnu zip (gzip) \\
\texttt{xzfile} & xz compression \\
\end{longtable}

It is a good idea to adjust your file's extension to reflect the
compression. R's \texttt{read} functions will open plain-text files
compressed in any of these formats. For example, you could read a
compressed file named \emph{poker.csv.bz2} with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{read.csv}\NormalTok{(}\StringTok{"poker.csv.bz2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

or:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{read.csv}\NormalTok{(}\StringTok{"data/poker.csv.bz2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

depending on where the file is saved.

\section{R Files}\label{r-files}

R provides two file formats of its own for storing data, \emph{.RDS} and
\emph{.RData}. RDS files can store a single R object, and RData files
can store multiple R objects.

You can open a RDS file with \texttt{readRDS}. For example, if the royal
flush data was saved as \emph{poker.RDS}, you could open it with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{poker }\OtherTok{\textless{}{-}} \FunctionTok{readRDS}\NormalTok{(}\StringTok{"poker.RDS"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Opening RData files is even easier. Simply run the function
\texttt{load} with the file:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{load}\NormalTok{(}\StringTok{"file.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

There's no need to assign the output to an object. The R objects in your
RData file will be loaded into your R session with their original names.
RData files can contain multiple R objects, so loading one may read in
multiple objects. \texttt{load} doesn't tell you how many objects it is
reading in, nor what their names are, so it pays to know a little about
the RData file before you load it.

If worse comes to worst, you can keep an eye on the environment pane in
RStudio as you load an RData file. It displays all of the objects that
you have created or loaded during your R session. Another useful trick
is to put parentheses around your load command like so,
\texttt{(load("poker.RData"))}. This will cause R to print out the names
of each object it loads from the file.

Both \texttt{readRDS} and \texttt{load} take a file path as their first
argument, just like R's other read and write functions. If your file is
in your working directory, the file path will be the file name.

\subsection{Saving R Files}\label{saving-r-files}

You can save an R object like a data frame as either an RData file or an
RDS file. RData files can store multiple R objects at once, but RDS
files are the better choice because they foster reproducible code.

To save data as an RData object, use the \texttt{save} function. To save
data as a RDS object, use the \texttt{saveRDS} function. In each case,
the first argument should be the name of the R object you wish to save.
You should then include a file argument that has the file name or file
path you want to save the data set to.

For example, if you have three R objects, \texttt{a}, \texttt{b}, and
\texttt{c}, you could save them all in the same RData file and then
reload them in another R session:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{c }\OtherTok{\textless{}{-}} \DecValTok{3}
\FunctionTok{save}\NormalTok{(a, b, c, }\AttributeTok{file =} \StringTok{"stuff.RData"}\NormalTok{)}
\FunctionTok{load}\NormalTok{(}\StringTok{"stuff.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

However, if you forget the names of your objects or give your file to
someone else to use, it will be difficult to determine what was in the
file---even after you (or they) load it. The user interface for RDS
files is much more clear. You can save only one object per file, and
whoever loads it can decide what they want to call their new data. As a
bonus, you don't have to worry about \texttt{load} overwriting any R
objects that happened to have the same name as the objects you are
loading:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{saveRDS}\NormalTok{(a, }\AttributeTok{file =} \StringTok{"stuff.RDS"}\NormalTok{) }
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{readRDS}\NormalTok{(}\StringTok{"stuff.RDS"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Saving your data as an R file offers some advantages over saving your
data as a plain-text file. R automatically compresses the file and will
also save any R-related metadata associated with your object. This can
be handy if your data contains factors, dates and times, or class
attributes. You won't have to reparse this information into R the way
you would if you converted everything to a text file.

On the other hand, R files cannot be read by many other programs, which
makes them inefficient for sharing. They may also create a problem for
long-term storage if you don't think you'll have a copy of R when you
reopen the files.

\section{Excel Spreadsheets}\label{excel-spreadsheets}

Microsoft Excel is a popular spreadsheet program that has become almost
industry standard in the business world. There is a good chance that you
will need to work with an Excel spreadsheet in R at least once in your
career. You can read spreadsheets into R and also save R data as a
spreadsheet in a variety of ways.

\subsection{Export from Excel}\label{export-from-excel}

The best method for moving data from Excel to R is to export the
spreadsheet from Excel as a \emph{.csv} or \emph{.txt} file. Not only
will R be able to read the text file, so will any other data analysis
software. Text files are the lingua franca of data storage.

Exporting the data solves another difficulty as well. Excel uses
proprietary formats and metadata that will not easily transfer into R.
For example, a single Excel file can include multiple spreadsheets, each
with their own columns and macros. When Excel exports the file as a
\emph{.csv} or \emph{.txt}, it makes sure this format is transferred
into a plain-text file in the most appropriate way. R may not be able to
manage the conversion as efficiently.

To export data from Excel, open the Excel spreadsheet and then go to
Save As in the Microsoft Office Button menu. Then choose CSV in the Save
as type box that appears and save the files. You can then read the file
into R with the \texttt{read.csv} function.

\subsection{Copy and Paste}\label{copy-and-paste}

You can also copy portions of an Excel spreadsheet and paste them into
R. To do this, open the spreadsheet and select the cells you wish to
read into R. Then select Edit \textgreater{} Copy in the menu bar---or
use a keyboard shortcut---to copy the cells to your clipboard.

On most operating systems, you can read the data stored in your
clipboard into R with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{read.table}\NormalTok{(}\StringTok{"clipboard"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

On Macs you will need to use:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{read.table}\NormalTok{(}\FunctionTok{pipe}\NormalTok{(}\StringTok{"pbpaste"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

If the cells contain values with spaces in them, this will disrupt
\texttt{read.table}. You can try another \texttt{read} function (or just
formally export the data from Excel) before reading it into R.

\subsection{XLConnect}\label{xlconnect}

Many packages have been written to help you read Excel files directly
into R. Unfortunately, many of these packages do not work on all
operating systems. Others have been made out of date by the \emph{.xlsx}
file format. One package that does work on all file systems (and gets
good reviews) is the XLConnect package. To use it, you'll need to
install and load the package:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"XLConnect"}\NormalTok{)}
\FunctionTok{library}\NormalTok{(XLConnect)}
\end{Highlighting}
\end{Shaded}

XLConnect relies on Java to be platform independent. So when you first
open XLConnect, RStudio may ask to download a Java Runtime Environment
if you do not already have one.

\subsection{Reading Spreadsheets}\label{reading-spreadsheets}

You can use XLConnect to read in an Excel spreadsheet with either a one-
or a two-step process. I'll start with the two-step process. First, load
an Excel workbook with \texttt{loadWorkbook}. \texttt{loadWorkbook} can
load both \emph{.xls} and \emph{.xlsx} files. It takes one argument: the
file path to your Excel workbook (this will be the name of the workbook
if it is saved in your working directory):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wb }\OtherTok{\textless{}{-}} \FunctionTok{loadWorkbook}\NormalTok{(}\StringTok{"file.xlsx"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Next, read a spreadsheet from the workbook with \texttt{readWorksheet},
which takes several arguments. The first argument should be a workbook
object created with \texttt{loadWorkbook}. The next argument,
\texttt{sheet}, should be the name of the spreadsheet in the workbook
that you would like to read into R. This will be the name that appears
on the bottom tab of the spreadsheet. You can also give \texttt{sheet} a
number, which specifies the sheet that you want to read in (one for the
first sheet, two for the second, and so on).

\texttt{readWorksheet} then takes four arguments that specify a bounding
box of cells to read in: \texttt{startRow}, \texttt{startCol},
\texttt{endRow}, and \texttt{endCol}. Use \texttt{startRow} and
\texttt{startCol} to describe the cell in the top-left corner of the
bounding box of cells that you wish to read in. Use \texttt{endRow} and
\texttt{endCol} to specify the cell in the bottom-right corner of the
bounding box. Each of these arguments takes a number. If you do not
supply bounding arguments, \texttt{readWorksheet} will read in the
rectangular region of cells in the spreadsheet that appears to contain
data. \texttt{readWorksheet} will assume that this region contains a
header row, but you can tell it otherwise with
\texttt{header\ =\ FALSE}.

So to read in the first worksheet from \texttt{wb}, you could use:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sheet1 }\OtherTok{\textless{}{-}} \FunctionTok{readWorksheet}\NormalTok{(wb, }\AttributeTok{sheet =} \DecValTok{1}\NormalTok{, }\AttributeTok{startRow =} \DecValTok{0}\NormalTok{, }\AttributeTok{startCol =} \DecValTok{0}\NormalTok{, }
  \AttributeTok{endRow =} \DecValTok{100}\NormalTok{, }\AttributeTok{endCol =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

R will save the output as a data frame. All of the arguments in
\texttt{readWorkbook} except the first are vectorized, so you can use it
to read in multiple sheets from the same workbook at once (or multiple
cell regions from a single worksheet). In this case,
\texttt{readWorksheet} will return a list of data frames.

You can combine these two steps with \texttt{readWorksheetFromFile}. It
takes the file argument from \texttt{loadWorkbook} and combines it with
the arguments from \texttt{readWorksheet}. You can use it to read one or
more sheets straight from an Excel file:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sheet1 }\OtherTok{\textless{}{-}} \FunctionTok{readWorksheetFromFile}\NormalTok{(}\StringTok{"file.xlsx"}\NormalTok{, }\AttributeTok{sheet =} \DecValTok{1}\NormalTok{, }\AttributeTok{startRow =} \DecValTok{0}\NormalTok{, }
  \AttributeTok{startCol =} \DecValTok{0}\NormalTok{, }\AttributeTok{endRow =} \DecValTok{100}\NormalTok{, }\AttributeTok{endCol =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{Writing Spreadsheets}\label{writing-spreadsheets}

Writing to an Excel spreadsheet is a four-step process. First, you need
to set up a workbook object with \texttt{loadWorkbook}. This works just
as before, except if you are not using an existing Excel file, you
should add the argument \texttt{create\ =\ TRUE}. XLConnect will create
a blank workbook. When you save it, XLConnect will write it to the file
location that you specified here with \texttt{loadWorkbook}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wb }\OtherTok{\textless{}{-}} \FunctionTok{loadWorkbook}\NormalTok{(}\StringTok{"file.xlsx"}\NormalTok{, }\AttributeTok{create =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Next, you need to create a worksheet inside your workbook object with
\texttt{createSheet}. Tell \texttt{createSheet} which workbook to place
the sheet in and which to use for the sheet.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{createSheet}\NormalTok{(wb, }\StringTok{"Sheet 1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Then you can save your data frame or matrix to the sheet with
\texttt{writeWorksheet}. The first argument of \texttt{writeWorksheet},
\texttt{object}, is the workbook to write the data to. The second
argument, \texttt{data}, is the data to write. The third argument,
\texttt{sheet}, is the name of the sheet to write it to. The next two
arguments, \texttt{startRow} and \texttt{startCol}, tell R where in the
spreadsheet to place the upper-left cell of the new data. These
arguments each default to 1. Finally, you can use \texttt{header} to
tell R whether your column names should be written with the data:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{writeWorksheet}\NormalTok{(wb, }\AttributeTok{data =}\NormalTok{ poker, }\AttributeTok{sheet =} \StringTok{"Sheet 1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Once you have finished adding sheets and data to your workbook, you can
save it by running \texttt{saveWorkbook} on the workbook object. R will
save the workbook to the file name or path you provided in
\texttt{loadWorkbook}. If this leads to an existing Excel file, R will
overwrite it. If it leads to a new file, R will create it.

You can also collapse these steps into a single call with
\texttt{writeWorksheetToFile}, like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{writeWorksheetToFile}\NormalTok{(}\StringTok{"file.xlsx"}\NormalTok{, }\AttributeTok{data =}\NormalTok{ poker, }\AttributeTok{sheet =} \StringTok{"Sheet 1"}\NormalTok{, }
  \AttributeTok{startRow =} \DecValTok{1}\NormalTok{, }\AttributeTok{startCol =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The XLConnect package also lets you do more advanced things with Excel
spreadsheets, such as writing to a named region in a spreadsheet,
working with formulas, and assigning styles to cells. You can read about
these features in XLConnect's vignette, which is accessible by loading
XLConnect and then running:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{vignette}\NormalTok{(}\StringTok{"XLConnect"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\section{Loading Files from Other
Programs}\label{loading-files-from-other-programs}

You should follow the same advice I gave you for Excel files whenever
you wish to work with file formats native to other programs: open the
file in the original program and export the data as a plain-text file,
usually a CSV. This will ensure the most faithful transcription of the
data in the file, and it will usually give you the most options for
customizing how the data is transcribed.

Sometimes, however, you may acquire a file but not the program it came
from. As a result, you won't be able to open the file in its native
program and export it as a text file. In this case, you can use one of
the functions in Table~\ref{tbl-others} to open the file. These
functions mostly come in R's \texttt{foreign} package. Each attempts to
read in a different file format with as few hiccups as possible.

\begin{longtable}[]{@{}lll@{}}
\caption{A number of functions will attempt to read the file types of
other data-analysis programs}\label{tbl-others}\tabularnewline
\toprule\noalign{}
File format & Function & Library \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
File format & Function & Library \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ERSI ArcGIS & \texttt{read.shapefile} & shapefiles \\
Matlab & \texttt{readMat} & R.matlab \\
minitab & \texttt{read.mtp} & foreign \\
SAS (permanent data set) & \texttt{read.ssd} & foreign \\
SAS (XPORT format) & \texttt{read.xport} & foreign \\
SPSS & \texttt{read.spss} & foreign \\
Stata & \texttt{read.dta} & foreign \\
Systat & \texttt{read.systat} & foreign \\
\end{longtable}

\subsection{Connecting to Databases}\label{connecting-to-databases}

You can also use R to connect to a database and read in data.

Use the RODBC package to connect to databases through an ODBC
connection.

Use the DBI package to connect to databases through individual drivers.
The DBI package provides a common syntax for working with different
databases. You will have to download a database-specific package to use
in conjunction with DBI. These packages provide the API for the native
drivers of different database programs. For MySQL use RMySQL, for SQLite
use RSQLite, for Oracle use ROracle, for PostgreSQL use RPostgreSQL, and
for databases that use drivers based on the Java Database Connectivity
(JDBC) API use RJDBC. Once you have loaded the appropriate driver
package, you can use the commands provided by DBI to access your
database.

\chapter{Debugging R Code}\label{sec-appendix-debug}

\begin{tcolorbox}[enhanced jigsaw, breakable, colback=white, colbacktitle=quarto-callout-note-color!10!white, arc=.35mm, bottomrule=.15mm, coltitle=black, left=2mm, rightrule=.15mm, colframe=quarto-callout-note-color-frame, leftrule=.75mm, opacitybacktitle=0.6, bottomtitle=1mm, toptitle=1mm, titlerule=0mm, opacityback=0, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, toprule=.15mm]

This appendix refers to environments, the topic of
\hyperref[sec-environments]{Environments}, and uses examples from
\hyperref[sec-programs]{Programs} and \hyperref[sec-s3]{S3}. You should
read through these chapters first to get the most out of this appendix.

\end{tcolorbox}

R comes with a simple set of debugging tools that RStudio amplifies. You
can use these tools to better understand code that produces an error or
returns an unexpected result. Usually this will be your own code, but
you can also examine the functions in R or one of its packages.

Debugging code can take as much creativity and insight as writing code.
There is no guarantee that you will find a bug or be able to fix it when
you do. However, you can help yourself by using R's debugging tools.
These include the \texttt{traceback}, \texttt{browser}, \texttt{debug},
\texttt{debugonce}, \texttt{trace}, and \texttt{recover} functions.

Using these tools is usually a two-step process. First, you locate
\emph{where} an error occurred. Then you try to determine \emph{why} it
occurred. You can do the first step with R's \texttt{traceback}
function.

\section{traceback}\label{traceback}

The \texttt{traceback} tool pinpoints the location of an error. Many R
functions call other R functions, which call other functions, and so on.
When an error occurs, it may not be clear which of these functions went
wrong. Let's consider an example. The following functions call one
another, and the last function creates an error (you'll see why in a
second):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{first }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() }\FunctionTok{second}\NormalTok{()}
\NormalTok{second }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() }\FunctionTok{third}\NormalTok{()}
\NormalTok{third }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() }\FunctionTok{fourth}\NormalTok{()}
\NormalTok{fourth }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() }\FunctionTok{fifth}\NormalTok{()}
\NormalTok{fifth }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() }\FunctionTok{bug}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

When you run \texttt{first}, it will call \texttt{second}, which will
call \texttt{third}, which will call \texttt{fourth}, which will call
\texttt{fifth}, which will call \texttt{bug}, a function that does not
exist. Here's what that will look like at the command line:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{first}\NormalTok{()}
\DocumentationTok{\#\#  Error in fifth() : could not find function "bug" }
\end{Highlighting}
\end{Shaded}

The error report tells us that the error occurred when R tried to run
\texttt{fifth}. It also tells us the nature of the error (there is no
function called \texttt{bug}). Here, it is obvious why R calls
\texttt{fifth}, but it might not be so obvious why R calls a function
when an error occurs in the wild.

You can see the path of functions that R called before it hit an error
by typing \texttt{traceback()} at the command line. \texttt{traceback}
will return a call stack, a list of the functions that R called in the
order that it called them. The bottom function will be the command that
you entered in the command line. The top function will be the function
that caused the error:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{traceback}\NormalTok{()}
\DocumentationTok{\#\# 5: fifth() at \#1}
\DocumentationTok{\#\# 4: fourth() at \#1}
\DocumentationTok{\#\# 3: third() at \#1}
\DocumentationTok{\#\# 2: second() at \#1}
\DocumentationTok{\#\# 1: first()}
\end{Highlighting}
\end{Shaded}

\texttt{traceback} will always refer to the last error you encountered.
If you would like to look at a less recent error, you will need to
recreate it before running \texttt{traceback}.

How can this help you? First, \texttt{traceback} returns a list of
suspects. One of these functions caused the error, and each function is
more suspicious than the ones below it. Chances are that our bug came
from \texttt{fifth} (it did), but it is also possible that an earlier
function did something odd---like call \texttt{fifth} when it shouldn't
have.

Second, \texttt{traceback} can show you if R stepped off the path that
you expected it to take. If this happened, look at the last function
before things went wrong.

Third, \texttt{traceback} can reveal the frightening extent of infinite
recursion errors. For example, if you change \texttt{fifth} so that it
calls \texttt{second}, the functions will make a loop: \texttt{second}
will call \texttt{third}, which will call \texttt{fourth}, which will
call \texttt{fifth}, which will call \texttt{second} and start the loop
over again. It is easier to do this sort of thing in practice than you
might think:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fifth }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() }\FunctionTok{second}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

When you call \texttt{first()}, R will start to run the functions. After
awhile, it will notice that it is repeating itself and will return an
error. \texttt{traceback} will show just what R was doing:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{first}\NormalTok{()}
\DocumentationTok{\#\# Error: evaluation nested too deeply: infinite recursion/options(expressions=)?}

\FunctionTok{traceback}\NormalTok{()}
\DocumentationTok{\#\# 5000: fourth() at \#1}
\DocumentationTok{\#\# 4999: third() at \#1}
\DocumentationTok{\#\# 4998: second() at \#1}
\DocumentationTok{\#\# 4997: fifth() at \#1}
\DocumentationTok{\#\# 4996: fourth() at \#1}
\DocumentationTok{\#\# 4995: third() at \#1}
\DocumentationTok{\#\# 4994: second() at \#1}
\DocumentationTok{\#\# 4993: fifth() at \#1}
\DocumentationTok{\#\# ...}
\end{Highlighting}
\end{Shaded}

Notice that there are 5,000 lines of output in this \texttt{traceback}.
If you are using RStudio, you will not get to see the traceback of an
infinite recursion error (I used the Mac GUI to get this output).
RStudio represses the traceback for infinite recursion errors to prevent
the large call stacks from pushing your console history out of R's
memory buffer. With RStudio, you will have to recognize the infinite
recursion error by its error message. However, you can still see the
imposing \texttt{traceback} by running things in a UNIX shell or the
Windows or Mac GUIs.

RStudio makes it very easy to use \texttt{traceback}. You do not even
need to type in the function name. Whenever an error occurs, RStudio
will display it in a gray box with two options. The first is Show
Traceback, shown in Figure~\ref{fig-show-traceback}.

\begin{figure}

\centering{

\includegraphics[width=0.8\linewidth,height=\textheight,keepaspectratio]{images/hopr_ae01.png}

}

\caption{\label{fig-show-traceback}RStudio's Show Traceback option.}

\end{figure}%

If you click Show Traceback, RStudio will expand the gray box and
display the \texttt{traceback} call stack, as in
Figure~\ref{fig-hide-traceback}. The Show Traceback option will persist
beside an error message in your console, even as you write new commands.
This means that you can go back and look at the call stacks for all
errors---not just the most recent error.

Imagine that you've used \texttt{traceback} to pinpoint a function that
you think might cause a bug. Now what should you do? You should try to
figure out what the function did to cause an error while it ran (if it
did anything). You can examine how the function runs with
\texttt{browser}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_ae02.png}}

}

\caption{\label{fig-hide-traceback}RStudio's Traceback display.}

\end{figure}%

\section{browser}\label{browser}

You can ask R to pause in the middle of running a function and give
control back to you with \texttt{browser}. This will let you enter new
commands at the command line. The active environment for these commands
will not be the global environment (as usual); it will be the runtime
environment of the function that you have paused. As a result, you can
look at the objects that the function is using, look up their values
with the same scoping rules that the function would use, and run code
under the same conditions that the function would run it in. This
arrangement provides the best chance for spotting the source of bugs in
a function.

To use \texttt{browser}, add the call \texttt{browser()} to the body of
a function and then resave the function. For example, if I wanted to
pause in the middle of the \texttt{score} function from
\hyperref[sec-programs]{Programs}, I could add \texttt{browser()} to the
body of \texttt{score} and then rerun the following code, which defines
\texttt{score}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{score }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{ (symbols) \{}
  \CommentTok{\# identify case}
\NormalTok{  same }\OtherTok{\textless{}{-}}\NormalTok{ symbols[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{\&\&}\NormalTok{ symbols[}\DecValTok{2}\NormalTok{] }\SpecialCharTok{==}\NormalTok{ symbols[}\DecValTok{3}\NormalTok{]}
\NormalTok{  bars }\OtherTok{\textless{}{-}}\NormalTok{ symbols }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{)}
  
  \CommentTok{\# get prize}
  \ControlFlowTok{if}\NormalTok{ (same) \{}
\NormalTok{    payouts }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"} \OtherTok{=} \DecValTok{100}\NormalTok{, }\StringTok{"7"} \OtherTok{=} \DecValTok{80}\NormalTok{, }\StringTok{"BBB"} \OtherTok{=} \DecValTok{40}\NormalTok{, }\StringTok{"BB"} \OtherTok{=} \DecValTok{25}\NormalTok{, }
      \StringTok{"B"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"C"} \OtherTok{=} \DecValTok{10}\NormalTok{, }\StringTok{"0"} \OtherTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \FunctionTok{unname}\NormalTok{(payouts[symbols[}\DecValTok{1}\NormalTok{]])}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\FunctionTok{all}\NormalTok{(bars)) \{}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    cherries }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"C"}\NormalTok{)}
\NormalTok{    prize }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)[cherries }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\NormalTok{  \}}
  
  \FunctionTok{browser}\NormalTok{()}

  \CommentTok{\# adjust for diamonds}
\NormalTok{  diamonds }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(symbols }\SpecialCharTok{==} \StringTok{"DD"}\NormalTok{)}
\NormalTok{  prize }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{\^{}}\NormalTok{ diamonds}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now whenever R runs \texttt{score}, it will come to the call
\texttt{browser()}. You can see this with the \texttt{play} function
from \hyperref[sec-programs]{Programs}. If you don't have \texttt{play}
handy, you can access it by running this code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get\_symbols }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  wheel }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"DD"}\NormalTok{, }\StringTok{"7"}\NormalTok{, }\StringTok{"BBB"}\NormalTok{, }\StringTok{"BB"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"0"}\NormalTok{)}
  \FunctionTok{sample}\NormalTok{(wheel, }\AttributeTok{size =} \DecValTok{3}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{, }
    \AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.03}\NormalTok{, }\FloatTok{0.03}\NormalTok{, }\FloatTok{0.06}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.25}\NormalTok{, }\FloatTok{0.01}\NormalTok{, }\FloatTok{0.52}\NormalTok{))}
\NormalTok{\}}

\NormalTok{play }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  symbols }\OtherTok{\textless{}{-}} \FunctionTok{get\_symbols}\NormalTok{()}
  \FunctionTok{structure}\NormalTok{(}\FunctionTok{score}\NormalTok{(symbols), }\AttributeTok{symbols =}\NormalTok{ symbols, }\AttributeTok{class =} \StringTok{"slots"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When you run \texttt{play}, \texttt{play} will call
\texttt{get\_symbols} and then \texttt{score}. As R works through
\texttt{score}, it will come across the call to \texttt{browser} and run
it. When R runs this call, several things will happen, as in
Figure~\ref{fig-browser}. First, R will stop running \texttt{score}.
Second, the command prompt will change to
\texttt{browser{[}1{]}\textgreater{}} and R will give me back control; I
can now type new commands in at the new command prompt. Third, three
buttons will appear above the console pane: Next, Continue, and Stop.
Fourth, RStudio will display the source code for \texttt{score} in the
scripts pane, and it will highlight the line that contains
\texttt{browser()}. Fifth, the environments tab will change. Instead of
revealing the objects that are saved in the global environment, it will
reveal the objects that are saved in the runtime environment of
\texttt{score} (see \hyperref[sec-environments]{Environments} for an
explanation of R's environment system). Sixth, RStudio will open a new
Traceback pane, which shows the call stack RStudio took to get to
\texttt{browser}. The most recent function, \texttt{score}, will be
highlighted.

I'm now in a new R mode, called \emph{browser mode}. Browser mode is
designed to help you uncover bugs, and the new display in RStudio is
designed to help you navigate this mode.

Any command that you run in browser mode will be evaluated in the
context of the runtime environment of the function that called
\texttt{browser}. This will be the function that is highlighted in the
new Traceback pane. Here, that function is \texttt{score}. So while we
are in browser mode, the active environment will be \texttt{score}'s
runtime environment. This lets you do two things.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_ae03.png}}

}

\caption{\label{fig-browser}RStudio updates its display whenever you
enter browser mode to help you navigate the mode.}

\end{figure}%

First, you can inspect the objects that \texttt{score} uses. The updated
Environments pane shows you which objects \texttt{score} has saved in
its local environment. You can inspect any of them by typing their name
at the browser prompt. This gives you a way to see the values of runtime
variables that you normally would not be able to access. If a value
looks clearly wrong, you may be close to finding a bug:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Browse[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\textgreater{}}\NormalTok{ symbols}
\DocumentationTok{\#\# [1] "B" "B" "0"}

\NormalTok{Browse[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\textgreater{}}\NormalTok{ same}
\DocumentationTok{\#\# [1] FALSE}
\end{Highlighting}
\end{Shaded}

Second, you can run code and see the same results that \texttt{score}
would see. For example, you could run the remaining lines of the
\texttt{score} function and see if they do anything unusual. You could
run these lines by typing them into the command prompt, or you could use
the three navigation buttons that now appear above the prompt, as in
Figure~\ref{fig-browser-buttons}.

The first button, Next, will run the next line of code in
\texttt{score}. The highlighted line in the scripts pane will advance by
one line to show you your new location in the \texttt{score} function.
If the next line begins a code chunk, like a \texttt{for} loop or an
\texttt{if} tree, R will run the whole chunk and will highlight the
whole chunk in the script window.

The second button, Continue, will run all of the remaining lines of
\texttt{score} and then exit the browser mode.

The third button, Stop, will exit browser mode without running any more
lines of \texttt{score}.

\begin{figure}

\centering{

\includegraphics[width=0.8\linewidth,height=\textheight,keepaspectratio]{images/hopr_ae04.png}

}

\caption{\label{fig-browser-buttons}You can navigate browser mode with
the three buttons at the top of the console pane.}

\end{figure}%

You can do the same things by typing the commands \texttt{n},
\texttt{c}, and \texttt{Q} into the browser prompt. This creates an
annoyance: what if you want to look up an object named \texttt{n},
\texttt{c}, or \texttt{Q}? Typing in the object name will not work, R
will either advance, continue, or quit the browser mode. Instead you
will have to look these objects up with the commands \texttt{get("n")},
\texttt{get("c")}, and \texttt{get("Q")}. \texttt{cont} is a synonym for
\texttt{c} in browser mode and \texttt{where} prints the call stack, so
you'll have to look up these objects with \texttt{get} as well.

Browser mode can help you see things from the perspective of your
functions, but it cannot show you where the bug lies. However, browser
mode can help you test hypotheses and investigate function behavior.
This is usually all you need to spot and fix a bug. The browser mode is
the basic debugging tool of R. Each of the following functions just
provides an alternate way to enter the browser mode.

Once you fix the bug, you should resave your function a third
time---this time without the \texttt{browser()} call. As long as the
browser call is in there, R will pause each time you, or another
function, calls \texttt{score}.

\section{Break Points}\label{break-points}

RStudio's break points provide a graphical way to add a \texttt{browser}
statement to a function. To use them, open the script where you've
defined a function. Then click to the left of the line number of the
line of code in the function body where you'd like to add the browser
statement. A hollow red dot will appear to show you where the break
point will occur. Then run the script by clicking the Source button at
the top of the Scripts pane. The hollow dot will turn into a solid red
dot to show that the function has a break point (see
Figure~\ref{fig-break-point}).

R will treat the break point like a \texttt{browser} statement, going
into browser mode when it encounters it. You can remove a break point by
clicking on the red dot. The dot will disappear, and the break point
will be removed.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{images/hopr_ae05.png}}

}

\caption{\label{fig-break-point}Break points provide the graphical
equivalent of a browser statement.}

\end{figure}%

Break points and \texttt{browser} provide a great way to debug functions
that you have defined. But what if you want to debug a function that
already exists in R? You can do that with the \texttt{debug} function.

\section{debug}\label{debug}

You can ``add'' a browser call to the very start of a preexisting
function with \texttt{debug}. To do this, run \texttt{debug} on the
function. For example, you can run \texttt{debug} on \texttt{sample}
with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{debug}\NormalTok{(sample)}
\end{Highlighting}
\end{Shaded}

Afterward, R will act as if there is a \texttt{browser()} statement in
the first line of the function. Whenever R runs the function, it will
immediately enter browser mode, allowing you to step through the
function one line at a time. R will continue to behave this way until
you ``remove'' the browser statement with \texttt{undebug}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{undebug}\NormalTok{(sample)}
\end{Highlighting}
\end{Shaded}

You can check whether a function is in ``debugging'' mode with
\texttt{isdebugged}. This will return \texttt{TRUE} if you've ran
\texttt{debug} on the function but have yet to run \texttt{undebug}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{isdebugged}\NormalTok{(sample)}
\DocumentationTok{\#\# FALSE}
\end{Highlighting}
\end{Shaded}

If this is all too much of a hassle, you can do what I do and use
\texttt{debugonce} instead of \texttt{debug}. R will enter browser mode
the very next time it runs the function but will automatically undebug
the function afterward. If you need to browse through the function
again, you can just run \texttt{debugonce} on it a second time.

You can recreate \texttt{debugonce} in RStudio whenever an error occurs.
``Rerun with debug'' will appear in the grey error box beneath Show
Traceback (Figure~\ref{fig-show-traceback}). If you click this option,
RStudio will rerun the command as if you had first run
\texttt{debugonce} on it. R will immediately go into browser mode,
allowing you to step through the code. The browser behavior will only
occur on this run of the code. You do not need to worry about calling
\texttt{undebug} when you are done.

\section{trace}\label{trace}

You can add the browser statement further into the function, and not at
the very start, with \texttt{trace}. \texttt{trace} takes the name of a
function as a character string and then an R expression to insert into
the function. You can also provide an \texttt{at} argument that tells
\texttt{trace} at which line of the function to place the expression. So
to insert a browser call at the fourth line of \texttt{sample}, you
would run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{trace}\NormalTok{(}\StringTok{"sample"}\NormalTok{, browser, }\AttributeTok{at =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can use \texttt{trace} to insert other R functions (not just
\texttt{browser}) into a function, but you may need to think of a clever
reason for doing so. You can also run \texttt{trace} on a function
without inserting any new code. R will prints
\texttt{trace:\textless{}the\ function\textgreater{}} at the command
line every time R runs the function. This is a great way to test a claim
I made in \hyperref[sec-s3]{S3}, that R calls \texttt{print} every time
it displays something at the command line:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{trace}\NormalTok{(print)}

\NormalTok{first}
\DocumentationTok{\#\# trace: print(function () second())}
\DocumentationTok{\#\# function() second()}

\FunctionTok{head}\NormalTok{(deck)}
\DocumentationTok{\#\# trace: print}
\DocumentationTok{\#\#    face   suit value}
\DocumentationTok{\#\# 1  king spades    13}
\DocumentationTok{\#\# 2 queen spades    12}
\DocumentationTok{\#\# 3  jack spades    11}
\DocumentationTok{\#\# 4   ten spades    10}
\DocumentationTok{\#\# 5  nine spades     9}
\DocumentationTok{\#\# 6 eight spades     8}
\end{Highlighting}
\end{Shaded}

You can revert a function to normal after calling trace on it with
\texttt{untrace}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{untrace}\NormalTok{(sample)}
\FunctionTok{untrace}\NormalTok{(print)}
\end{Highlighting}
\end{Shaded}

\section{recover}\label{recover}

The \texttt{recover} function provides one final option for debugging.
It combines the call stack of \texttt{traceback} with the browser mode
of \texttt{browser}. You can use \texttt{recover} just like
\texttt{browser}, by inserting it directly into a function's body. Let's
demonstrate \texttt{recover} with the \texttt{fifth} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fifth }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() }\FunctionTok{recover}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

When R runs \texttt{recover}, it will pause and display the call stack,
but that's not all. R gives you the option of opening a browser mode in
\emph{any} of the functions that appear in the call stack. Annoyingly,
the call stack will be displayed upside down compared to
\texttt{traceback}. The most recent function will be on the bottom, and
the original function will be on the top:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{first}\NormalTok{()}
\DocumentationTok{\#\# }
\DocumentationTok{\#\# Enter a frame number, or 0 to exit   }
\DocumentationTok{\#\# }
\DocumentationTok{\#\# 1: first()}
\DocumentationTok{\#\# 2: \#1: second()}
\DocumentationTok{\#\# 3: \#1: third()}
\DocumentationTok{\#\# 4: \#1: fourth()}
\DocumentationTok{\#\# 5: \#1: fifth()}
\end{Highlighting}
\end{Shaded}

To enter a browser mode, type in the number next to the function in
whose runtime environment you would like to browse. If you do not wish
to browse any of the functions, type \texttt{0}:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3}
\DocumentationTok{\#\# Selection: 3}
\DocumentationTok{\#\# Called from: fourth()}
\DocumentationTok{\#\# Browse[1]\textgreater{} }
\end{Highlighting}
\end{Shaded}

You can then proceed as normal. \texttt{recover} gives you a chance to
inspect variables up and down your call stack and is a powerful tool for
uncovering bugs. However, adding \texttt{recover} to the body of an R
function can be cumbersome. Most R users use it as a global option for
handling errors.

If you run the following code, R will automatically call
\texttt{recover()} whenever an error occurs:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{options}\NormalTok{(}\AttributeTok{error =}\NormalTok{ recover)}
\end{Highlighting}
\end{Shaded}

This behavior will last until you close your R session, or reverse the
behavior by calling:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{options}\NormalTok{(}\AttributeTok{error =} \ConstantTok{NULL}\NormalTok{)}
\end{Highlighting}
\end{Shaded}



\backmatter


\end{document}
